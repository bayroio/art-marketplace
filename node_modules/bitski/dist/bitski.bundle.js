(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Bitski = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AccessToken = void 0;

/**
 * Represents a Bitski access token
 */
class AccessToken {
  /**
   *
   * @param token the access token
   * @param expiresAt the token expiration date (in seconds) (optional)
   * @param scope the scopes this token represents (optional)
   */
  constructor(token, expiresAt, scope) {
    this.token = token;
    this.scope = scope;
    this.expiresAt = expiresAt;
  }
  /**
   * Creates a token from a TokenResponse object
   * @param tokenResponse The token response object to build a token from
   */


  static fromTokenResponse(tokenResponse) {
    let expiresAt;

    if (tokenResponse.expiresIn) {
      expiresAt = Math.floor(Date.now() / 1000) + tokenResponse.expiresIn;
    }

    return new AccessToken(tokenResponse.accessToken, expiresAt, tokenResponse.scope);
  }
  /**
   * Creates a token from a storage string
   * @param s JSON string representing the token
   */


  static fromString(s) {
    let parsed;

    try {
      parsed = JSON.parse(s);
    } catch (error) {
      return;
    }

    if (!parsed.token) {
      return;
    }

    return new AccessToken(parsed.token, parsed.expiresAt, parsed.scope);
  }
  /**
   * Calculates if the token is still active
   */


  get expired() {
    if (this.expiresAt) {
      const now = Math.floor(Date.now() / 1000);
      const expiresIn = this.expiresAt - now;
      return expiresIn <= 0;
    }

    return false;
  }
  /**
   * Returns a JSON string suitable for writing in local storage
   */


  toStorageString() {
    return JSON.stringify({
      expiresAt: this.expiresAt,
      scope: this.scope,
      token: this.token
    });
  }

}

exports.AccessToken = AccessToken;

},{}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OAuthManager = exports.LOGIN_HINT_SIGNUP = void 0;

var _appauth = require("@openid/appauth");

var _constants = require("../constants");

var _authenticationError = require("../errors/authentication-error");

var _noHashQueryStringUtils = require("../utils/no-hash-query-string-utils");

var _requestUtils = require("../utils/request-utils");

var _popupHandler = require("./popup-handler");

// Use this constant in login_hint to indicate that the sign up UI should be displayed
const LOGIN_HINT_SIGNUP = 'signup';
/**
 * Responsible for submitting requests to our OAuth server.
 */

exports.LOGIN_HINT_SIGNUP = LOGIN_HINT_SIGNUP;

class OAuthManager {
  /**
   * Create a new OAuth Manager
   * @param options Settings object
   * @param options.clientId string: The client id to use for various requests
   * @param options.redirectUri string: The redirect URI to use for responding to auth requests
   * @param options.configuration AuthorizationServiceConfiguration (optional): The configuration for the OAuth server
   * @param options.additionalScopes string[] (optional): Additional scopes to request outside of openid.
   * Default is offline. Pass an empty array to only request openid.
   */
  constructor(options) {
    this.clientId = options.clientId;
    this.redirectUri = options.redirectUri;
    this.configuration = options.configuration || new _appauth.AuthorizationServiceConfiguration(_constants.DEFAULT_OAUTH_CONFIGURATION);
    const additionalScopes = options.additionalScopes || _constants.DEFAULT_OPTIONAL_SCOPES;
    this.scopes = _constants.DEFAULT_SCOPES.concat(additionalScopes);
    this.tokenHandler = new _appauth.BaseTokenRequestHandler(new _appauth.FetchRequestor());
    this.notifier = new _appauth.AuthorizationNotifier();
    this.notifier.setAuthorizationListener(this.didCompleteAuthorizationFlow.bind(this));
  }
  /**
   * Trigger a popup sign in flow (the default)
   */


  signInPopup(opts) {
    opts = opts || {};
    const promise = new Promise((fulfill, reject) => {
      this.pendingResolver = {
        fulfill,
        reject
      };
    });
    this.authHandler = new _popupHandler.PopupRequestHandler();
    this.authHandler.setAuthorizationNotifier(this.notifier);
    const request = this.createAuthRequest(opts);
    this.authHandler.performAuthorizationRequest(this.configuration, request);
    return promise.then(response => {
      return this.requestAccessToken(response.code);
    });
  }
  /**
   * Trigger a redirect sign in flow. Promise should never fulfill, as you will be redirected.
   */


  signInRedirect(opts) {
    opts = opts || {};
    const promise = new Promise((fulfill, reject) => {
      this.pendingResolver = {
        fulfill,
        reject
      };
    });
    this.authHandler = new _appauth.RedirectRequestHandler(undefined, new _noHashQueryStringUtils.NoHashQueryStringUtils());
    this.authHandler.setAuthorizationNotifier(this.notifier);
    const request = this.createAuthRequest(opts);
    this.authHandler.performAuthorizationRequest(this.configuration, request); // Since this method redirects the whole window, the promise will
    // likely never complete unless we encounter an error.

    return promise;
  }
  /**
   * Attempt to finalize auth request from a redirect flow. Called from your redirect url once you've been
   * redirected back.
   */


  redirectCallback() {
    const promise = new Promise((fulfill, reject) => {
      this.pendingResolver = {
        fulfill,
        reject
      };
    });
    this.authHandler = new _appauth.RedirectRequestHandler(undefined, new _noHashQueryStringUtils.NoHashQueryStringUtils());
    this.authHandler.setAuthorizationNotifier(this.notifier);
    this.authHandler.completeAuthorizationRequestIfPossible();
    return promise.then(response => {
      return this.requestAccessToken(response.code);
    });
  }
  /**
   * Exchange an authorization code for an access token
   * @param code The authorization code to exchange
   */


  requestAccessToken(code) {
    const request = this.createTokenRequest(code);
    return this.tokenHandler.performTokenRequest(this.configuration, request);
  }
  /**
   * Request a new access token from a previous refresh token
   * @param refreshToken The refresh token to use for authorization
   */


  refreshAccessToken(refreshToken) {
    const request = this.createRefreshTokenRequest(refreshToken);
    return this.tokenHandler.performTokenRequest(this.configuration, request);
  }
  /**
   * Submit a sign out request on the oauth endpoint
   * @param accessToken The access token to sign out with
   */


  requestSignOut(accessToken) {
    return fetch("".concat(_constants.BITSKI_USER_API_HOST, "/logout"), {
      headers: {
        'Accept': 'application/json',
        'Authorization': "Bearer ".concat(accessToken),
        'Content-Type': 'application/json'
      },
      method: 'POST'
    }).then(response => {
      return (0, _requestUtils.parseResponse)(response);
    });
  }
  /**
   * Request a user's profile from the oauth server
   * @param accessToken The access token for the user
   */


  requestUserInfo(accessToken) {
    const userInfoEndpoint = this.configuration.userInfoEndpoint;

    if (!userInfoEndpoint) {
      return Promise.reject(_authenticationError.AuthenticationError.InvalidConfiguration('Could not find user info endpoint'));
    }

    return fetch(userInfoEndpoint, {
      headers: {
        Accept: 'application/json',
        Authorization: "Bearer ".concat(accessToken)
      }
    }).then(response => {
      return (0, _requestUtils.parseResponse)(response);
    });
  }
  /**
   * Internal callback from our Auth Request handler. Passes the response through to a cached promise if it exists.
   * @param request The original auth request
   * @param response The auth response if it was successful
   * @param errorResponse The error response if it failed
   */


  didCompleteAuthorizationFlow(request, response, errorResponse) {
    if (this.pendingResolver) {
      if (response) {
        this.pendingResolver.fulfill(response);
        this.pendingResolver = undefined;
      } else if (errorResponse) {
        if (errorResponse instanceof _popupHandler.PopupClosedError) {
          this.pendingResolver.reject(_authenticationError.AuthenticationError.UserCancelled());
        } else if (errorResponse instanceof _popupHandler.PopupBlockedError) {
          // Parse domain of the authority, to log better context for error.
          const urlMatch = /^(http?s:\/\/[\w.]*)\/[\w\/]*$/; // Check for matches against the authority

          const matches = this.configuration.authorizationEndpoint.match(urlMatch);
          const baseUrl = matches && matches.length > 1 ? matches[1] : '';
          this.pendingResolver.reject(_authenticationError.AuthenticationError.PopupBlocked(baseUrl));
        } else {
          this.pendingResolver.reject(_authenticationError.AuthenticationError.ServerError(errorResponse.error, errorResponse.errorDescription));
        }

        this.pendingResolver = undefined;
      }
    }
  }
  /**
   * Factory method to create an auth request
   */


  createAuthRequest(opts) {
    // Create base request
    const request = new _appauth.AuthorizationRequest({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: _appauth.AuthorizationRequest.RESPONSE_TYPE_CODE,
      scope: this.scopes.join(' ')
    }, undefined, false); // Pass options through

    if (opts.login_hint) {
      // Only assign extras if login_hint is included in the options
      request.extras = {
        login_hint: opts.login_hint
      };
    }

    return request;
  }
  /**
   * Factory method to create a token request with a refresh token
   * @param refreshToken Refresh token to use
   */


  createRefreshTokenRequest(refreshToken) {
    return new _appauth.TokenRequest({
      client_id: this.clientId,
      grant_type: _appauth.GRANT_TYPE_REFRESH_TOKEN,
      redirect_uri: this.redirectUri,
      refresh_token: refreshToken
    });
  }
  /**
   * Factory method to create a token request with an auth code
   * @param code The auth code to use
   */


  createTokenRequest(code) {
    return new _appauth.TokenRequest({
      client_id: this.clientId,
      code,
      grant_type: _appauth.GRANT_TYPE_AUTHORIZATION_CODE,
      redirect_uri: this.redirectUri
    });
  }

}

exports.OAuthManager = OAuthManager;

},{"../constants":11,"../errors/authentication-error":12,"../utils/no-hash-query-string-utils":25,"../utils/request-utils":27,"./popup-handler":4,"@openid/appauth":96}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OpenidAuthProvider = void 0;

var _bitski = require("../bitski");

var _authenticationError = require("../errors/authentication-error");

var _oauthManager = require("./oauth-manager");

var _tokenStore = require("./token-store");

var _user = require("./user");

var _userStore = require("./user-store");

class OpenidAuthProvider {
  constructor(clientId, redirectUri, additionalScopes, opts) {
    opts = opts || {};
    const settings = {
      additionalScopes,
      clientId,
      redirectUri
    };
    Object.assign(settings, opts);
    this.oauthManager = new _oauthManager.OAuthManager(settings);
    this.tokenStore = new _tokenStore.TokenStore(clientId, opts.store);
    this.userStore = new _userStore.UserStore(clientId, opts.store);
  }

  get authStatus() {
    if (this.tokenStore.currentToken) {
      return _bitski.AuthenticationStatus.Connected;
    } else if (this.tokenStore.refreshToken) {
      return _bitski.AuthenticationStatus.Expired;
    } else {
      return _bitski.AuthenticationStatus.NotConnected;
    }
  }

  getAccessToken() {
    if (this.tokenStore.currentToken) {
      return Promise.resolve(this.tokenStore.currentToken);
    }

    if (this.tokenStore.refreshToken) {
      return this.refreshAccessToken();
    }

    return Promise.reject(_authenticationError.AuthenticationError.NotSignedIn());
  }

  getRefreshToken() {
    if (this.tokenStore.refreshToken) {
      return Promise.resolve(this.tokenStore.refreshToken);
    } // Error: the user did not approve this app for offline access


    if (this.tokenStore.currentToken) {
      return Promise.reject(_authenticationError.AuthenticationError.NoRefreshToken());
    } // Error: the user is not signed in.


    return Promise.reject(_authenticationError.AuthenticationError.NotSignedIn());
  }

  invalidateToken() {
    if (this.tokenStore.currentToken) {
      this.tokenStore.invalidateCurrentToken();
    }

    if (this.signOutCallback) {
      this.signOutCallback();
    }

    return Promise.resolve();
  }

  refreshAccessToken() {
    if (this.tokenStore.refreshToken) {
      return this.oauthManager.refreshAccessToken(this.tokenStore.refreshToken).then(tokenResponse => {
        this.tokenStore.persistTokenResponse(tokenResponse);
        return tokenResponse.accessToken;
      }).catch(error => {
        // If we can't renew, we likely have bad data
        this.tokenStore.clear();
        this.userStore.clear();
        throw error;
      });
    }

    return Promise.reject(_authenticationError.AuthenticationError.NoRefreshToken());
  }

  signIn(method, opts) {
    let promise;

    switch (method) {
      case _bitski.OAuthSignInMethod.Redirect:
        promise = this.oauthManager.signInRedirect(opts);
        break;

      case _bitski.OAuthSignInMethod.Silent:
        return Promise.reject(_authenticationError.AuthenticationError.UnsupportedAuthenticationMethod());

      default:
        promise = this.oauthManager.signInPopup(opts);
        break;
    }

    return promise.then(tokenResponse => {
      this.tokenStore.persistTokenResponse(tokenResponse);
      return this.loadUser();
    });
  }

  connect() {
    return this.refreshAccessToken().then(() => {
      return this.loadUser();
    });
  }

  getUser() {
    return this.getOrFetchUser();
  }

  signInOrConnect() {
    let signInMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _bitski.OAuthSignInMethod.Popup;
    let opts = arguments.length > 1 ? arguments[1] : undefined;

    switch (this.authStatus) {
      case _bitski.AuthenticationStatus.Connected:
        return this.loadUser();

      case _bitski.AuthenticationStatus.Expired:
        return this.connect();

      case _bitski.AuthenticationStatus.NotConnected:
        return this.signIn(signInMethod, opts);
    }
  }

  redirectCallback() {
    return this.oauthManager.redirectCallback().then(tokenResponse => {
      this.tokenStore.persistTokenResponse(tokenResponse);
      return this.loadUser();
    });
  }

  signOut() {
    this.tokenStore.clear();
    this.userStore.clear(); // Call the sign out callback if one has been provided

    if (this.signOutCallback) {
      this.signOutCallback();
    } // We don't currently have the ability to invalidate access tokens, so for now simply resolve.
    // Down the road this may perform a network request to invalidate.


    return Promise.resolve();
  }

  getOrFetchUser() {
    const currentUser = this.userStore.currentUser;

    if (currentUser) {
      return Promise.resolve(currentUser);
    }

    return this.loadUser();
  }

  loadUser() {
    return this.getAccessToken().then(accessToken => {
      return this.oauthManager.requestUserInfo(accessToken);
    }).then(json => {
      return _user.User.fromJson(json);
    }).then(user => {
      this.userStore.set(user);
      return user;
    });
  }

}

exports.OpenidAuthProvider = OpenidAuthProvider;

},{"../bitski":8,"../errors/authentication-error":12,"./oauth-manager":2,"./token-store":5,"./user":7,"./user-store":6}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopupRequestHandler = exports.PopupBlockedError = exports.PopupClosedError = void 0;

var _appauth = require("@openid/appauth");

var _constants = require("../constants");

var _callback = require("../utils/callback");

var _popupValidator = require("../utils/popup-validator");

// tslint:disable max-classes-per-file
// Intermediate errors, since AuthorizationRequestHandler must return an AuthorizationError instance.
// These should not be user visible.
class PopupClosedError extends _appauth.AuthorizationError {
  constructor() {
    super({
      error: 'The popup was dismissed.'
    });
  }

}

exports.PopupClosedError = PopupClosedError;

class PopupBlockedError extends _appauth.AuthorizationError {
  constructor() {
    super({
      error: 'The popup was blocked.'
    });
  }

} // Create a popup feature string from an object with keys and values


exports.PopupBlockedError = PopupBlockedError;

function createPopupFeatureString(features) {
  // Convert to array of strings
  const featuresArray = Object.keys(features).reduce((arr, key) => {
    const value = features[key]; // convert to feature string format: top=100

    arr.push("".concat(key, "=").concat(value));
    return arr;
  }, Array()); // Join strings with ',' and finish with ';'

  return featuresArray.join(',') + ';';
} // Returns a set of attributes for a centered popup based on
// the default values from constants.ts


function createCenteredPopupFeatures() {
  const windowFeatures = _constants.DEFAULT_POPUP_FEATURES;
  const w = windowFeatures.width;
  const h = windowFeatures.height; // Fixes dual-screen position

  const dualScreenLeft = window.screenLeft || window.screenX;
  const dualScreenTop = window.screenTop || window.screenY;
  const windowWidth = window.innerWidth || document.documentElement.clientWidth || screen.width;
  const windowHeight = window.innerHeight || document.documentElement.clientHeight || screen.height;
  const left = windowWidth / 2 - w / 2;
  const top = windowHeight / 2 - h / 2;
  windowFeatures.left = left + dualScreenLeft;
  windowFeatures.top = top + dualScreenTop;
  return windowFeatures;
}

class PopupRequestHandler extends _appauth.AuthorizationRequestHandler {
  constructor() {
    let utils = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new _appauth.BasicQueryStringUtils();
    let crypto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new _appauth.DefaultCrypto();
    super(utils, crypto);
    this.popupWindow = null;
    this.isCancelled = false;
    this.isBlocked = false; // Watch for the popup being blocked

    this.validator = new _popupValidator.PopupValidator(() => {
      // Return a specific error if blocked, so that we can handle it appropriately.
      this.isBlocked = true;
      this.completeAuthorizationRequestIfPossible();
    });
  }

  performAuthorizationRequest(configuration, request) {
    const url = this.buildRequestUrl(configuration, request);
    this.pendingRequest = request;
    this.id = request.state; // Set a unique handler on the main window

    window["popupCallback_".concat(request.state)] = this.callback.bind(this); // Start monitoring to see if the popup has been closed

    this.closedTimer = window.setInterval(this.checkPopup.bind(this), _constants.CHECK_FOR_POPUP_CLOSE_INTERVAL); // Create features for popup

    const windowFeatures = createCenteredPopupFeatures(); // Create popup window

    this.popupWindow = window.open(url, '_blank', createPopupFeatureString(windowFeatures)); // Check if the popup we just created was blocked.

    this.validator.check(this.popupWindow); // Focus the popup to bring it to the front

    if (this.popupWindow) {
      this.popupWindow.focus();
    }
  }

  callback(url) {
    this.responseUrl = url;
    this.completeAuthorizationRequestIfPossible();
  } // Custom implementation to remove excess log spam


  completeAuthorizationRequestIfPossible() {
    return this.completeAuthorizationRequest().then(result => {
      if (result && this.notifier) {
        this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
      }
    });
  }

  completeAuthorizationRequest() {
    const request = this.pendingRequest; // Assert there is a pending request

    if (!request) {
      return Promise.resolve(null);
    } // Assert the request wasn't cancelled


    if (this.isCancelled === true) {
      return this.respondWithCancelled(request);
    }

    if (this.isBlocked === true) {
      return this.respondWithBlocked(request);
    } // Assert there is no error


    if (this.error) {
      return this.respondWithError(request, this.error.message);
    } // Assert there is a response url to parse


    if (!this.responseUrl) {
      return Promise.resolve(null);
    } // Parse the url into data


    const data = (0, _callback.parseUrlParams)(this.responseUrl); // Extra the state

    const state = data.state; // Validate state is same as request

    if (request.state !== state) {
      return Promise.resolve(null);
    } // Check for an error response


    const error = data.error;

    if (error) {
      // get additional optional info.
      const errorUri = data.error_uri;
      const errorDescription = data.error_description;
      return this.respondWithError(request, error, errorDescription, errorUri);
    } // Respond with a code


    const code = data.code;
    return this.respondWithCode(request, code);
  }

  respondWithBlocked(request) {
    const error = new PopupBlockedError();
    const response = {
      request,
      error,
      response: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  respondWithCancelled(request) {
    const error = new PopupClosedError();
    const response = {
      request,
      error,
      response: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  respondWithError(request, errorMessage, errorDescription, errorUri) {
    const error = new _appauth.AuthorizationError({
      error: errorMessage,
      error_description: errorDescription,
      error_uri: errorUri,
      state: request.state
    });
    const response = {
      request,
      error,
      response: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  respondWithCode(request, code) {
    let authorizationResponse = null;

    if (code) {
      authorizationResponse = new _appauth.AuthorizationResponse({
        code,
        state: request.state
      });
    }

    const response = {
      request,
      response: authorizationResponse,
      error: null
    };
    this.cleanup();
    return Promise.resolve(response);
  }

  cleanup() {
    window.clearInterval(this.closedTimer);
    delete window["popupCallback_".concat(this.id)];

    if (this.popupWindow) {
      this.popupWindow.close();
    }

    this.popupWindow = null;
    this.pendingRequest = undefined;
    this.error = undefined;
    this.id = undefined;
    this.responseUrl = undefined;
  }

  checkPopup() {
    if (this.popupWindow && this.popupWindow.closed) {
      // Stop checking
      window.clearInterval(this.closedTimer);
      this.isCancelled = true;
      this.completeAuthorizationRequestIfPossible();
    }
  }

}

exports.PopupRequestHandler = PopupRequestHandler;

},{"../constants":11,"../utils/callback":23,"../utils/popup-validator":26,"@openid/appauth":96}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TokenStore = void 0;

var _constants = require("../constants");

var _localstorageStore = require("../utils/localstorage-store");

var _accessToken = require("./access-token");

class TokenStore {
  constructor(clientId, store) {
    this.clientId = clientId;
    this.store = store || new _localstorageStore.LocalStorageStore();
    const accessTokenString = this.store.getItem(this.accessTokenKey);

    if (accessTokenString) {
      let parsedToken;

      try {
        parsedToken = _accessToken.AccessToken.fromString(accessTokenString);
      } finally {
        this.accessToken = parsedToken;
      }
    }
  }

  get currentToken() {
    if (this.accessToken && !this.accessToken.expired) {
      return this.accessToken.token;
    }
  }

  get refreshToken() {
    const token = this.store.getItem(this.refreshTokenKey);

    if (token) {
      return token;
    }
  }

  get accessTokenKey() {
    return "".concat(_constants.ACCESS_TOKEN_KEY, ".").concat(this.clientId);
  }

  get refreshTokenKey() {
    return "".concat(_constants.REFRESH_TOKEN_KEY, ".").concat(this.clientId);
  }

  persistTokenResponse(response) {
    if (response.refreshToken) {
      this.store.setItem(this.refreshTokenKey, response.refreshToken);
    }

    const parsedToken = _accessToken.AccessToken.fromTokenResponse(response);

    this.store.setItem(this.accessTokenKey, parsedToken.toStorageString());
    this.accessToken = parsedToken;
  }

  invalidateCurrentToken() {
    this.accessToken = undefined;
    this.store.clearItem(this.accessTokenKey);
  }

  clear() {
    this.accessToken = undefined;
    this.store.clearItem(this.refreshTokenKey);
    this.store.clearItem(this.accessTokenKey);
  }

}

exports.TokenStore = TokenStore;

},{"../constants":11,"../utils/localstorage-store":24,"./access-token":1}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UserStore = void 0;

var _constants = require("../constants");

var _localstorageStore = require("../utils/localstorage-store");

var _user = require("./user");

class UserStore {
  constructor(clientId, store) {
    this.clientId = clientId;
    this.store = store || new _localstorageStore.LocalStorageStore();
    this.user = this.fetchUser();
  }

  get currentUser() {
    return this.user || this.fetchUser();
  }

  get storageKey() {
    return "".concat(_constants.USER_KEY, ".").concat(this.clientId);
  }

  set(user) {
    this.user = user;
    this.cacheUser(user);
  }

  clear() {
    this.user = undefined;
    this.cacheUser(undefined);
  }

  fetchUser() {
    const userData = this.store.getItem(this.storageKey);

    if (userData) {
      return _user.User.fromString(userData);
    }
  }

  cacheUser(user) {
    if (user) {
      this.store.setItem(this.storageKey, user.toStorageString());
    } else {
      this.store.clearItem(this.storageKey);
    }
  }

}

exports.UserStore = UserStore;

},{"../constants":11,"../utils/localstorage-store":24,"./user":7}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.User = void 0;

class User {
  constructor(id, accounts, email, emailVerified, phone, phoneNumberVerified) {
    this.id = id;
    this.accounts = accounts;
    this.email = email;
    this.emailVerified = emailVerified;
    this.phoneNumber = phone;
    this.phoneNumberVerified = phoneNumberVerified;
  }

  static fromJson(json) {
    return new User(json.sub, json.accounts, json.email, json.email_verified, json.phone_number, json.phone_number_verified);
  }

  static fromString(s) {
    let parsed;

    try {
      parsed = JSON.parse(s);
    } catch (e) {
      return;
    }

    if (parsed.id) {
      return new User(parsed.id, parsed.accounts, parsed.email, parsed.emailVerified, parsed.phoneNumber, parsed.phoneNumberVerified);
    }

    return;
  }

  toStorageString() {
    return JSON.stringify({
      accounts: this.accounts,
      email: this.email,
      emailVerified: this.emailVerified,
      id: this.id,
      phoneNumber: this.phoneNumber,
      phoneNumberVerified: this.phoneNumberVerified
    });
  }

}

exports.User = User;

},{}],8:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "Kovan", {
  enumerable: true,
  get: function get() {
    return _bitskiProvider.Kovan;
  }
});
Object.defineProperty(exports, "Mainnet", {
  enumerable: true,
  get: function get() {
    return _bitskiProvider.Mainnet;
  }
});
Object.defineProperty(exports, "Rinkeby", {
  enumerable: true,
  get: function get() {
    return _bitskiProvider.Rinkeby;
  }
});
Object.defineProperty(exports, "LOGIN_HINT_SIGNUP", {
  enumerable: true,
  get: function get() {
    return _oauthManager.LOGIN_HINT_SIGNUP;
  }
});
Object.defineProperty(exports, "ConnectButtonSize", {
  enumerable: true,
  get: function get() {
    return _connectButton.ConnectButtonSize;
  }
});
Object.defineProperty(exports, "LocalStorageStore", {
  enumerable: true,
  get: function get() {
    return _localstorageStore.LocalStorageStore;
  }
});
Object.defineProperty(exports, "AuthenticationError", {
  enumerable: true,
  get: function get() {
    return _authenticationError.AuthenticationError;
  }
});
Object.defineProperty(exports, "AuthenticationErrorCode", {
  enumerable: true,
  get: function get() {
    return _authenticationError.AuthenticationErrorCode;
  }
});
Object.defineProperty(exports, "ParseError", {
  enumerable: true,
  get: function get() {
    return _parseError.ParseError;
  }
});
Object.defineProperty(exports, "ParseErrorCode", {
  enumerable: true,
  get: function get() {
    return _parseError.ParseErrorCode;
  }
});
Object.defineProperty(exports, "SignerError", {
  enumerable: true,
  get: function get() {
    return _signerError.SignerError;
  }
});
Object.defineProperty(exports, "SignerErrorCode", {
  enumerable: true,
  get: function get() {
    return _signerError.SignerErrorCode;
  }
});
exports.Bitski = exports.AuthenticationStatus = exports.OAuthSignInMethod = void 0;

var _bitskiProvider = require("bitski-provider");

var _oauthManager = require("./auth/oauth-manager");

var _openidAuthProvider = require("./auth/openid-auth-provider");

var _connectButton = require("./components/connect-button");

var _constants = require("./constants");

var _bitskiBrowserEngine = require("./providers/bitski-browser-engine");

var _index = _interopRequireDefault(require("./styles/index"));

var _callback = require("./utils/callback");

var _localstorageStore = require("./utils/localstorage-store");

var _authenticationError = require("./errors/authentication-error");

var _parseError = require("./errors/parse-error");

var _signerError = require("./errors/signer-error");

var OAuthSignInMethod;
exports.OAuthSignInMethod = OAuthSignInMethod;

(function (OAuthSignInMethod) {
  OAuthSignInMethod["Redirect"] = "REDIRECT";
  OAuthSignInMethod["Popup"] = "POPUP";
  OAuthSignInMethod["Silent"] = "SILENT";
})(OAuthSignInMethod || (exports.OAuthSignInMethod = OAuthSignInMethod = {}));

var AuthenticationStatus;
exports.AuthenticationStatus = AuthenticationStatus;

(function (AuthenticationStatus) {
  AuthenticationStatus["Connected"] = "CONNECTED";
  AuthenticationStatus["Expired"] = "EXPIRED";
  AuthenticationStatus["NotConnected"] = "NOT_CONNECTED";
})(AuthenticationStatus || (exports.AuthenticationStatus = AuthenticationStatus = {})); // Customize token and user caching


/**
 * Bitski SDK
 */
class Bitski {
  /**
   * @param clientId OAuth Client ID
   * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
   * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
   * Note: Make sure your app is approved for the scopes you are requesting first.
   * @param options Other OAuth settings. Don't change these unless you know what you are doing.
   */
  constructor(clientId, redirectUri, additionalScopes, options) {
    this.engines = new Map();
    this.signoutHandlers = [];
    this.clientId = clientId;
    this.sdkVersion = _constants.SDK_VERSION;
    this.authProvider = new _openidAuthProvider.OpenidAuthProvider(clientId, redirectUri || window.location.href, additionalScopes, options);

    if (document && document.body) {
      this.injectStyles();
    } else {
      window.addEventListener('load', () => {
        this.injectStyles();
      });
    }

    this.authProvider.signOutCallback = this.onSignOut.bind(this);
  }
  /**
   * Alternative to using our static callback.html file. Call this from your own redirect page.
   */


  static callback() {
    (0, _callback.processCallback)();
  }
  /**
   * Returns a new web3 provider for a given network.
   * @param options options for the provider, or a network name
   */


  getProvider(options) {
    // Check cache for existing provider
    const existingProvider = this.engines.get(JSON.stringify(options));

    if (existingProvider) {
      existingProvider.start();
      return existingProvider;
    } // Create a new provider if one does not exist


    let normalizedOptions = {};

    if (options && typeof options !== 'string') {
      normalizedOptions = options;
    }

    const network = this.networkFromProviderOptions(options);

    if (network === _bitskiProvider.Kovan && normalizedOptions.minGasPrice == null) {
      normalizedOptions.minGasPrice = 1;
    }

    const newProvider = this.createProvider(network, normalizedOptions);
    newProvider.start();
    this.engines.set(JSON.stringify(options), newProvider);
    return newProvider;
  }
  /**
   * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the
   * first parameter, it will automatically add it to the DOM inside that element. Make sure to add
   * a callback to get notified of login events.
   * @param options {ConnectButtonOptions} Optional configuration for the button
   * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.
   */


  getConnectButton(options, callback) {
    return new _connectButton.ConnectButton(this.authProvider, options, callback);
  }
  /**
   * Signs in or connects to bitski depending on the user's auth state.
   * Since it may open a popup, this method must be called from user interaction handler,
   * such as a click or tap handler.
   * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
   */


  start(options) {
    return this.authProvider.signInOrConnect(undefined, options);
  }
  /**
   * Check the logged in state of the user
   */


  get authStatus() {
    return this.authProvider.authStatus;
  }
  /**
   * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
   * @param options Optionally provide additional options for the sign in request.
   *
   * You can use the options parameter to request that we show the sign up form instead of the sign in form:
   * ```javascript
   * import { LOGIN_HINT_SIGNUP } from 'bitski';
   *
   * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
   * ```
   */


  signIn(options) {
    return this.authProvider.signIn(OAuthSignInMethod.Popup, options);
  }
  /**
   * Gets the current signed in user. Will reject if we are not signed in.
   */


  getUser() {
    return this.authProvider.getUser();
  }
  /**
   * Connects to bitski to get a valid access token if possible.
   */


  connect() {
    return this.authProvider.connect();
  }
  /**
   * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
   * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
   */


  signInRedirect(options) {
    this.authProvider.signIn(OAuthSignInMethod.Redirect, options);
  }
  /**
   * Call from your oauth redirect page.
   */


  redirectCallback() {
    return this.authProvider.redirectCallback();
  }
  /**
   * Retrieves the current access token for the user, if logged in.
   */


  getCurrentAccessToken() {
    return this.authProvider.getAccessToken();
  }
  /**
   * Retrieves the current refresh token for the user, if logged in.
   * Requires that the user has approved your application for offline access.
   */


  getCurrentRefreshToken() {
    return this.authProvider.getRefreshToken();
  }
  /**
   * Register a callback to be called on sign out. This is a good practice,
   * since there may be situations where you are signed out unexpectedly.
   * @param fn Your callback function
   */


  addSignOutHandler(fn) {
    this.signoutHandlers.push(fn);
  }
  /**
   * Remove a registered signout callback
   * @param fn Your callback function
   */


  removeSignOutHandler(fn) {
    const index = this.signoutHandlers.findIndex(item => item === fn);

    if (index >= 0) {
      this.signoutHandlers.splice(index, 1);
    }
  }
  /**
   * Sign the current user out of your application.
   */


  signOut() {
    this.engines.forEach(engine => engine.stop());
    return this.authProvider.signOut();
  }

  createProvider(network) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new _bitskiBrowserEngine.BitskiBrowserEngine(this.clientId, this.authProvider, this.sdkVersion, network, options);
  }

  networkFromName(networkName) {
    switch (networkName) {
      case '':
      case 'mainnet':
        return _bitskiProvider.Mainnet;

      case 'rinkeby':
        return _bitskiProvider.Rinkeby;

      case 'kovan':
        return _bitskiProvider.Kovan;

      default:
        throw new Error("Unsupported network name ".concat(networkName, ". Try passing a `network` in the options instead."));
    }
  }

  networkFromProviderOptions(options) {
    if (!options) {
      return _bitskiProvider.Mainnet;
    }

    if (typeof options === 'string') {
      return this.networkFromName(options);
    }

    if (options.network) {
      return options.network;
    }

    if (options.networkName) {
      return this.networkFromName(options.networkName);
    }

    return _bitskiProvider.Mainnet;
  }

  onSignOut() {
    this.signoutHandlers.forEach(cb => {
      cb();
    });
  }
  /**
   * Embeds Bitski's UI styles
   */


  injectStyles() {
    if (document.getElementById('BitskiEmbeddedStyles')) {
      return;
    }

    const style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.setAttribute('id', 'BitskiEmbeddedStyles');
    style.appendChild(document.createTextNode(_index.default));
    const head = document.head || document.getElementsByTagName('head')[0];
    head.appendChild(style);
  }

}

exports.Bitski = Bitski;

},{"./auth/oauth-manager":2,"./auth/openid-auth-provider":3,"./components/connect-button":9,"./constants":11,"./errors/authentication-error":12,"./errors/parse-error":13,"./errors/signer-error":14,"./providers/bitski-browser-engine":15,"./styles/index":19,"./utils/callback":23,"./utils/localstorage-store":24,"@babel/runtime/helpers/interopRequireDefault":28,"bitski-provider":149}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ConnectButton = exports.ConnectButtonSize = void 0;

var _bitski = require("../bitski");

var _authenticationError = require("../errors/authentication-error");

/**
 * Sizing options for the Bitski connect button.
 */
var ConnectButtonSize;
exports.ConnectButtonSize = ConnectButtonSize;

(function (ConnectButtonSize) {
  ConnectButtonSize["Small"] = "SMALL";
  ConnectButtonSize["Medium"] = "MEDIUM";
  ConnectButtonSize["Large"] = "LARGE";
})(ConnectButtonSize || (exports.ConnectButtonSize = ConnectButtonSize = {}));
/**
 * A button used to connect to Bitski.
 */


class ConnectButton {
  /**
   * @param authProvider An instance of an AuthProvider to process sign in requests.
   * @param options Optional ConnectButtonOptions to configure your button.
   * @param callback Optional callback to be called after successful or failed log in attempt.
   * You can also set this directly later with the `callback` property.
   */
  constructor(authProvider, options, callback) {
    // Set options to object if undefined
    options = options || {}; // Configure instance

    this.authProvider = authProvider;
    this.size = options.size || ConnectButtonSize.Medium;
    this.authIntegrationType = options.authMethod || _bitski.OAuthSignInMethod.Popup;
    this.callback = callback;
    this.signInOptions = options.signInOptions || {}; // Create the element

    this.element = document.createElement('button');
    this.configureElement();
    this.element.addEventListener('click', this.signin.bind(this)); // Embed if needed

    if (options.container) {
      options.container.appendChild(this.element);
    }
  }
  /**
   * Removes the button from the page
   */


  remove() {
    if (this.element.parentNode) {
      this.element.parentNode.removeChild(this.element);
    }
  }

  signin() {
    this.authProvider.signInOrConnect(this.authIntegrationType, this.signInOptions).then(user => {
      if (this.callback) {
        this.callback(undefined, user);
      }
    }).catch(error => {
      // Check for cancellation
      if (error instanceof _authenticationError.AuthenticationError && error.code === _authenticationError.AuthenticationErrorCode.UserCancelled) {
        // Not a real error, the user just cancelled. Trigger cancellation callback.
        if (this.onCancel) {
          this.onCancel();
        }
      } else if (this.callback) {
        // Real error. Forward to main callback.
        this.callback(error, undefined);
      }
    });
  }

  configureElement() {
    this.element.title = 'Continue with Bitski';
    this.element.innerText = 'Continue with Bitski';
    this.element.className = 'bitski-connect-button';
    let sizeClass = '';

    switch (this.size) {
      case ConnectButtonSize.Small:
        sizeClass = 'size-small';
        break;

      case ConnectButtonSize.Medium:
        sizeClass = 'size-medium';
        break;

      case ConnectButtonSize.Large:
        sizeClass = 'size-large';
        break;
    }

    this.element.classList.add(sizeClass);
  }

}

exports.ConnectButton = ConnectButton;

},{"../bitski":8,"../errors/authentication-error":12}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Dialog = void 0;
const TEMPLATE = "\n  <div class='bitski-dialog'>\n      <button class='bitski-close-button'>Close</button>\n      <div class='bitski-dialog-body'></div>\n  </div>\n";
/**
 * Basic modal dialog
 */

class Dialog {
  /**
   * Creates and displays a new dialog
   * @param content The content (HTMLElement, selector, or text) to embed in the dialog
   * @param dynamicContent Set to true to show loading state
   */
  constructor(content) {
    let dynamicContent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    // check for an element passed as content or a selector corresponding to an element
    this.content = this.parseContent(content); // Find or create dialog container

    this.container = this.createContainer(); // Inject dialog content

    this.injectTemplate(this.container, this.content); // Show a spinner if content is dynamic

    if (dynamicContent) {
      this.setLoading(true);
    } // Add close handlers


    this.addCloseHandlers(); // A short delay is required before triggering animations

    setTimeout(() => {
      this.show();
    }, 10);
  }
  /**
   * Show the dialog
   */


  show() {
    this.container.classList.add('bitski-visible', 'bitski-loaded');
  }
  /**
   * Hides the dialog, but does not remove
   */


  hide() {
    this.container.classList.remove('bitski-visible', 'bitski-loaded');
  }
  /**
   * Dismisses the dialog without triggering the close handler.
   */


  dismiss() {
    // Allow 500ms for the animations to finish before removing elements from DOM
    setTimeout(() => {
      this.container.remove();
    }, 500);
    this.hide();
  }
  /**
   * Cancels the dialog by dismissing and triggering the close handler.
   */


  close() {
    this.dismiss();

    if (this.onClose) {
      this.onClose();
    }
  }
  /**
   * Show or hide the loading indicator
   * @param loading Whether or not to display the spinner
   */


  setLoading(loading) {
    const body = document.querySelector('.bitski-dialog-body');

    if (body) {
      if (loading) {
        body.classList.add('bitski-loading');
      } else {
        body.classList.remove('bitski-loading');
      }
    }
  }
  /**
   * Determines what content to embed
   * @param content Content to parse
   */


  parseContent(content) {
    // check for an element passed as content
    if (content instanceof HTMLElement) {
      return content;
    } // determine if content is a selector


    if (document.querySelector(content)) {
      return document.querySelector(content);
    } // otherwise content is text to be appended to the dialog body


    const div = document.createElement('div');
    div.innerText = content;
    return div;
  }
  /**
   * Creates and injects the container element at the end of the body,
   * responsible for housing all the dialog-related content.
   */


  createContainer() {
    const existingContainer = document.querySelector('#bitski-dialog-container');

    if (existingContainer) {
      return existingContainer;
    }

    const container = document.createElement('div');
    container.id = 'bitski-dialog-container';
    document.body.appendChild(container);
    return container;
  }
  /**
   * Injects the provided content into the template provided
   * @param container The container element
   * @param content The content to inject in the template
   */


  injectTemplate(container, content) {
    container.innerHTML = TEMPLATE;
    const body = container.querySelector('.bitski-dialog-body');

    if (body) {
      body.appendChild(content);
    }
  }
  /**
   * Adds event listeners for events that should trigger closing the dialog
   */


  addCloseHandlers() {
    // Close on click outside of the dialog
    this.container.addEventListener('click', event => {
      if (event.target === this.container) {
        this.close();
      }
    }); // Close on escape press

    document.addEventListener('keyup', e => {
      if (e.key === 'Escape') {
        this.close();
      }
    }); // Close on close button click

    const closeButton = this.container.querySelector('.bitski-close-button');

    if (closeButton) {
      closeButton.addEventListener('click', this.close.bind(this));
    }
  }

}

exports.Dialog = Dialog;

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DEFAULT_AUTHORIZED_METHODS = exports.CACHED_METHODS = exports.USER_KEY = exports.ACCESS_TOKEN_KEY = exports.REFRESH_TOKEN_KEY = exports.DEFAULT_POPUP_FEATURES = exports.CHECK_FOR_POPUP_CLOSE_INTERVAL = exports.DEFAULT_OPTIONAL_SCOPES = exports.DEFAULT_SCOPES = exports.DEFAULT_OAUTH_CONFIGURATION = exports.IFRAME_MESSAGE_ORIGIN_INCLUDES = exports.BITSKI_WEB_BASE_URL = exports.BITSKI_RPC_BASE_URL = exports.BITSKI_TRANSACTION_API_BASE_URL = exports.BITSKI_USER_API_HOST = exports.SDK_VERSION = void 0;
// SDK
const SDK_VERSION = '0.10.7'; // URLs

exports.SDK_VERSION = SDK_VERSION;
const BITSKI_USER_API_HOST = 'https://www.bitski.com/v1';
exports.BITSKI_USER_API_HOST = BITSKI_USER_API_HOST;
const BITSKI_TRANSACTION_API_BASE_URL = 'https://api.bitski.com/v1';
exports.BITSKI_TRANSACTION_API_BASE_URL = BITSKI_TRANSACTION_API_BASE_URL;
const BITSKI_RPC_BASE_URL = 'https://api.bitski.com/v1/web3';
exports.BITSKI_RPC_BASE_URL = BITSKI_RPC_BASE_URL;
const BITSKI_WEB_BASE_URL = 'https://sign.bitski.com';
exports.BITSKI_WEB_BASE_URL = BITSKI_WEB_BASE_URL;
const IFRAME_MESSAGE_ORIGIN_INCLUDES = '.bitski.com'; // OAuth

exports.IFRAME_MESSAGE_ORIGIN_INCLUDES = IFRAME_MESSAGE_ORIGIN_INCLUDES;
const DEFAULT_OAUTH_CONFIGURATION = {
  authorization_endpoint: 'https://account.bitski.com/oauth2/auth',
  revocation_endpoint: '',
  token_endpoint: 'https://account.bitski.com/oauth2/token',
  userinfo_endpoint: 'https://account.bitski.com/userinfo'
};
exports.DEFAULT_OAUTH_CONFIGURATION = DEFAULT_OAUTH_CONFIGURATION;
const DEFAULT_SCOPES = ['openid']; // scopes that are always included

exports.DEFAULT_SCOPES = DEFAULT_SCOPES;
const DEFAULT_OPTIONAL_SCOPES = ['offline']; // scopes that are included by default, but can be overridden
// Popup Window

exports.DEFAULT_OPTIONAL_SCOPES = DEFAULT_OPTIONAL_SCOPES;
const CHECK_FOR_POPUP_CLOSE_INTERVAL = 500;
exports.CHECK_FOR_POPUP_CLOSE_INTERVAL = CHECK_FOR_POPUP_CLOSE_INTERVAL;
const DEFAULT_POPUP_FEATURES = {
  location: 'no',
  toolbar: 'no',
  width: 500,
  height: 500,
  left: 100,
  top: 100
}; // Storage

exports.DEFAULT_POPUP_FEATURES = DEFAULT_POPUP_FEATURES;
const REFRESH_TOKEN_KEY = 'bitski.refresh_token';
exports.REFRESH_TOKEN_KEY = REFRESH_TOKEN_KEY;
const ACCESS_TOKEN_KEY = 'bitski.access_token';
exports.ACCESS_TOKEN_KEY = ACCESS_TOKEN_KEY;
const USER_KEY = 'bitski.user'; // Methods

exports.USER_KEY = USER_KEY;
const CACHED_METHODS = ['eth_accounts'];
exports.CACHED_METHODS = CACHED_METHODS;
const DEFAULT_AUTHORIZED_METHODS = ['eth_sendTransaction', 'eth_signTransaction', 'eth_sign', 'personal_sign', 'eth_signTypedData', 'eth_signTypedData_v3'];
exports.DEFAULT_AUTHORIZED_METHODS = DEFAULT_AUTHORIZED_METHODS;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthenticationError = exports.AuthenticationErrorCode = void 0;
var AuthenticationErrorCode;
exports.AuthenticationErrorCode = AuthenticationErrorCode;

(function (AuthenticationErrorCode) {
  // The user is not currently signed in
  AuthenticationErrorCode[AuthenticationErrorCode["NotSignedIn"] = 1000] = "NotSignedIn"; // The user cancelled the auth request

  AuthenticationErrorCode[AuthenticationErrorCode["UserCancelled"] = 1001] = "UserCancelled"; // Either you did not request offline access, or the user did not approve your app for offline access

  AuthenticationErrorCode[AuthenticationErrorCode["NoRefreshToken"] = 1002] = "NoRefreshToken"; // You requested silent sign in, which is deprecated

  AuthenticationErrorCode[AuthenticationErrorCode["UnsupportedAuthenticationMethod"] = 1003] = "UnsupportedAuthenticationMethod"; // We received an error from the oauth server

  AuthenticationErrorCode[AuthenticationErrorCode["ServerError"] = 1004] = "ServerError"; // The SDK is configured incorrectly

  AuthenticationErrorCode[AuthenticationErrorCode["InvalidConfiguration"] = 1005] = "InvalidConfiguration"; // Popup blocked

  AuthenticationErrorCode[AuthenticationErrorCode["PopupBlocked"] = 1006] = "PopupBlocked";
})(AuthenticationErrorCode || (exports.AuthenticationErrorCode = AuthenticationErrorCode = {}));
/**
 * Represents an error that is thrown during the authentication process
 */


class AuthenticationError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'AuthenticationError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, AuthenticationError);
    }

    this.code = code;
  } // throw AuthenticationError.NotSignedIn()


  static NotSignedIn() {
    return new AuthenticationError('Not signed in.', AuthenticationErrorCode.NotSignedIn);
  } // throw AuthenticationError.UserCancelled()


  static UserCancelled() {
    return new AuthenticationError('Sign in request was cancelled.', AuthenticationErrorCode.UserCancelled);
  } // throw AuthenticationError.NoRefreshToken()


  static NoRefreshToken() {
    return new AuthenticationError('Refresh token is not available.', AuthenticationErrorCode.NoRefreshToken);
  } // throw AuthenticationError.UnsupportedAuthenticationMethod()


  static UnsupportedAuthenticationMethod() {
    return new AuthenticationError('Sign in method not supported.', AuthenticationErrorCode.UnsupportedAuthenticationMethod);
  } // throw AuthenticationError.PopupBlocked()


  static PopupBlocked(baseUrl) {
    const msg = "The popup was blocked. Please make sure ".concat(baseUrl, " is allowed to open popups.");
    return new AuthenticationError(msg, AuthenticationErrorCode.PopupBlocked);
  } // throw Authentication Error.ServerError(message, description)


  static ServerError(message, description) {
    const err = new AuthenticationError("Error from the server: ".concat(message), AuthenticationErrorCode.ServerError);
    err.description = description;
    return err;
  } // throw AuthenticationError.InvalidConfiguration()


  static InvalidConfiguration(reason) {
    return new AuthenticationError("The OAuth Configuration is invalid: ".concat(reason), AuthenticationErrorCode.InvalidConfiguration);
  }

}

exports.AuthenticationError = AuthenticationError;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParseError = exports.ParseErrorCode = void 0;
var ParseErrorCode;
exports.ParseErrorCode = ParseErrorCode;

(function (ParseErrorCode) {
  // Could not parse response as JSON
  ParseErrorCode[ParseErrorCode["InvalidJSON"] = 2000] = "InvalidJSON"; // Received an error response status,
  // but not error body was provided.

  ParseErrorCode[ParseErrorCode["NoErrorBody"] = 2001] = "NoErrorBody";
})(ParseErrorCode || (exports.ParseErrorCode = ParseErrorCode = {}));
/**
 * Represents an error that is thrown during decoding
 */


class ParseError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'ParseError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, ParseError);
    }

    this.code = code;
  }

  static InvalidJSON() {
    return new ParseError('Could not decode response as JSON', ParseErrorCode.InvalidJSON);
  }

  static UnknownError() {
    return new ParseError('An unknown error occurred.', ParseErrorCode.NoErrorBody);
  }

}

exports.ParseError = ParseError;

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignerError = exports.SignerErrorCode = void 0;
var SignerErrorCode;
exports.SignerErrorCode = SignerErrorCode;

(function (SignerErrorCode) {
  // The signer module received a request to sign via an unsupported RPC method
  SignerErrorCode[SignerErrorCode["UnsupportedMethod"] = 3000] = "UnsupportedMethod"; // The user cancelled or rejected the transaction

  SignerErrorCode[SignerErrorCode["UserCancelled"] = 3001] = "UserCancelled"; // The request is missing params for the transaction.
  // Check that params is an array, and the transaction is the first object.

  SignerErrorCode[SignerErrorCode["MissingTransaction"] = 3002] = "MissingTransaction"; // The message signature request is missing expected params.
  // Check that params is an array, and that they include both a from address, and a message to sign.

  SignerErrorCode[SignerErrorCode["MissingMessage"] = 3003] = "MissingMessage"; // Missing from address in typed data request

  SignerErrorCode[SignerErrorCode["MissingFrom"] = 3004] = "MissingFrom"; // Missing typed data params. Make sure params is an array and includes
  // both a from address, and a typed data payload.

  SignerErrorCode[SignerErrorCode["MissingTypedData"] = 3005] = "MissingTypedData";
})(SignerErrorCode || (exports.SignerErrorCode = SignerErrorCode = {}));

class SignerError extends Error {
  constructor(message, code) {
    super(message);
    this.name = 'TransactionError'; // Maintains proper stack trace for where our error was thrown (only available on V8)

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SignerError);
    }

    this.code = code;
  }

  static UnsupportedMethod() {
    return new SignerError('The method requested is not currently supported.', SignerErrorCode.UnsupportedMethod);
  }

  static UserCancelled() {
    return new SignerError('The user cancelled this transaction', SignerErrorCode.UserCancelled);
  }

  static MissingTransaction() {
    return new SignerError('Could not find transaction in request', SignerErrorCode.MissingTransaction);
  }

  static MissingMessage() {
    return new SignerError('Could not find message params in request', SignerErrorCode.MissingMessage);
  }

  static MissingFrom() {
    return new SignerError('Could not find from address in request params.', SignerErrorCode.MissingFrom);
  }

  static MissingTypedData() {
    return new SignerError('Could not find data to sign in request params.', SignerErrorCode.MissingTypedData);
  }

}

exports.SignerError = SignerError;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitskiBrowserEngine = void 0;

var _bitskiProvider = require("bitski-provider");

var _constants = require("../constants");

var _transactionSigner = require("../signing/transaction-signer");

var _authenticatedCache = require("../subproviders/authenticated-cache");

var _remoteAccounts = require("../subproviders/remote-accounts");

var _signature = require("../subproviders/signature");

// Predicate to determine if the token provider is an AuthProvider
function isAuthProvider(object) {
  return object.getUser !== undefined;
}

class BitskiBrowserEngine extends _bitskiProvider.BitskiEngine {
  constructor(clientId, tokenProvider, sdkVersion, network) {
    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};
    super(options);
    options = options || {};
    this.network = network;
    this.clientId = clientId;
    this.sdkVersion = sdkVersion;
    this.apiBaseUrl = options.apiBaseUrl || _constants.BITSKI_TRANSACTION_API_BASE_URL;
    this.webBaseUrl = options.webBaseUrl || _constants.BITSKI_WEB_BASE_URL;
    this.tokenProvider = tokenProvider;
    const defaultBitskiHeaders = {
      'X-API-KEY': this.clientId,
      'X-CLIENT-ID': this.clientId,
      'X-CLIENT-VERSION': this.sdkVersion
    };
    this.headers = defaultBitskiHeaders;
    this.rpcHeaders = {};

    if (options && options.additionalHeaders) {
      this.headers = Object.assign({}, options.additionalHeaders, this.headers);
      this.rpcHeaders = options.additionalHeaders;
    }

    if (this.network && this.network.rpcUrl.includes('bitski.com')) {
      this.rpcHeaders = Object.assign({}, this.rpcHeaders, defaultBitskiHeaders);
    }

    this.signer = new _transactionSigner.BitskiTransactionSigner(this.webBaseUrl, this.apiBaseUrl, this.headers, options.callbackURL);
    this.addSubproviders();
  }

  addSubproviders() {
    // Used for eth_accounts calls
    const accountsProvider = new _remoteAccounts.RemoteAccountSubprovider("".concat(_constants.BITSKI_RPC_BASE_URL, "/mainnet"), false, this.tokenProvider, this.headers); // Used for all other calls

    const fetchSubprovider = new _bitskiProvider.AuthenticatedFetchSubprovider(this.network.rpcUrl, false, this.tokenProvider, this.rpcHeaders); // Respond to some requests via userinfo object if available

    if (isAuthProvider(this.tokenProvider)) {
      const cacheSubprovider = new _authenticatedCache.AuthenticatedCacheSubprovider(this.tokenProvider);
      this.addProvider(cacheSubprovider);
    } // Ensure that whenever accounts are requested, they go through Bitski


    this.addProvider(accountsProvider); // Respond to requests that need signed with an iframe

    const signatureSubprovider = new _signature.SignatureSubprovider(this.network, this.signer, this.tokenProvider);
    this.addProvider(signatureSubprovider); // Finally, add our basic HTTP provider

    this.addProvider(fetchSubprovider);
  }

}

exports.BitskiBrowserEngine = BitskiBrowserEngine;

},{"../constants":11,"../signing/transaction-signer":16,"../subproviders/authenticated-cache":20,"../subproviders/remote-accounts":21,"../subproviders/signature":22,"bitski-provider":149}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BitskiTransactionSigner = void 0;

var _dialog = require("../components/dialog");

var _constants = require("../constants");

var _signerError = require("../errors/signer-error");

var _requestUtils = require("../utils/request-utils");

/**
 * This class is responsible for signing transactions. It only knows about Bitski's proprietary transaction objects.
 * It is also the only class that knows about the iframe signing implementation.
 */
class BitskiTransactionSigner {
  constructor(webBaseUrl, apiBaseUrl, defaultHeaders, callbackURL) {
    this.webBaseUrl = webBaseUrl;
    this.apiBaseUrl = apiBaseUrl;
    this.defaultHeaders = defaultHeaders;
    this.callbackURL = callbackURL; // Watch for new messages on the window.

    window.addEventListener('message', this.receiveMessage.bind(this), false);
  }

  async sign(transaction, accessToken) {
    // Submit transaction to API
    const persisted = await this.submitTransaction(transaction, accessToken); // If we have a callback URL, use the redirect flow

    if (this.callbackURL) {
      return this.redirectToCallbackURL(persisted.transaction);
    } // Show the modal (await response)


    return this.showAuthorizationModal(persisted.transaction);
  }
  /**
   * Event listener for callbacks from the iframe
   * @param event MessageEvent received from the browser
   */


  receiveMessage(event) {
    // Ignore messages from the current window, and from frames that aren't on Bitski.com
    if (event.source === window || !event.origin.includes(_constants.IFRAME_MESSAGE_ORIGIN_INCLUDES)) {
      return;
    }

    const data = event.data; // Ignore message events that don't actually have data

    if (data === undefined || data === null) {
      return;
    } // Ignore messages when we don't have a current request in flight


    if (this.currentRequest === undefined) {
      return;
    }

    const [fulfill, reject] = this.currentRequest; // Dismiss current dialog

    if (this.currentRequestDialog) {
      this.currentRequestDialog.dismiss();
    } // Call the callback to complete the request


    if (data.error) {
      reject(data.error);
    } else {
      fulfill(data.result);
    } // Clear state


    this.currentRequest = undefined;
    this.currentRequestDialog = undefined;
  }
  /**
   * Responsible for submitting the Transaction object to the API
   * @param transaction The Transaction object to submit
   * @param accessToken The current user's access token
   */


  async submitTransaction(transaction, accessToken) {
    const requestBody = {
      transaction
    };
    const headers = Object.assign({}, this.defaultHeaders, {
      'Authorization': "Bearer ".concat(accessToken),
      'Content-Type': 'application/json'
    });
    const response = await fetch("".concat(this.apiBaseUrl, "/transactions"), {
      method: 'POST',
      body: JSON.stringify(requestBody),
      headers
    });
    return (0, _requestUtils.parseResponse)(response);
  }
  /**
   * Displays the authorization form in a modal window
   * @param transaction The transaction that has been submitted
   */


  showAuthorizationModal(transaction) {
    return new Promise((fulfill, reject) => {
      const url = "".concat(this.webBaseUrl, "/transactions/").concat(transaction.id);
      const iframe = document.createElement('iframe');
      iframe.style.position = 'absolute';
      iframe.style.top = '0';
      iframe.style.left = '0';
      iframe.style.width = '100%';
      iframe.style.height = '100%';
      iframe.frameBorder = '0';
      iframe.src = url; // Dismiss any existing dialogs to prevent UI glitches.

      if (this.currentRequestDialog) {
        this.currentRequestDialog.close();
      }

      this.currentRequest = [fulfill, reject];
      this.currentRequestDialog = new _dialog.Dialog(iframe, true);

      this.currentRequestDialog.onClose = () => {
        // Capture reject callback
        reject(_signerError.SignerError.UserCancelled());
      };
    });
  }

  redirectToCallbackURL(transaction) {
    const url = "".concat(this.webBaseUrl, "/transactions/").concat(transaction.id, "?redirectURI=").concat(this.callbackURL);
    window.location.href = url;
    return Promise.resolve('');
  }

}

exports.BitskiTransactionSigner = BitskiTransactionSigner;

},{"../components/dialog":10,"../constants":11,"../errors/signer-error":14,"../utils/request-utils":27}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* tslint:disable */
const css = "\n.bitski-connect-button {\n  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, 'Helvetica Neue', sans-serif;\n  font-weight: 500;\n  background-color: #1C11D9;\n  background-repeat: no-repeat;\n  background-position: 0px 0px;\n  border: none;\n  color: #fff;\n  margin: 0;\n  padding: 0;\n  cursor: pointer;\n  text-shadow: 1px 0 1px rgba(0, 0, 0, 0.03);\n  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.14);\n  transition: background 200ms linear, transform 200ms ease-out;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n}\n.bitski-connect-button:focus,\n.bitski-connect-button:active {\n  background-color: #2117C7;\n  transform: scale(0.99, 0.99);\n  color: rgba(255, 255, 255, 0.8);\n}\n.bitski-connect-button.size-small {\n  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-sm.svg');\n  border-radius: 3px;\n  font-size: 10px;\n  height: 22px;\n  line-height: 19px;\n  padding-left: 30px;\n  padding-right: 8px;\n}\n.bitski-connect-button.size-medium {\n  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-md.svg');\n  border-radius: 4px;\n  font-size: 11px;\n  height: 30px;\n  line-height: 29px;\n  padding-left: 40px;\n  padding-right: 12px;\n}\n.bitski-connect-button.size-large {\n  background-image: url('https://cdn.bitskistatic.com/sdk/btn-v2-bg-lg.svg');\n  border-radius: 5px;\n  font-size: 14px;\n  height: 44px;\n  line-height: 44px;\n  padding-left: 57px;\n  padding-right: 15px;\n}\n";
var _default = css;
exports.default = _default;

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/* tslint:disable */
const css = "\n#bitski-dialog-container {\n  position: fixed;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  background: rgba(0, 0, 0, 0);\n  z-index: 1000;\n  transition: background linear 0.2s;\n  pointer-events: none;\n}\n#bitski-dialog-container.bitski-visible {\n  background: rgba(0, 0, 0, 0.5);\n  pointer-events: auto;\n}\n.bitski-dialog {\n  opacity: 0;\n  transform: translateY(100vh);\n  transition: opacity 300ms linear, transform 400ms cubic-bezier(0.19, 1, 0.22, 1);\n  pointer-events: none;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n#bitski-dialog-container.bitski-visible .bitski-dialog {\n  opacity: 1;\n  transform: none;\n  transition: opacity 300ms linear, transform 600ms cubic-bezier(0.19, 1, 0.22, 1);\n  pointer-events: auto;\n}\n.bitski-dialog .bitski-close-button {\n  background: transparent url('https://cdn.bitskistatic.com/sdk/close.svg') no-repeat 50% 50%;\n  position: absolute;\n  right: 12px;\n  top: 12px;\n  border: none;\n  outline: none;\n  margin: 0;\n  cursor: pointer;\n  padding: 0;\n  width: 28px;\n  height: 28px;\n  z-index: 100;\n  overflow: hidden;\n  text-indent: -1000px;\n}\n.bitski-dialog-body {\n  background: #fff;\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  z-index: 5;\n  max-width: 100%;\n}\n.bitski-dialog-body.bitski-loading::after {\n  content: \"\";\n  background: url('https://cdn.bitskistatic.com/sdk/loading.svg') no-repeat 50% 50%;\n  animation: rotate 600ms linear infinite;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  opacity: 0.3;\n  width: 38px;\n  height: 38px;\n  margin-left: -19px;\n  margin-top: -19px;\n  z-index: -1;\n}\n@media (min-width: 600px) {\n  #bitski-dialog-container {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n  .bitski-dialog {\n    position: relative;\n    width: 400px;\n    height: 420px;\n  }\n  .bitski-dialog-body {\n    border-radius: 16px;\n    overflow: hidden;\n    box-shadow: 0px 0px 0px 1px rgba(0,0,0,0.1), 0px 10px 50px rgba(0,0,0,0.4);\n  }\n}\n\n@keyframes rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  50% {\n    transform: rotate(180deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n";
var _default = css;
exports.default = _default;

},{}],19:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _connectButton = _interopRequireDefault(require("./connect-button"));

var _dialog = _interopRequireDefault(require("./dialog"));

/* tslint:disable */
const css = "\n  ".concat(_dialog.default, "\n  ").concat(_connectButton.default, "\n");
var _default = css;
exports.default = _default;

},{"./connect-button":17,"./dialog":18,"@babel/runtime/helpers/interopRequireDefault":28}],20:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AuthenticatedCacheSubprovider = void 0;

var _providerEngine = require("@bitski/provider-engine");

var _constants = require("../constants");

/*
 * Subprovider that caches values related to the user.
 */
class AuthenticatedCacheSubprovider extends _providerEngine.Subprovider {
  constructor(authProvider) {
    super();
    this.authProvider = authProvider;
    this.cachedValues = new Map();
  }

  handleRequest(payload, next, end) {
    // Only evaluate matching methods
    if (this.supportsCache(payload.method) === false) {
      return next();
    } // Allow overriding the cache


    if (payload.skipCache) {
      return next();
    } // Load from cache


    this.checkCachedValues(payload.method).then(value => {
      if (value !== undefined) {
        // Value for method is cached, return value
        end(undefined, value);
      } else {
        // Value for method is not cached, fallback to fetch
        next();
      }
    }).catch(() => {
      // If method is not supported, or we encounter an error, fallback to fetch provider
      return next();
    });
  }

  supportsCache(methodName) {
    return _constants.CACHED_METHODS.includes(methodName);
  }

  checkCachedValues(methodName) {
    // First, check in-memory cache
    if (this.cachedValues.has(methodName)) {
      return Promise.resolve(this.cachedValues.get(methodName));
    } // Fallback to local-storage cache


    switch (methodName) {
      case 'eth_accounts':
        return this.getAccounts();

      default:
        return Promise.reject(new Error('Method not supported'));
    }
  }

  getAccounts() {
    // TODO: Move this to a subscription model and load into memory automatically
    return this.authProvider.getUser().then(user => {
      if (user.accounts) {
        this.cachedValues.set('eth_accounts', user.accounts);
        return user.accounts;
      }

      throw new Error('Accounts not found on user');
    });
  }

}

exports.AuthenticatedCacheSubprovider = AuthenticatedCacheSubprovider;

},{"../constants":11,"@bitski/provider-engine":34}],21:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RemoteAccountSubprovider = void 0;

var _bitskiProvider = require("bitski-provider");

// A subprovider that loads accounts from a custom rpc endpoint.
// This is necessary because to guarantee that account related calls go through Bitski
class RemoteAccountSubprovider extends _bitskiProvider.AuthenticatedFetchSubprovider {
  handleRequest(payload, next, end) {
    if (payload.method === 'eth_accounts') {
      this.handleAuthenticatedRequest(payload, next, end);
    } else {
      next();
    }
  }

}

exports.RemoteAccountSubprovider = RemoteAccountSubprovider;

},{"bitski-provider":149}],22:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SignatureSubprovider = exports.TransactionKind = void 0;

var _providerEngine = require("@bitski/provider-engine");

var _uuid = _interopRequireDefault(require("uuid"));

var _constants = require("../constants");

var _signerError = require("../errors/signer-error");

var TransactionKind;
exports.TransactionKind = TransactionKind;

(function (TransactionKind) {
  TransactionKind["SendTransaction"] = "ETH_SEND_TRANSACTION";
  TransactionKind["SignTransaction"] = "ETH_SIGN_TRANSACTION";
  TransactionKind["Sign"] = "ETH_SIGN";
  TransactionKind["SignTypedData"] = "ETH_SIGN_TYPED_DATA";
})(TransactionKind || (exports.TransactionKind = TransactionKind = {}));
/**
 * A Subprovider that manages the interface between JSON-RPC and Bitski's proprietary transaction signing flow.
 * This class is responsible for transforming the JSON-RPC request into a Transaction object that the Bitski signer understands.
 * Also responsible for submitting the transaction to the network, and converting the response back into an RPC response.
 *
 * Important: this class assumes the transaction has all the necessary fields populated. The TransactionValidatorSubprovider
 * should be placed in front of this subprovider.
 */


class SignatureSubprovider extends _providerEngine.Subprovider {
  constructor(network, signer, tokenProvider, signatureMethods) {
    super();
    this.network = network;
    this.tokenProvider = tokenProvider;
    this.signer = signer;
    this.signatureMethods = signatureMethods || _constants.DEFAULT_AUTHORIZED_METHODS;
  }
  /**
   * Handle RPC request from engine (called by)
   * @param payload RPC request payload
   * @param next Callback to skip handling this request
   * @param end Completion handler
   */


  handleRequest(payload, next, end) {
    if (this.requiresSignature(payload.method)) {
      this.handleSignatureRequest(payload, end);
      return;
    }

    next();
  }
  /**
   * Called when a payload is received that needs a signature
   * @param payload The JSON-RPC request
   * @param callback The callback to call when the request has been handled
   */


  async handleSignatureRequest(payload, callback) {
    try {
      // Get access token
      const accessToken = await this.tokenProvider.getAccessToken(); // Prepare a transaction object

      const transaction = await this.createBitskiTransaction(payload); // Sign the transaction object

      const signedResponse = await this.signer.sign(transaction, accessToken); // Send the transaction if needed

      const result = await this.sendIfNeeded(payload, signedResponse); // Call the callback with the result

      callback(undefined, result);
    } catch (error) {
      // Call with the error if any of the steps fail
      callback(error, undefined);
    }
  }
  /** Should this subprovider handle the request?
   * @param method The RPC method of the request
   */


  requiresSignature(method) {
    return this.signatureMethods.includes(method);
  }
  /**
   * This will forward transactions that should be automatically submitted to the network, otherwise
   * resolve with the original value.
   * @param payload The original request payload
   * @param signedData signed data for the transaction
   */


  sendIfNeeded(payload, signedData) {
    if (payload.method === 'eth_sendTransaction') {
      // Create a send raw transaction payload
      const sendPayload = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_sendRawTransaction',
        params: [signedData]
      };
      return this.performRequest(sendPayload);
    }

    return Promise.resolve(signedData);
  }
  /**
   * Load the balance so the web approval dialog can give the user better context
   * @param payload Payload for the request
   */


  loadBalanceIfNeeded(payload) {
    // Only necessary if this is a transaction
    const isTransaction = payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction';
    const isCustomRPC = !this.network.rpcUrl.includes('api.bitski.com');

    if (isTransaction && isCustomRPC) {
      const transaction = payload.params[0];
      const balancePayload = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_getBalance',
        params: [transaction.from, 'latest']
      };
      return this.performRequest(balancePayload);
    }

    return Promise.resolve();
  }
  /**
   * Responsible for creating the Transaction object from a given RPC payload
   * @param payload JSON-RPC payload to extract the values from
   */


  async createBitskiTransaction(payload) {
    const context = await this.createContext(payload);
    const kind = this.kindForMethod(payload.method);
    const extractedPayload = this.createPayload(payload);
    const transaction = {
      id: (0, _uuid.default)(),
      kind,
      payload: extractedPayload,
      context
    };
    return transaction;
  }

  async createContext(request) {
    switch (request.method) {
      case 'eth_sendTransaction':
      case 'eth_signTransaction':
        const balance = await this.loadBalanceIfNeeded(request);
        return {
          chainId: this.network.chainId,
          currentBalance: balance
        };

      case 'eth_signTypedData':
      case 'eth_signTypedData_v3':
        // The from address should be the first parameter as a 20 byte hex string
        if (request.params && request.params.length > 0) {
          return {
            from: request.params[0]
          };
        }

        throw _signerError.SignerError.MissingFrom();

      default:
        // Other transaction types do not need context
        return {};
    }
  }
  /**
   * Responsible for creating the payload from a given RPC request
   * @param request JSON-RPC request to extract params from
   */


  createPayload(request) {
    switch (request.method) {
      case 'eth_sendTransaction':
      case 'eth_signTransaction':
        if (request.params && request.params.length > 0) {
          return request.params[0];
        } else {
          throw _signerError.SignerError.MissingTransaction();
        }

      case 'eth_sign':
        if (request.params && request.params.length > 1) {
          return {
            from: request.params[0],
            message: request.params[1]
          };
        } else {
          throw _signerError.SignerError.MissingMessage();
        }

      case 'personal_sign':
        if (request.params && request.params.length > 1) {
          return {
            from: request.params[1],
            message: request.params[0]
          };
        } else {
          throw _signerError.SignerError.MissingMessage();
        }

      case 'eth_signTypedData':
      case 'eth_signTypedData_v3':
        if (request.params && request.params.length > 1) {
          return request.params[1];
        } else {
          throw _signerError.SignerError.MissingTypedData();
        }

      default:
        throw _signerError.SignerError.UnsupportedMethod();
    }
  }
  /**
   * Determines a BitskiTransaction.Kind value from a given RPC method name
   * @param method The JSON-RPC method being requested
   */


  kindForMethod(method) {
    switch (method) {
      case 'eth_sendTransaction':
      case 'eth_signTransaction':
        // Convert both *sign* and *send* methods into a sign transaction.
        // (we will forward the transaction locally if needed)
        return TransactionKind.SignTransaction;

      case 'eth_sign':
      case 'personal_sign':
        return TransactionKind.Sign;

      case 'eth_signTypedData':
      case 'eth_signTypedData_v3':
        return TransactionKind.SignTypedData;

      default:
        throw _signerError.SignerError.UnsupportedMethod();
    }
  } // Wraps emitPayload in a promise


  performRequest(payload) {
    return new Promise((fulfill, reject) => {
      this.emitPayload(payload, (err, result) => {
        if (err) {
          reject(err);
        } else {
          fulfill(result.result);
        }
      });
    });
  }

}

exports.SignatureSubprovider = SignatureSubprovider;

},{"../constants":11,"../errors/signer-error":14,"@babel/runtime/helpers/interopRequireDefault":28,"@bitski/provider-engine":34,"uuid":138}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processCallback = processCallback;
exports.parseUrlParams = parseUrlParams;

/**
 * Automatically handles finalizing the oauth sign in process with the Bitski SDK
 */
function processCallback() {
  if (window.opener) {
    notifyOpener(window.location);
  } else {
    throw new Error('Parent window could not be found');
  }
}
/**
 * Notifies the opener when in a popup
 * @param url the url that contains the query params
 */


function notifyOpener(url) {
  if (window.opener) {
    if (url) {
      // parse url to get state
      const data = parseUrlParams(url);

      if (data.state) {
        const name = "popupCallback_".concat(data.state);
        const callback = window.opener[name];

        if (callback) {
          callback(url);
        } else {
          throw new Error('No callback found on opener');
        }
      } else {
        throw new Error('No state found in response');
      }
    }
  } else {
    throw new Error('No window.opener');
  }
}
/**
 * Extracts query params from the hash of the url
 * @param url the url to parse
 */


function parseUrlParams(url) {
  let params;

  if (url.href.includes('#')) {
    params = extractQuery(url.hash);
  } else if (url.href.includes('?')) {
    params = url.search.split('?').pop();
  }

  if (!params) {
    throw new Error('No params found in result');
  }

  return params.split('&').reduce((prev, item) => {
    const [key, value] = item.split('=');

    if (key && value) {
      prev[decodeURIComponent(key)] = decodeURIComponent(value);
    }

    return prev;
  }, {});
}

function extractQuery(url) {
  if (!url.includes('#')) {
    throw new Error('No params found in result');
  }

  return url.split('#').pop();
}

},{}],24:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalStorageStore = void 0;

// Default implementation of generic store interface.
// Uses localStorage or sessionStorage (pass which one you want in constructor).
class LocalStorageStore {
  constructor() {
    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : localStorage;
    this.storage = storage;
  }

  clear() {
    this.storage.clear();
  }

  getItem(key) {
    return this.storage.getItem(key);
  }

  setItem(key, value) {
    this.storage.setItem(key, value);
  }

  clearItem(key) {
    this.storage.removeItem(key);
  }

}

exports.LocalStorageStore = LocalStorageStore;

},{}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NoHashQueryStringUtils = void 0;

var _appauth = require("@openid/appauth");

class NoHashQueryStringUtils extends _appauth.BasicQueryStringUtils {
  parse(input, useHash) {
    return super.parse(input, false
    /* never use hash */
    );
  }

}

exports.NoHashQueryStringUtils = NoHashQueryStringUtils;

},{"@openid/appauth":96}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PopupValidator = void 0;

/**
 * A simple utility class that will check to see if a popup is blocked.
 * Derived from info and examples on this page:
 * https://stackoverflow.com/questions/2914/how-can-i-detect-if-a-browser-is-blocking-a-popup
 */
class PopupValidator {
  constructor(errorHandler) {
    this.errorHandler = errorHandler;
  } // Check a popup window to see if it has been blocked.
  // The error handler will be called asynchronously if
  // the window has been detected to have been blocked.


  check(popup) {
    if (popup) {
      if (/chrome/.test(navigator.userAgent.toLowerCase())) {
        setTimeout(() => {
          this.isPopupBlocked(popup);
        }, 200);
      } else {
        popup.onload = () => {
          this.isPopupBlocked(popup);
        };
      }
    } else {
      this.handleBlocked();
    }
  }

  isPopupBlocked(popup) {
    if (popup.innerHeight > 0 === false) {
      this.handleBlocked();
    }
  }

  handleBlocked() {
    this.errorHandler();
  }

}

exports.PopupValidator = PopupValidator;

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseResponse = parseResponse;

var _bitskiProvider = require("bitski-provider");

var _parseError = require("../errors/parse-error");

/**
 * Parses a Fetch Response to extract either the result or the error
 * @param response the fetch response to parse
 */
function parseResponse(response) {
  return response.json().catch(() => {
    throw _parseError.ParseError.InvalidJSON();
  }).then(json => {
    if (response.status >= 200 && response.status < 300) {
      return json;
    } else {
      if (json && json.error && json.error.message) {
        throw new _bitskiProvider.ServerError(json.error.message, response.status, response.url);
      } else if (json && json.error) {
        throw new _bitskiProvider.ServerError(json.error, response.status, response.url);
      } else {
        throw _parseError.ParseError.UnknownError();
      }
    }
  });
}

},{"../errors/parse-error":13,"bitski-provider":149}],28:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],29:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var provider_engine_error_1 = require("./errors/provider-engine-error");
var create_payload_1 = require("./util/create-payload");
// The base class which ProviderEngine will extend from that provides the basic Web3 Provider interface
var BaseProvider = /** @class */ (function (_super) {
    __extends(BaseProvider, _super);
    function BaseProvider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Modern send method
    BaseProvider.prototype.send = function (method, params) {
        var payload = create_payload_1.createPayload({ method: method, params: params });
        return this.sendPayload(payload).then(function (response) {
            return response.result;
        });
    };
    // Legacy sendAsync method
    BaseProvider.prototype.sendAsync = function (payload, cb) {
        this.sendPayload(payload).then(function (response) {
            cb(null, response);
        }).catch(function (error) {
            cb(error, null);
        });
    };
    // Whether or not this provider supports subscriptions
    BaseProvider.prototype.supportsSubscriptions = function () {
        // Override this in your subclass if you support subscriptions
        return false;
    };
    // Method to subscribe to a given subscription type
    BaseProvider.prototype.subscribe = function (subscribeMethod, subscriptionMethod, parameters) {
        // Override this with subscription implementation
        return Promise.reject(new provider_engine_error_1.ProviderEngineError('Subscriptions are not supported', provider_engine_error_1.ProviderEngineErrorCode.UnsupportedFeature));
    };
    // Method to unsubscribe
    BaseProvider.prototype.unsubscribe = function (subscriptionId, unsubscribeMethod) {
        // Override this with unsubscribe implementation
        return Promise.reject(new provider_engine_error_1.ProviderEngineError('Subscriptions are not supported', provider_engine_error_1.ProviderEngineErrorCode.UnsupportedFeature));
    };
    return BaseProvider;
}(events_1.EventEmitter));
exports.default = BaseProvider;

},{"./errors/provider-engine-error":32,"./util/create-payload":58,"events":109}],30:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var BlockTrackerErrorCode;
(function (BlockTrackerErrorCode) {
    // Block data was not found after retries
    BlockTrackerErrorCode[BlockTrackerErrorCode["BlockNotFound"] = 3000] = "BlockNotFound";
})(BlockTrackerErrorCode = exports.BlockTrackerErrorCode || (exports.BlockTrackerErrorCode = {}));
/**
 * Represents errors that occur in the block tracker
 */
var BlockTrackerError = /** @class */ (function (_super) {
    __extends(BlockTrackerError, _super);
    function BlockTrackerError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, BlockTrackerError);
        }
        _this.code = code;
        return _this;
    }
    BlockTrackerError.BlockNotFound = function (blockNumber) {
        return new BlockTrackerError("Could not load block " + blockNumber, BlockTrackerErrorCode.BlockNotFound);
    };
    return BlockTrackerError;
}(Error));
exports.BlockTrackerError = BlockTrackerError;

},{}],31:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var GasPriceErrorCode;
(function (GasPriceErrorCode) {
    GasPriceErrorCode[GasPriceErrorCode["BlockNotFound"] = 4000] = "BlockNotFound";
})(GasPriceErrorCode = exports.GasPriceErrorCode || (exports.GasPriceErrorCode = {}));
/**
 * Represents errors that occur in the gas price subprovider
 */
var GasPriceError = /** @class */ (function (_super) {
    __extends(GasPriceError, _super);
    function GasPriceError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, GasPriceError);
        }
        _this.code = code;
        return _this;
    }
    GasPriceError.BlockNotFound = function (blockNumber) {
        var msg = "Could not calculate gas. Block " + blockNumber + " was not found";
        return new GasPriceError(msg, GasPriceErrorCode.BlockNotFound);
    };
    return GasPriceError;
}(Error));
exports.GasPriceError = GasPriceError;

},{}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ProviderEngineErrorCode;
(function (ProviderEngineErrorCode) {
    ProviderEngineErrorCode[ProviderEngineErrorCode["UnhandledRequest"] = 1000] = "UnhandledRequest";
    ProviderEngineErrorCode[ProviderEngineErrorCode["MissingImplementation"] = 1001] = "MissingImplementation";
    ProviderEngineErrorCode[ProviderEngineErrorCode["UnsupportedFeature"] = 1002] = "UnsupportedFeature";
})(ProviderEngineErrorCode = exports.ProviderEngineErrorCode || (exports.ProviderEngineErrorCode = {}));
/**
 * Represents errors specific to ProviderEngine
 */
var ProviderEngineError = /** @class */ (function (_super) {
    __extends(ProviderEngineError, _super);
    function ProviderEngineError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, ProviderEngineError);
        }
        _this.code = code;
        return _this;
    }
    return ProviderEngineError;
}(Error));
exports.ProviderEngineError = ProviderEngineError;

},{}],33:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var SubscriptionErrorCode;
(function (SubscriptionErrorCode) {
    SubscriptionErrorCode[SubscriptionErrorCode["UnsupportedType"] = 2000] = "UnsupportedType";
    SubscriptionErrorCode[SubscriptionErrorCode["NotFound"] = 2001] = "NotFound";
})(SubscriptionErrorCode = exports.SubscriptionErrorCode || (exports.SubscriptionErrorCode = {}));
/**
 * Represents an error that occurs in the subscriptions subprovider
 */
var SubscriptionError = /** @class */ (function (_super) {
    __extends(SubscriptionError, _super);
    function SubscriptionError(message, code) {
        var _this = _super.call(this, message) || this;
        // Maintains proper stack trace for where our error was thrown (only available on V8)
        if (Error.captureStackTrace) {
            Error.captureStackTrace(_this, SubscriptionError);
        }
        _this.code = code;
        return _this;
    }
    SubscriptionError.UnsupportedType = function (type) {
        return new SubscriptionError("Unsupported subscription type: " + type, SubscriptionErrorCode.UnsupportedType);
    };
    SubscriptionError.NotFound = function (subscriptionId) {
        return new SubscriptionError("Subscription with id " + subscriptionId + " not found", SubscriptionErrorCode.NotFound);
    };
    return SubscriptionError;
}(Error));
exports.SubscriptionError = SubscriptionError;

},{}],34:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var provider_engine_1 = __importDefault(require("./provider-engine"));
var subprovider_1 = __importDefault(require("./subprovider"));
exports.Subprovider = subprovider_1.default;
exports.default = provider_engine_1.default;
// Errors
var block_tracker_error_1 = require("./errors/block-tracker-error");
exports.BlockTrackerError = block_tracker_error_1.BlockTrackerError;
exports.BlockTrackerErrorCode = block_tracker_error_1.BlockTrackerErrorCode;
var gas_price_error_1 = require("./errors/gas-price-error");
exports.GasPriceError = gas_price_error_1.GasPriceError;
exports.GasPriceErrorCode = gas_price_error_1.GasPriceErrorCode;
var provider_engine_error_1 = require("./errors/provider-engine-error");
exports.ProviderEngineError = provider_engine_error_1.ProviderEngineError;
exports.ProviderEngineErrorCode = provider_engine_error_1.ProviderEngineErrorCode;
var subscription_error_1 = require("./errors/subscription-error");
exports.SubscriptionError = subscription_error_1.SubscriptionError;
exports.SubscriptionErrorCode = subscription_error_1.SubscriptionErrorCode;
__export(require("./subproviders/index"));

},{"./errors/block-tracker-error":30,"./errors/gas-price-error":31,"./errors/provider-engine-error":32,"./errors/subscription-error":33,"./provider-engine":35,"./subprovider":36,"./subproviders/index":51}],35:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eachSeries_1 = __importDefault(require("async/eachSeries"));
var base_provider_1 = __importDefault(require("./base-provider"));
var provider_engine_error_1 = require("./errors/provider-engine-error");
var block_tracker_1 = __importDefault(require("./util/block-tracker"));
var stoplight_1 = __importDefault(require("./util/stoplight"));
var Web3ProviderEngine = /** @class */ (function (_super) {
    __extends(Web3ProviderEngine, _super);
    function Web3ProviderEngine(opts) {
        var _this = _super.call(this) || this;
        _this._pollForBlocks = true;
        _this._running = false;
        _this.setMaxListeners(30);
        // parse options
        opts = opts || {};
        // block polling
        var directProvider = {
            sendAsync: function (req, cb) {
                _this.sendPayload(req).then(function (res) {
                    cb(null, res);
                }).catch(function (err) {
                    cb(err);
                });
            },
        };
        if (opts.disableBlockTracking === true) {
            _this._pollForBlocks = false;
        }
        var blockTrackerProvider = opts.blockTrackerProvider || directProvider;
        _this._blockTracker = new block_tracker_1.default({
            provider: blockTrackerProvider,
            blockTracker: opts.blockTracker,
            pollingInterval: opts.pollingInterval || 4000,
        });
        _this._blockTracker.on('block', _this._setCurrentBlock.bind(_this));
        _this._blockTracker.on('sync', _this.emit.bind(_this, 'sync'));
        _this._blockTracker.on('rawBlock', _this.emit.bind(_this, 'rawBlock'));
        _this._blockTracker.on('latest', _this.emit.bind(_this, 'latest'));
        // Handle errors instead of re-emitting, since they will throw otherwise
        _this._blockTracker.on('error', function (error) {
            // Ignore errors from the block tracker unless debug is enabled
            if (opts.debug) {
                console.log('DEBUG: ' + error.message);
            }
        });
        // set initialization blocker
        _this._ready = new stoplight_1.default();
        _this._providers = [];
        return _this;
    }
    Web3ProviderEngine.prototype.isRunning = function () {
        return this._running;
    };
    Web3ProviderEngine.prototype.start = function () {
        // trigger start
        this._ready.go();
        if (this._pollForBlocks) {
            // start tracking blocks
            this._blockTracker.start();
        }
        // update state
        this._running = true;
        // signal that we started
        this.emit('start');
    };
    Web3ProviderEngine.prototype.stop = function () {
        // stop block tracking
        this._blockTracker.stop();
        // update state
        this._running = false;
        // signal that we stopped
        this.emit('stop');
    };
    Web3ProviderEngine.prototype.addProvider = function (source) {
        this._providers.push(source);
        source.setEngine(this);
    };
    Web3ProviderEngine.prototype.send = function (method, params) {
        var _this = this;
        // Wrap base class with Stoplight
        return new Promise(function (fulfill, reject) {
            _this._ready.await(function () {
                _super.prototype.send.call(_this, method, params).then(fulfill, reject);
            });
        });
    };
    Web3ProviderEngine.prototype.sendAsync = function (payload, cb) {
        var _this = this;
        // Wrap base class with Stoplight
        this._ready.await(function () {
            _super.prototype.sendAsync.call(_this, payload, cb);
        });
    };
    // Actually perform the request
    Web3ProviderEngine.prototype.sendPayload = function (payload) {
        var _this = this;
        return new Promise(function (fulfill, reject) {
            var currentProvider = -1;
            var result = null;
            var error = null;
            // Stack of subprovider next callbacks
            var stack = [];
            var next = function (callback) {
                currentProvider += 1;
                if (callback) {
                    // Insert in front since eachSeries traverses from front
                    stack.unshift(callback);
                }
                // Bubbled down as far as we could go, and the request wasn't
                // handled. Return an error.
                if (currentProvider >= _this._providers.length) {
                    // tslint:disable-next-line: max-line-length
                    var msg = "Request for method \"" + payload.method + "\" not handled by any subprovider.";
                    end(new provider_engine_error_1.ProviderEngineError(msg, provider_engine_error_1.ProviderEngineErrorCode.UnhandledRequest));
                    return;
                }
                // Handle request in next subprovider
                try {
                    var provider = _this._providers[currentProvider];
                    provider.handleRequest(payload, next, end);
                }
                catch (e) {
                    end(e);
                }
            };
            var notifySubprovider = function (fn, callback) {
                if (fn) {
                    fn(error, result, callback);
                }
                else {
                    callback();
                }
            };
            var end = function (e, r) {
                error = e;
                result = r;
                // Call any callbacks from subproviders
                eachSeries_1.default(stack, notifySubprovider).then(function () {
                    // Reconstruct JSONRPCResponse
                    var resultObj = {
                        id: payload.id,
                        jsonrpc: payload.jsonrpc,
                        result: result,
                    };
                    // Complete promise
                    if (error) {
                        reject(error);
                    }
                    else {
                        fulfill(resultObj);
                    }
                });
            };
            // Call next() to kick things off
            next();
        });
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function (bufferBlock) {
        this.currentBlock = bufferBlock;
        this.emit('block', bufferBlock);
    };
    return Web3ProviderEngine;
}(base_provider_1.default));
exports.default = Web3ProviderEngine;

},{"./base-provider":29,"./errors/provider-engine-error":32,"./util/block-tracker":57,"./util/stoplight":63,"async/eachSeries":68}],36:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var create_payload_1 = require("./util/create-payload");
// this is the base class for a subprovider -- mostly helpers
var Subprovider = /** @class */ (function (_super) {
    __extends(Subprovider, _super);
    function Subprovider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Subprovider.prototype.setEngine = function (engine) {
        var _this = this;
        this.engine = engine;
        engine.on('block', function (block) {
            _this.currentBlock = block;
        });
    };
    Subprovider.prototype.emitPayload = function (payload, cb) {
        this.engine.sendAsync(create_payload_1.createPayload(payload), cb);
    };
    return Subprovider;
}(events_1.EventEmitter));
exports.default = Subprovider;

},{"./util/create-payload":58,"events":109}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("clone"));
var eth_util_1 = require("../../util/eth-util");
var rpc_cache_utils_1 = require("../../util/rpc-cache-utils");
var cache_strategy_1 = __importDefault(require("./cache-strategy"));
//
// BlockCacheStrategy
//
var BlockCacheStrategy = /** @class */ (function (_super) {
    __extends(BlockCacheStrategy, _super);
    function BlockCacheStrategy() {
        var _this = _super.call(this) || this;
        _this.cache = {};
        return _this;
    }
    BlockCacheStrategy.prototype.getBlockCacheForPayload = function (payload, blockNumberHex) {
        var blockNumber = parseInt(blockNumberHex, 16);
        var blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            var newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    };
    BlockCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {
        var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache) {
            return miss();
        }
        var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
        var cached = blockCache[identifier];
        if (cached) {
            var clonedValue = clone_1.default(cached);
            return hit(null, clonedValue);
        }
        else {
            return miss();
        }
    };
    BlockCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {
        if (result) {
            var blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
            var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
            var clonedValue = clone_1.default(result);
            blockCache[identifier] = clonedValue;
        }
        callback();
    };
    BlockCacheStrategy.prototype.canCache = function (payload) {
        if (!rpc_cache_utils_1.canCache(payload)) {
            return false;
        }
        var blockTag = rpc_cache_utils_1.blockTagForPayload(payload);
        return (blockTag !== 'pending');
    };
    // naively removes older block caches
    BlockCacheStrategy.prototype.cacheRollOff = function (previousBlock) {
        var _this = this;
        var previousHex = eth_util_1.bufferToHex(previousBlock.number);
        var oldBlockNumber = parseInt(previousHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter(function (num) { return num <= oldBlockNumber; })
            .forEach(function (num) { return delete _this.cache[num]; });
    };
    return BlockCacheStrategy;
}(cache_strategy_1.default));
exports.default = BlockCacheStrategy;

},{"../../util/eth-util":59,"../../util/rpc-cache-utils":61,"./cache-strategy":38,"clone":111}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var CacheStrategy = /** @class */ (function () {
    function CacheStrategy() {
    }
    return CacheStrategy;
}());
exports.default = CacheStrategy;

},{}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var cache_strategy_1 = __importDefault(require("./cache-strategy"));
var perma_cache_strategy_1 = __importDefault(require("./perma-cache-strategy"));
//
// ConditionalPermaCacheStrategy
//
var ConditionalPermaCacheStrategy = /** @class */ (function (_super) {
    __extends(ConditionalPermaCacheStrategy, _super);
    function ConditionalPermaCacheStrategy(conditionals) {
        var _this = _super.call(this) || this;
        _this.strategy = new perma_cache_strategy_1.default();
        _this.conditionals = conditionals;
        return _this;
    }
    ConditionalPermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {
        return this.strategy.hitCheck(payload, requestedBlockNumber, hit, miss);
    };
    ConditionalPermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {
        var conditional = this.conditionals[payload.method];
        if (conditional) {
            if (conditional(result)) {
                this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);
            }
            else {
                callback();
            }
        }
        else {
            // Cache all requests that don't have a conditional
            this.strategy.cacheResult(payload, result, requestedBlockNumber, callback);
        }
    };
    ConditionalPermaCacheStrategy.prototype.canCache = function (payload) {
        return this.strategy.canCache(payload);
    };
    return ConditionalPermaCacheStrategy;
}(cache_strategy_1.default));
exports.default = ConditionalPermaCacheStrategy;

},{"./cache-strategy":38,"./perma-cache-strategy":40}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("clone"));
var rpc_cache_utils_1 = require("../../util/rpc-cache-utils");
var cache_strategy_1 = __importDefault(require("./cache-strategy"));
var PermaCacheStrategy = /** @class */ (function (_super) {
    __extends(PermaCacheStrategy, _super);
    function PermaCacheStrategy() {
        var _this = _super.call(this) || this;
        _this.cache = {};
        // clear cache every ten minutes
        var timeout = setInterval(function () {
            _this.cache = {};
        }, 10 * 60 * 1e3);
        // do not require the Node.js event loop to remain active
        if (timeout.unref) {
            timeout.unref();
        }
        return _this;
    }
    PermaCacheStrategy.prototype.hitCheck = function (payload, requestedBlockNumber, hit, miss) {
        var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
        var cached = this.cache[identifier];
        if (!cached) {
            return miss();
        }
        // If the block number we're requesting at is greater than or
        // equal to the block where we cached a previous response,
        // the cache is valid. If it's from earlier than the cache,
        // send it back down to the client (where it will be recached.)
        var cacheIsEarlyEnough = compareHex(requestedBlockNumber, cached.blockNumber) >= 0;
        if (cacheIsEarlyEnough) {
            var clonedValue = clone_1.default(cached.result);
            return hit(null, clonedValue);
        }
        else {
            return miss();
        }
    };
    PermaCacheStrategy.prototype.cacheResult = function (payload, result, requestedBlockNumber, callback) {
        var identifier = rpc_cache_utils_1.cacheIdentifierForPayload(payload);
        if (result) {
            var clonedValue = clone_1.default(result);
            this.cache[identifier] = {
                blockNumber: requestedBlockNumber,
                result: clonedValue,
            };
        }
        callback();
    };
    PermaCacheStrategy.prototype.canCache = function (payload) {
        return rpc_cache_utils_1.canCache(payload);
    };
    return PermaCacheStrategy;
}(cache_strategy_1.default));
exports.default = PermaCacheStrategy;
function compareHex(hexA, hexB) {
    var numA = parseInt(hexA, 16);
    var numB = parseInt(hexB, 16);
    return numA === numB ? 0 : (numA > numB ? 1 : -1);
}

},{"../../util/rpc-cache-utils":61,"./cache-strategy":38,"clone":111}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var subprovider_1 = __importDefault(require("../subprovider"));
var eth_util_1 = require("../util/eth-util");
var rpc_cache_utils_1 = require("../util/rpc-cache-utils");
var block_strategy_1 = __importDefault(require("./cache-strategies/block-strategy"));
var conditional_perma_strategy_1 = __importDefault(require("./cache-strategies/conditional-perma-strategy"));
var BlockCacheProvider = /** @class */ (function (_super) {
    __extends(BlockCacheProvider, _super);
    function BlockCacheProvider() {
        var _this = _super.call(this) || this;
        _this.isEnabled = false;
        _this.strategies = {
            perma: new conditional_perma_strategy_1.default({
                eth_getTransactionByHash: containsBlockhash,
                eth_getTransactionReceipt: containsBlockhash,
            }),
            block: new block_strategy_1.default(),
            fork: new block_strategy_1.default(),
        };
        return _this;
    }
    // setup a block listener on 'setEngine'
    BlockCacheProvider.prototype.setEngine = function (engine) {
        var _this = this;
        _super.prototype.setEngine.call(this, engine);
        // unblock initialization after first block
        engine.once('block', function () {
            _this.isEnabled = true;
            // from now on, empty old cache every block
            engine.on('block', _this.clearOldCache.bind(_this));
        });
    };
    BlockCacheProvider.prototype.handleRequest = function (payload, next, end) {
        // skip cache if told to do so
        if (payload.skipCache) {
            // console.log('CACHE SKIP - skip cache if told to do so')
            return next();
        }
        // Ignore requests for the latest block
        if (payload.method === 'eth_getBlockByNumber' && payload.params[0] === 'latest') {
            // console.log('CACHE SKIP - Ignore block polling requests.')
            return next();
        }
        // Block cache should not start handling requests until blocks have been received.
        if (!this.isEnabled) {
            return next();
        }
        // actually handle the request
        this._handleRequest(payload, next, end);
    };
    BlockCacheProvider.prototype._handleRequest = function (payload, next, end) {
        var type = rpc_cache_utils_1.cacheTypeForPayload(payload);
        var strategy = this.strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCache(payload)) {
            return next();
        }
        var blockTag = rpc_cache_utils_1.blockTagForPayload(payload);
        if (!blockTag) {
            blockTag = 'latest';
        }
        var requestedBlockNumber;
        if (blockTag === 'earliest') {
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            requestedBlockNumber = eth_util_1.bufferToHex(this.currentBlock.number);
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // console.log('REQUEST at block 0x' + requestedBlockNumber.toString('hex'))
        // end on a hit, continue on a miss
        strategy.hitCheck(payload, requestedBlockNumber, end, function () {
            // miss fallthrough to provider chain, caching the result on the way back up.
            next(function (err, result, cb) {
                // err is already handled by engine
                if (err) {
                    return cb();
                }
                strategy.cacheResult(payload, result, requestedBlockNumber, cb);
            });
        });
    };
    BlockCacheProvider.prototype.clearOldCache = function (newBlock) {
        var previousBlock = this.currentBlock;
        this.currentBlock = newBlock;
        if (!previousBlock) {
            return;
        }
        this.strategies.block.cacheRollOff(previousBlock);
        this.strategies.fork.cacheRollOff(previousBlock);
    };
    return BlockCacheProvider;
}(subprovider_1.default));
exports.default = BlockCacheProvider;
function hexToBN(hex) {
    return new bn_js_1.default(eth_util_1.toBuffer(hex));
}
function containsBlockhash(result) {
    if (!result) {
        return false;
    }
    if (!result.blockHash) {
        return false;
    }
    var hasNonZeroHash = hexToBN(result.blockHash).gt(new bn_js_1.default(0));
    return hasNonZeroHash;
}

},{"../subprovider":36,"../util/eth-util":59,"../util/rpc-cache-utils":61,"./cache-strategies/block-strategy":37,"./cache-strategies/conditional-perma-strategy":39,"bn.js":107}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var xtend_1 = __importDefault(require("xtend"));
var fixture_1 = __importDefault(require("./fixture"));
var DefaultFixtures = /** @class */ (function (_super) {
    __extends(DefaultFixtures, _super);
    function DefaultFixtures(opts) {
        var _this = this;
        opts = opts || {};
        var responses = xtend_1.default({
            web3_clientVersion: 'ProviderEngine' + '/javascript',
            net_listening: true,
            eth_hashrate: '0x00',
            eth_mining: false,
        }, opts);
        _this = _super.call(this, responses) || this;
        return _this;
    }
    return DefaultFixtures;
}(fixture_1.default));
exports.default = DefaultFixtures;

},{"./fixture":49,"xtend":143}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var asyncify_1 = __importDefault(require("async/asyncify"));
var retry_1 = __importDefault(require("async/retry"));
var waterfall_1 = __importDefault(require("async/waterfall"));
var cross_fetch_1 = __importDefault(require("cross-fetch"));
var json_rpc_error_1 = __importDefault(require("json-rpc-error"));
var promise_to_callback_1 = __importDefault(require("promise-to-callback"));
var subprovider_1 = __importDefault(require("../subprovider"));
var create_payload_1 = require("../util/create-payload");
var RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
var FetchSubprovider = /** @class */ (function (_super) {
    __extends(FetchSubprovider, _super);
    function FetchSubprovider(opts) {
        var _this = _super.call(this) || this;
        _this.rpcUrl = opts.rpcUrl;
        _this.originHttpHeaderKey = opts.originHttpHeaderKey;
        return _this;
    }
    FetchSubprovider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        var originDomain = payload.origin;
        // overwrite id to not conflict with other concurrent users
        var newPayload = this.createPayload(payload);
        // remove extra parameter from request
        delete newPayload.origin;
        var reqParams = {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(newPayload),
        };
        if (this.originHttpHeaderKey && originDomain) {
            reqParams.headers[this.originHttpHeaderKey] = originDomain;
        }
        retry_1.default({
            times: 5,
            interval: 1000,
            errorFilter: isErrorRetriable,
        }, function (cb) { return _this._submitRequest(reqParams, cb); }, function (err, result) {
            // ends on retriable error
            if (err && isErrorRetriable(err)) {
                var errMsg = "FetchSubprovider - cannot complete request. All retries exhausted.\nOriginal Error:\n" + err.toString() + "\n\n";
                var retriesExhaustedErr = new Error(errMsg);
                return end(retriesExhaustedErr);
            }
            // otherwise continue normally
            return end(err, result);
        });
    };
    FetchSubprovider.prototype.createPayload = function (payload) {
        return create_payload_1.createPayload(payload);
    };
    FetchSubprovider.prototype._submitRequest = function (reqParams, done) {
        var targetUrl = this.rpcUrl;
        promise_to_callback_1.default(cross_fetch_1.default(targetUrl, reqParams))(function (err, res) {
            if (err) {
                return done(err);
            }
            // continue parsing result
            waterfall_1.default([
                checkForHttpErrors,
                // buffer body
                function (cb) { return promise_to_callback_1.default(res.text())(cb); },
                // parse body
                asyncify_1.default(function (rawBody) { return JSON.parse(rawBody); }),
                parseResponse,
            ], done);
            function checkForHttpErrors(cb) {
                // check for errors
                switch (res.status) {
                    case 405:
                        return cb(new json_rpc_error_1.default.MethodNotFound());
                    case 418:
                        return cb(createRatelimitError());
                    case 503:
                    case 504:
                        return cb(createTimeoutError());
                    default:
                        return cb();
                }
            }
            function parseResponse(body, cb) {
                // check for error code
                if (res.status !== 200) {
                    return cb(new json_rpc_error_1.default.InternalError(body));
                }
                // check for rpc error
                if (body.error) {
                    return cb(new json_rpc_error_1.default.InternalError(body.error));
                }
                // return successful result
                cb(null, body.result);
            }
        });
    };
    return FetchSubprovider;
}(subprovider_1.default));
exports.default = FetchSubprovider;
function isErrorRetriable(err) {
    var errMsg = err.toString();
    return RETRIABLE_ERRORS.some(function (phrase) { return errMsg.includes(phrase); });
}
function createRatelimitError() {
    var msg = "Request is being rate limited.";
    var err = new Error(msg);
    return new json_rpc_error_1.default.InternalError(err);
}
function createTimeoutError() {
    var msg = "Gateway timeout. The request took too long to process. ";
    msg += "This can happen when querying logs over too wide a block range.";
    var err = new Error(msg);
    return new json_rpc_error_1.default.InternalError(err);
}

},{"../subprovider":36,"../util/create-payload":58,"async/asyncify":64,"async/retry":87,"async/waterfall":88,"cross-fetch":112,"json-rpc-error":123,"promise-to-callback":131}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var parallel_1 = __importDefault(require("async/parallel"));
var subprovider_1 = __importDefault(require("../subprovider"));
var eth_util_1 = require("../util/eth-util");
var stoplight_1 = __importDefault(require("../util/stoplight"));
var block_filter_1 = __importDefault(require("./filters/block-filter"));
var log_filter_1 = __importDefault(require("./filters/log-filter"));
var pending_tx_filter_1 = __importDefault(require("./filters/pending-tx-filter"));
var FilterSubprovider = /** @class */ (function (_super) {
    __extends(FilterSubprovider, _super);
    function FilterSubprovider(opts) {
        var _this = _super.call(this) || this;
        opts = opts || {};
        _this.filterIndex = 0;
        _this.filters = {};
        _this.filterDestroyHandlers = {};
        _this.asyncBlockHandlers = {};
        _this.asyncPendingBlockHandlers = {};
        _this._ready = new stoplight_1.default();
        _this._ready.setMaxListeners(opts.maxFilters || 25);
        _this._ready.go();
        _this.pendingBlockTimeout = opts.pendingBlockTimeout || 4000;
        _this.checkForPendingBlocksActive = false;
        // TODO: Actually load the blocks
        // we dont have engine immeditately
        setTimeout(function () {
            // asyncBlockHandlers require locking provider until updates are completed
            _this.engine.on('block', function (block) {
                // pause processing
                _this._ready.stop();
                // update filters
                var updaters = valuesFor(_this.asyncBlockHandlers).map(function (fn) { return fn.bind(null, block); });
                parallel_1.default(updaters, function (err) {
                    // tslint:disable-next-line: no-console
                    if (err) {
                        console.error(err);
                    }
                    // unpause processing
                    _this._ready.go();
                });
            });
        });
        return _this;
    }
    FilterSubprovider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        switch (payload.method) {
            case 'eth_newBlockFilter':
                this.newBlockFilter(end);
                return;
            case 'eth_newPendingTransactionFilter':
                this.newPendingTransactionFilter(end);
                this.checkForPendingBlocks();
                return;
            case 'eth_newFilter':
                this.newLogFilter(payload.params[0], end);
                return;
            case 'eth_getFilterChanges':
                this._ready.await(function () {
                    _this.getFilterChanges(payload.params[0], end);
                });
                return;
            case 'eth_getFilterLogs':
                this._ready.await(function () {
                    _this.getFilterLogs(payload.params[0], end);
                });
                return;
            case 'eth_uninstallFilter':
                this._ready.await(function () {
                    _this.uninstallFilter(payload.params[0], end);
                });
                return;
            default:
                next();
                return;
        }
    };
    FilterSubprovider.prototype.newBlockFilter = function (cb) {
        var _this = this;
        this._getBlockNumber(function (err, blockNumber) {
            if (err) {
                return cb(err);
            }
            var filter = new block_filter_1.default({
                blockNumber: blockNumber,
            });
            var newBlockHandler = filter.update.bind(filter);
            _this.engine.on('block', newBlockHandler);
            var destroyHandler = function () {
                _this.engine.removeListener('block', newBlockHandler);
            };
            _this.filterIndex++;
            _this.filters[_this.filterIndex] = filter;
            _this.filterDestroyHandlers[_this.filterIndex] = destroyHandler;
            var hexFilterIndex = eth_util_1.intToHex(_this.filterIndex);
            cb(null, hexFilterIndex);
        });
    };
    FilterSubprovider.prototype.newLogFilter = function (opts, done) {
        var _this = this;
        var filter = new log_filter_1.default(opts);
        var newLogHandler = filter.update.bind(filter);
        var blockHandler = function (block, cb) {
            _this._logsForBlock(block, function (err, logs) {
                if (err) {
                    return cb(err);
                }
                newLogHandler(logs);
                cb();
            });
        };
        this.filterIndex++;
        this.asyncBlockHandlers[this.filterIndex] = blockHandler;
        this.filters[this.filterIndex] = filter;
        var hexFilterIndex = eth_util_1.intToHex(this.filterIndex);
        done(null, hexFilterIndex);
    };
    FilterSubprovider.prototype.newPendingTransactionFilter = function (done) {
        var _this = this;
        var filter = new pending_tx_filter_1.default();
        var newTxHandler = filter.update.bind(filter);
        var blockHandler = function (block, cb) {
            _this._txHashesForBlock(block, function (err, txs) {
                if (err) {
                    return cb(err);
                }
                newTxHandler(txs);
                cb();
            });
        };
        this.filterIndex++;
        this.asyncPendingBlockHandlers[this.filterIndex] = blockHandler;
        this.filters[this.filterIndex] = filter;
        var hexFilterIndex = eth_util_1.intToHex(this.filterIndex);
        done(null, hexFilterIndex);
    };
    FilterSubprovider.prototype.getFilterChanges = function (hexFilterId, cb) {
        var filterId = parseInt(hexFilterId, 16);
        var filter = this.filters[filterId];
        // if (!filter) { console.warn('FilterSubprovider - no filter with that id:', hexFilterId); }
        if (!filter) {
            return cb(null, []);
        }
        var results = filter.getChanges();
        filter.clearChanges();
        cb(null, results);
    };
    FilterSubprovider.prototype.getFilterLogs = function (hexFilterId, cb) {
        var filterId = parseInt(hexFilterId, 16);
        var filter = this.filters[filterId];
        // if (!filter) { console.warn('FilterSubprovider - no filter with that id:', hexFilterId); }
        if (!filter) {
            return cb(null, []);
        }
        if (filter.type === 'log') {
            this.emitPayload({
                id: 0,
                jsonrpc: '2.0',
                method: 'eth_getLogs',
                params: [{
                        fromBlock: filter.fromBlock,
                        toBlock: filter.toBlock,
                        address: filter.address,
                        topics: filter.topics,
                    }],
            }, function (err, res) {
                if (err) {
                    return cb(err);
                }
                cb(null, res.result);
            });
        }
        else {
            cb(null, []);
        }
    };
    FilterSubprovider.prototype.uninstallFilter = function (hexFilterId, cb) {
        var filterId = parseInt(hexFilterId, 16);
        var filter = this.filters[filterId];
        if (!filter) {
            cb(null, false);
            return;
        }
        this.filters[filterId].removeAllListeners();
        var destroyHandler = this.filterDestroyHandlers[filterId];
        delete this.filters[filterId];
        delete this.asyncBlockHandlers[filterId];
        delete this.asyncPendingBlockHandlers[filterId];
        delete this.filterDestroyHandlers[filterId];
        if (destroyHandler) {
            destroyHandler();
        }
        cb(null, true);
    };
    FilterSubprovider.prototype.checkForPendingBlocks = function () {
        var _this = this;
        if (this.checkForPendingBlocksActive) {
            return;
        }
        var activePendingTxFilters = !!Object.keys(this.asyncPendingBlockHandlers).length;
        if (activePendingTxFilters) {
            this.checkForPendingBlocksActive = true;
            this.emitPayload({
                id: 0,
                jsonrpc: '2.0',
                method: 'eth_getBlockByNumber',
                params: ['pending', true],
            }, function (err, res) {
                if (err) {
                    _this.checkForPendingBlocksActive = false;
                    // console.error(err);
                    return;
                }
                _this.onNewPendingBlock(res.result, function () {
                    // if (err) { console.error(err); }
                    _this.checkForPendingBlocksActive = false;
                    setTimeout(_this.checkForPendingBlocks.bind(_this), _this.pendingBlockTimeout);
                });
            });
        }
    };
    FilterSubprovider.prototype.onNewPendingBlock = function (block, cb) {
        // update filters
        var updaters = valuesFor(this.asyncPendingBlockHandlers).map(function (fn) { return fn.bind(null, block); });
        parallel_1.default(updaters, cb);
    };
    FilterSubprovider.prototype._getBlockNumber = function (cb) {
        var blockNumber = bufferToNumberHex(this.engine.currentBlock.number);
        cb(null, blockNumber);
    };
    FilterSubprovider.prototype._logsForBlock = function (block, cb) {
        var blockNumber = bufferToNumberHex(block.number);
        this.emitPayload({
            id: 0,
            jsonrpc: '2.0',
            method: 'eth_getLogs',
            params: [{
                    fromBlock: blockNumber,
                    toBlock: blockNumber,
                }],
        }, function (err, response) {
            if (err) {
                return cb(err);
            }
            if (response.error) {
                return cb(response.error);
            }
            cb(null, response.result);
        });
    };
    FilterSubprovider.prototype._txHashesForBlock = function (block, cb) {
        var txs = block.transactions;
        // short circuit if empty
        if (txs.length === 0) {
            return cb(null, []);
        }
        // txs are already hashes
        if ('string' === typeof txs[0]) {
            cb(null, txs);
            // txs are obj, need to map to hashes
        }
        else {
            var results = txs.map(function (tx) { return tx.hash; });
            cb(null, results);
        }
    };
    return FilterSubprovider;
}(subprovider_1.default));
exports.default = FilterSubprovider;
// util
function bufferToNumberHex(buffer) {
    return stripLeadingZero(buffer.toString('hex'));
}
function stripLeadingZero(hexNum) {
    var stripped = eth_util_1.stripHexPrefix(hexNum);
    while (stripped[0] === '0') {
        stripped = stripped.substr(1);
    }
    return "0x" + stripped;
}
function valuesFor(obj) {
    return Object.keys(obj).map(function (key) { return obj[key]; });
}

},{"../subprovider":36,"../util/eth-util":59,"../util/stoplight":63,"./filters/block-filter":45,"./filters/log-filter":47,"./filters/pending-tx-filter":48,"async/parallel":86}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_1 = __importDefault(require("./filter"));
//
// BlockFilter
//
var BlockFilter = /** @class */ (function (_super) {
    __extends(BlockFilter, _super);
    function BlockFilter(opts) {
        var _this = 
        // console.log('BlockFilter - new')
        _super.call(this) || this;
        _this.type = 'block';
        _this.engine = opts.engine;
        _this.blockNumber = opts.blockNumber;
        _this.updates = [];
        return _this;
    }
    BlockFilter.prototype.update = function (block) {
        var blockHash = bufferToHex(block.hash);
        this.updates.push(blockHash);
        this.emit('data', block);
    };
    BlockFilter.prototype.getChanges = function () {
        // console.log('BlockFilter - getChanges:', results.length)
        return this.updates;
    };
    BlockFilter.prototype.clearChanges = function () {
        // console.log('BlockFilter - clearChanges')
        this.updates = [];
    };
    return BlockFilter;
}(filter_1.default));
exports.default = BlockFilter;
function bufferToHex(buffer) {
    return '0x' + buffer.toString('hex');
}

},{"./filter":46}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var Filter = /** @class */ (function (_super) {
    __extends(Filter, _super);
    function Filter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Filter;
}(events_1.EventEmitter));
exports.default = Filter;

},{"events":109}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_1 = __importDefault(require("./filter"));
//
// LogFilter
//
var LogFilter = /** @class */ (function (_super) {
    __extends(LogFilter, _super);
    function LogFilter(opts) {
        var _this = 
        // console.log('LogFilter - new')
        _super.call(this) || this;
        _this.type = 'log';
        _this.fromBlock = (opts.fromBlock !== undefined) ? opts.fromBlock : 'latest';
        _this.toBlock = (opts.toBlock !== undefined) ? opts.toBlock : 'latest';
        var expectedAddress = opts.address && (Array.isArray(opts.address) ? opts.address : [opts.address]);
        _this.address = expectedAddress && expectedAddress.map(normalizeHex);
        _this.topics = opts.topics || [];
        _this.updates = [];
        _this.allResults = [];
        return _this;
    }
    LogFilter.prototype.update = function (logs) {
        var _this = this;
        // validate filter match
        var validLogs = [];
        logs.forEach(function (log) {
            var validated = _this.validateLog(log);
            if (!validated) {
                return;
            }
            // add to results
            validLogs.push(log);
            _this.updates.push(log);
            _this.allResults.push(log);
        });
        if (validLogs.length > 0) {
            this.emit('data', validLogs);
        }
    };
    LogFilter.prototype.getChanges = function () {
        // console.log('LogFilter - getChanges')
        return this.updates;
    };
    LogFilter.prototype.getAllResults = function () {
        // console.log('LogFilter - getAllResults')
        return this.allResults;
    };
    LogFilter.prototype.clearChanges = function () {
        // console.log('LogFilter - clearChanges')
        this.updates = [];
    };
    LogFilter.prototype.validateLog = function (log) {
        // console.log('LogFilter - validateLog:', log)
        // check if block number in bounds:
        // console.log('LogFilter - validateLog - blockNumber', this.fromBlock, this.toBlock)
        if (blockTagIsNumber(this.fromBlock) && hexToInt(this.fromBlock) >= hexToInt(log.blockNumber)) {
            return false;
        }
        if (blockTagIsNumber(this.toBlock) && hexToInt(this.toBlock) <= hexToInt(log.blockNumber)) {
            return false;
        }
        // address is correct:
        // console.log('LogFilter - validateLog - address', this.address)
        if (this.address && !(this.address.map(function (a) { return a.toLowerCase(); }).includes(log.address.toLowerCase()))) {
            return false;
        }
        // topics match:
        // topics are position-dependant
        // topics can be nested to represent `or` [[a || b], c]
        // topics can be null, representing a wild card for that position
        // console.log('LogFilter - validateLog - topics', log.topics)
        // console.log('LogFilter - validateLog - against topics', this.topics)
        var topicsMatch = this.topics.reduce(function (previousMatched, topicPattern, index) {
            // abort in progress
            if (!previousMatched) {
                return false;
            }
            // wild card
            if (!topicPattern) {
                return true;
            }
            // pattern is longer than actual topics
            var logTopic = log.topics[index];
            if (!logTopic) {
                return false;
            }
            // check each possible matching topic
            var subtopicsToMatch = Array.isArray(topicPattern) ? topicPattern : [topicPattern];
            var topicDoesMatch = subtopicsToMatch.filter(function (subTopic) {
                return logTopic.toLowerCase() === subTopic.toLowerCase();
            }).length > 0;
            return topicDoesMatch;
        }, true);
        // console.log('LogFilter - validateLog - '+(topicsMatch ? 'approved!' : 'denied!')+' ==============')
        return topicsMatch;
    };
    return LogFilter;
}(filter_1.default));
exports.default = LogFilter;
function blockTagIsNumber(blockTag) {
    return blockTag && ['earliest', 'latest', 'pending'].indexOf(blockTag) === -1;
}
function hexToInt(hexString) {
    return Number(hexString);
}
function normalizeHex(hexString) {
    return hexString.slice(0, 2) === '0x' ? hexString : '0x' + hexString;
}

},{"./filter":46}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var filter_1 = __importDefault(require("./filter"));
//
// PendingTxFilter
//
var PendingTransactionFilter = /** @class */ (function (_super) {
    __extends(PendingTransactionFilter, _super);
    function PendingTransactionFilter() {
        var _this = 
        // console.log('PendingTransactionFilter - new')
        _super.call(this) || this;
        _this.type = 'pendingTx';
        _this.updates = [];
        _this.allResults = [];
        return _this;
    }
    PendingTransactionFilter.prototype.update = function (txs) {
        var _this = this;
        // console.log('PendingTransactionFilter - update')
        var validTxs = [];
        txs.forEach(function (tx) {
            // validate filter match
            var validated = _this.validateUnique(tx);
            if (!validated) {
                return;
            }
            // add to results
            validTxs.push(tx);
            _this.updates.push(tx);
            _this.allResults.push(tx);
        });
        if (validTxs.length > 0) {
            this.emit('data', validTxs);
        }
    };
    PendingTransactionFilter.prototype.getChanges = function () {
        // console.log('PendingTransactionFilter - getChanges')
        return this.updates;
    };
    PendingTransactionFilter.prototype.getAllResults = function () {
        // console.log('PendingTransactionFilter - getAllResults')
        return this.allResults;
    };
    PendingTransactionFilter.prototype.clearChanges = function () {
        // console.log('PendingTransactionFilter - clearChanges')
        this.updates = [];
    };
    PendingTransactionFilter.prototype.validateUnique = function (tx) {
        return this.allResults.indexOf(tx) === -1;
    };
    return PendingTransactionFilter;
}(filter_1.default));
exports.default = PendingTransactionFilter;

},{"./filter":46}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var subprovider_1 = __importDefault(require("../subprovider"));
var FixtureProvider = /** @class */ (function (_super) {
    __extends(FixtureProvider, _super);
    function FixtureProvider(staticResponses) {
        var _this = _super.call(this) || this;
        _this.staticResponses = staticResponses || {};
        return _this;
    }
    FixtureProvider.prototype.handleRequest = function (payload, next, end) {
        var staticResponse = this.staticResponses[payload.method];
        // async function
        if ('function' === typeof staticResponse) {
            staticResponse(payload, next, end);
            // static response - null is valid response
        }
        else if (staticResponse !== undefined) {
            // return result asynchronously
            setTimeout(function () { return end(null, staticResponse); });
            // no prepared response - skip
        }
        else {
            next();
        }
    };
    return FixtureProvider;
}(subprovider_1.default));
exports.default = FixtureProvider;

},{"../subprovider":36}],50:[function(require,module,exports){
"use strict";
/*
 * Calculate gasPrice based on last blocks.
 * @author github.com/axic
 *
 * FIXME: support minimum suggested gas and perhaps other options from geth:
 * https://github.com/ethereum/go-ethereum/blob/master/eth/gasprice.go
 * https://github.com/ethereum/go-ethereum/wiki/Gas-Price-Oracle
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var map_1 = __importDefault(require("async/map"));
var gas_price_error_1 = require("../errors/gas-price-error");
var subprovider_1 = __importDefault(require("../subprovider"));
var GaspriceProvider = /** @class */ (function (_super) {
    __extends(GaspriceProvider, _super);
    function GaspriceProvider(opts) {
        var _this = this;
        opts = opts || {};
        _this = _super.call(this) || this;
        _this.numberOfBlocks = opts.numberOfBlocks || 10;
        _this.delayInBlocks = opts.delayInBlocks || 5;
        return _this;
    }
    GaspriceProvider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        if (payload.method !== 'eth_gasPrice') {
            return next();
        }
        var p = { id: 0, jsonrpc: '2.0', method: 'eth_blockNumber', params: [] };
        this.emitPayload(p, function (_, res) {
            // FIXME: convert number using a bignum library
            var lastBlock = parseInt(res.result, 16) - _this.delayInBlocks;
            var blockNumbers = [];
            for (var i = 0; i < _this.numberOfBlocks; i++) {
                blockNumbers.push('0x' + lastBlock.toString(16));
                lastBlock--;
            }
            var getBlock = function (item, cb) {
                var p2 = { id: 0, jsonrpc: '2.0', method: 'eth_getBlockByNumber', params: [item, true] };
                _this.emitPayload(p2, function (err, blockRes) {
                    if (err) {
                        return cb(err);
                    }
                    if (!blockRes.result) {
                        return cb(gas_price_error_1.GasPriceError.BlockNotFound(item));
                    }
                    cb(null, blockRes.result.transactions);
                });
            };
            // FIXME: this could be made much faster
            var calcPrice = function (err, transactions) {
                // flatten array
                transactions = transactions.reduce(function (a, b) { return a.concat(b); }, []);
                // leave only the gasprice
                // FIXME: convert number using a bignum library
                transactions = transactions.map(function (a) { return parseInt(a.gasPrice, 16); }, []);
                // order ascending
                transactions.sort(function (a, b) { return a - b; });
                // ze median
                var half = Math.floor(transactions.length / 2);
                var median;
                if (transactions.length % 2) {
                    median = transactions[half];
                }
                else {
                    median = Math.floor((transactions[half - 1] + transactions[half]) / 2.0);
                }
                end(null, median);
            };
            map_1.default(blockNumbers, getBlock, calcPrice);
        });
    };
    return GaspriceProvider;
}(subprovider_1.default));
exports.default = GaspriceProvider;

},{"../errors/gas-price-error":31,"../subprovider":36,"async/map":85}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var cache_1 = require("./cache");
exports.BlockCacheSubprovider = cache_1.default;
var default_fixture_1 = require("./default-fixture");
exports.DefaultFixtureSubprovider = default_fixture_1.default;
var fetch_1 = require("./fetch");
exports.FetchSubprovider = fetch_1.default;
var filters_1 = require("./filters");
exports.FilterSubprovider = filters_1.default;
var fixture_1 = require("./fixture");
exports.FixtureSubprovider = fixture_1.default;
var gasprice_1 = require("./gasprice");
exports.GasPriceSubprovider = gasprice_1.default;
var inflight_cache_1 = require("./inflight-cache");
exports.InflightCacheSubprovider = inflight_cache_1.default;
var provider_1 = require("./provider");
exports.ProviderSubprovider = provider_1.default;
var sanitizer_1 = require("./sanitizer");
exports.SanitizerSubprovider = sanitizer_1.default;
var subscriptions_1 = require("./subscriptions");
exports.SubscriptionSubprovider = subscriptions_1.default;

},{"./cache":41,"./default-fixture":42,"./fetch":43,"./filters":44,"./fixture":49,"./gasprice":50,"./inflight-cache":52,"./provider":53,"./sanitizer":54,"./subscriptions":55}],52:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var clone_1 = __importDefault(require("clone"));
var subprovider_1 = __importDefault(require("../subprovider"));
var rpc_cache_utils_1 = require("../util/rpc-cache-utils");
var InflightCacheSubprovider = /** @class */ (function (_super) {
    __extends(InflightCacheSubprovider, _super);
    function InflightCacheSubprovider() {
        var _this = _super.call(this) || this;
        _this.inflightRequests = {};
        return _this;
    }
    InflightCacheSubprovider.prototype.handleRequest = function (payload, next, end) {
        var _this = this;
        var cacheId = rpc_cache_utils_1.cacheIdentifierForPayload(payload, { includeBlockRef: true });
        // if not cacheable, skip
        if (!cacheId) {
            return next();
        }
        // check for matching requests
        var activeRequestHandlers = this.inflightRequests[cacheId];
        if (!activeRequestHandlers) {
            // create inflight cache for cacheId
            activeRequestHandlers = [];
            this.inflightRequests[cacheId] = activeRequestHandlers;
            next(function (err, result, cb) {
                // complete inflight for cacheId
                delete _this.inflightRequests[cacheId];
                activeRequestHandlers.forEach(function (handler) { return handler(err, clone_1.default(result)); });
                result = clone_1.default(result);
                cb();
            });
        }
        else {
            // hit inflight cache for cacheId
            // setup the response listener
            activeRequestHandlers.push(end);
        }
    };
    return InflightCacheSubprovider;
}(subprovider_1.default));
exports.default = InflightCacheSubprovider;

},{"../subprovider":36,"../util/rpc-cache-utils":61,"clone":111}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var json_rpc_error_1 = __importDefault(require("json-rpc-error"));
var subprovider_1 = __importDefault(require("../subprovider"));
// wraps a provider in a subprovider interface
var ProviderSubprovider = /** @class */ (function (_super) {
    __extends(ProviderSubprovider, _super);
    function ProviderSubprovider(provider) {
        var _this = _super.call(this) || this;
        _this.provider = provider;
        return _this;
    }
    ProviderSubprovider.prototype.handleRequest = function (payload, next, end) {
        this.provider.sendAsync(payload, function (err, response) {
            if (err) {
                return end(err);
            }
            if (response.error) {
                return end(new json_rpc_error_1.default.InternalError(response.error));
            }
            end(null, response.result);
        });
    };
    return ProviderSubprovider;
}(subprovider_1.default));
exports.default = ProviderSubprovider;

},{"../subprovider":36,"json-rpc-error":123}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var subprovider_1 = __importDefault(require("../subprovider"));
var eth_util_1 = require("../util/eth-util");
var SanitizerSubprovider = /** @class */ (function (_super) {
    __extends(SanitizerSubprovider, _super);
    function SanitizerSubprovider() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SanitizerSubprovider.prototype.handleRequest = function (payload, next, end) {
        var txParams = payload.params[0];
        if (typeof txParams === 'object' && !Array.isArray(txParams)) {
            var sanitized = cloneTxParams(txParams);
            payload.params[0] = sanitized;
        }
        next();
    };
    return SanitizerSubprovider;
}(subprovider_1.default));
exports.default = SanitizerSubprovider;
// we use this to clean any custom params from the txParams
var permitted = [
    'from',
    'to',
    'value',
    'data',
    'gas',
    'gasPrice',
    'nonce',
    'fromBlock',
    'toBlock',
    'address',
    'topics',
];
function cloneTxParams(txParams) {
    var sanitized = permitted.reduce(function (copy, p) {
        if (p in txParams) {
            if (Array.isArray(txParams[p])) {
                copy[p] = txParams[p].map(function (item) { return sanitize(item); });
            }
            else {
                copy[p] = sanitize(txParams[p]);
            }
        }
        return copy;
    }, {});
    return sanitized;
}
function sanitize(value) {
    switch (value) {
        case 'latest':
            return value;
        case 'pending':
            return value;
        case 'earliest':
            return value;
        default:
            if (typeof value === 'string') {
                return eth_util_1.addHexPrefix(value.toLowerCase());
            }
            else {
                return value;
            }
    }
}

},{"../subprovider":36,"../util/eth-util":59}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var subscription_error_1 = require("../errors/subscription-error");
var eth_util_1 = require("../util/eth-util");
var rpc_hex_encoding_1 = require("../util/rpc-hex-encoding");
var filters_1 = __importDefault(require("./filters"));
var SubscriptionSubprovider = /** @class */ (function (_super) {
    __extends(SubscriptionSubprovider, _super);
    function SubscriptionSubprovider(opts) {
        var _this = _super.call(this, opts) || this;
        _this.subscriptions = {};
        return _this;
    }
    SubscriptionSubprovider.prototype.handleRequest = function (payload, next, end) {
        switch (payload.method) {
            case 'eth_subscribe':
                this.eth_subscribe(payload, end);
                break;
            case 'eth_unsubscribe':
                this.eth_unsubscribe(payload, end);
                break;
            default:
                _super.prototype.handleRequest.call(this, payload, next, end);
        }
    };
    SubscriptionSubprovider.prototype.eth_subscribe = function (payload, cb) {
        var _this = this;
        var subscriptionType = payload.params[0];
        var callback = function (err, hexId) {
            if (err) {
                return cb(err);
            }
            var id = parseInt(hexId, 16);
            _this.subscriptions[id] = subscriptionType;
            _this.filters[id].on('data', function (results) {
                _this.filters[id].clearChanges();
                if (!Array.isArray(results)) {
                    results = [results];
                }
                results.forEach(function (r) { return _this._notificationHandler(hexId, subscriptionType, r); });
            });
            if (subscriptionType === 'newPendingTransactions') {
                _this.checkForPendingBlocks();
            }
            cb(null, hexId);
        };
        switch (subscriptionType) {
            case 'logs':
                var options = payload.params[1];
                this.newLogFilter(options, callback);
                break;
            case 'newPendingTransactions':
                this.newPendingTransactionFilter(callback);
                break;
            case 'newHeads':
                this.newBlockFilter(callback);
                break;
            case 'syncing':
            default:
                cb(subscription_error_1.SubscriptionError.UnsupportedType(subscriptionType));
                return;
        }
    };
    SubscriptionSubprovider.prototype.eth_unsubscribe = function (payload, cb) {
        var _this = this;
        var hexId = payload.params[0];
        var id = parseInt(hexId, 16);
        if (!this.subscriptions[id]) {
            cb(subscription_error_1.SubscriptionError.NotFound(hexId));
        }
        else {
            this.uninstallFilter(hexId, function (err, result) {
                delete _this.subscriptions[id];
                cb(err, result);
            });
        }
    };
    SubscriptionSubprovider.prototype._notificationHandler = function (hexId, subscriptionType, result) {
        if (subscriptionType === 'newHeads') {
            result = this._notificationResultFromBlock(result);
        }
        // it seems that web3 doesn't expect there to be a separate error event
        // so we must emit null along with the result object
        this.emit('data', null, {
            jsonrpc: '2.0',
            method: 'eth_subscription',
            params: {
                subscription: hexId,
                result: result,
            },
        });
    };
    SubscriptionSubprovider.prototype._notificationResultFromBlock = function (block) {
        return {
            hash: eth_util_1.bufferToHex(block.hash),
            parentHash: eth_util_1.bufferToHex(block.parentHash),
            sha3Uncles: eth_util_1.bufferToHex(block.sha3Uncles),
            miner: eth_util_1.bufferToHex(block.miner),
            stateRoot: eth_util_1.bufferToHex(block.stateRoot),
            transactionsRoot: eth_util_1.bufferToHex(block.transactionsRoot),
            receiptsRoot: eth_util_1.bufferToHex(block.receiptsRoot),
            logsBloom: eth_util_1.bufferToHex(block.logsBloom),
            difficulty: rpc_hex_encoding_1.bufferToQuantityHex(block.difficulty),
            number: rpc_hex_encoding_1.bufferToQuantityHex(block.number),
            gasLimit: rpc_hex_encoding_1.bufferToQuantityHex(block.gasLimit),
            gasUsed: rpc_hex_encoding_1.bufferToQuantityHex(block.gasUsed),
            nonce: block.nonce ? eth_util_1.bufferToHex(block.nonce) : null,
            mixHash: eth_util_1.bufferToHex(block.mixHash),
            timestamp: rpc_hex_encoding_1.bufferToQuantityHex(block.timestamp),
            extraData: eth_util_1.bufferToHex(block.extraData),
        };
    };
    return SubscriptionSubprovider;
}(filters_1.default));
exports.default = SubscriptionSubprovider;

},{"../errors/subscription-error":33,"../util/eth-util":59,"../util/rpc-hex-encoding":62,"./filters":44}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function assert(condition, message) {
    if (!condition) {
        throw message || 'Assertion failed';
    }
}
exports.assert = assert;

},{}],57:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eth_block_tracker_1 = __importDefault(require("eth-block-tracker"));
var events_1 = require("events");
var block_tracker_error_1 = require("../errors/block-tracker-error");
var create_payload_1 = require("./create-payload");
var eth_util_1 = require("./eth-util");
// Class responsible for tracking new blocks as they are mined,
// loading them, parsing them, and alerting subscribers via events.
var BlockTracker = /** @class */ (function (_super) {
    __extends(BlockTracker, _super);
    function BlockTracker(opts) {
        var _this = _super.call(this) || this;
        // Number of milliseconds to wait before retrying
        _this.blockTimeout = 300;
        // Maximum attempts to load a block
        _this.maxBlockRetries = 3;
        _this.provider = opts.provider;
        _this._blockTracker = opts.blockTracker || new eth_block_tracker_1.default(__assign({}, opts, { setSkipCacheFlag: true }));
        return _this;
    }
    BlockTracker.prototype.start = function () {
        this.createSubscriptions();
    };
    BlockTracker.prototype.stop = function () {
        this.destroySubscriptions();
    };
    BlockTracker.prototype.fetchLatest = function () {
        var _this = this;
        return this._blockTracker.checkForLatestBlock().catch(function (error) {
            _this.emit('error', error);
        });
    };
    BlockTracker.prototype.createSubscriptions = function () {
        // on new block, request block body and emit as events
        this._blockTracker.on('latest', this.onLatest.bind(this));
        // forward other events
        this._blockTracker.on('sync', this.emit.bind(this, 'sync'));
        this._blockTracker.on('error', this.emit.bind(this, 'error'));
    };
    BlockTracker.prototype.destroySubscriptions = function () {
        // stop block polling by removing event listeners
        this._blockTracker.removeAllListeners();
    };
    BlockTracker.prototype.onLatest = function (blockNumber) {
        this.currentBlockNumber = blockNumber;
        this.loadBlock(blockNumber);
    };
    // Tries to get the block payload recursively
    BlockTracker.prototype.loadBlock = function (blockNumber, callCount) {
        var _this = this;
        if (callCount === void 0) { callCount = 0; }
        this._getBlockByNumber(blockNumber).then(function (blockResponse) {
            // Result can be null if the block hasn't fully propagated to the nodes
            if (blockResponse.result) {
                _this.updateBlock(blockResponse.result);
            }
            else if (callCount < _this.maxBlockRetries && blockNumber === _this.currentBlockNumber) {
                // Only call recursively if the current block number is still the same
                // and if we are under the retry limit.
                setTimeout(function () {
                    _this.loadBlock(blockNumber, callCount + 1);
                }, _this.blockTimeout);
            }
            else {
                throw block_tracker_error_1.BlockTrackerError.BlockNotFound(blockNumber);
            }
        }).catch(function (err) {
            // Don't retry for errors (provider should have already retried)
            _this.emit('error', err);
        });
    };
    BlockTracker.prototype._getBlockByNumber = function (blockNumber) {
        var _this = this;
        var req = create_payload_1.createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true });
        return new Promise(function (fulfill, reject) {
            _this.provider.sendAsync(req, function (err, result) {
                if (err) {
                    return reject(err);
                }
                fulfill(result);
            });
        });
    };
    // Parse the block into a buffer representation and update subscribers.
    BlockTracker.prototype.updateBlock = function (block) {
        var bufferBlock = toBufferBlock(block);
        // set current + emit "block" event
        this._setCurrentBlock(bufferBlock);
        // emit other events
        this.emit('rawBlock', block);
        this.emit('latest', block);
    };
    BlockTracker.prototype._setCurrentBlock = function (bufferBlock) {
        this.currentBlock = bufferBlock;
        this.emit('block', bufferBlock);
    };
    return BlockTracker;
}(events_1.EventEmitter));
exports.default = BlockTracker;
// util
function toBufferBlock(jsonBlock) {
    return {
        number: eth_util_1.toBuffer(jsonBlock.number),
        hash: eth_util_1.toBuffer(jsonBlock.hash),
        parentHash: eth_util_1.toBuffer(jsonBlock.parentHash),
        nonce: eth_util_1.toBuffer(jsonBlock.nonce),
        mixHash: eth_util_1.toBuffer(jsonBlock.mixHash),
        sha3Uncles: eth_util_1.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: eth_util_1.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: eth_util_1.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: eth_util_1.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: eth_util_1.toBuffer(jsonBlock.receiptsRoot),
        miner: eth_util_1.toBuffer(jsonBlock.miner),
        difficulty: eth_util_1.toBuffer(jsonBlock.difficulty),
        totalDifficulty: eth_util_1.toBuffer(jsonBlock.totalDifficulty),
        size: eth_util_1.toBuffer(jsonBlock.size),
        extraData: eth_util_1.toBuffer(jsonBlock.extraData),
        gasLimit: eth_util_1.toBuffer(jsonBlock.gasLimit),
        gasUsed: eth_util_1.toBuffer(jsonBlock.gasUsed),
        timestamp: eth_util_1.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions,
    };
}

},{"../errors/block-tracker-error":30,"./create-payload":58,"./eth-util":59,"eth-block-tracker":115,"events":109}],58:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var xtend_1 = __importDefault(require("xtend"));
var random_id_1 = require("./random-id");
function createPayload(data) {
    return xtend_1.default({
        // defaults
        id: random_id_1.createRandomId(),
        jsonrpc: '2.0',
        params: [],
    }, data);
}
exports.createPayload = createPayload;

},{"./random-id":60,"xtend":143}],59:[function(require,module,exports){
(function (Buffer){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var ethjs_util_1 = __importDefault(require("ethjs-util"));
// Methods from ethereumjs-util
/**
 * Attempts to turn a value into a `Buffer`. As input it supports
 * `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjs_util_1.default.isHexString(v)) {
                v = Buffer.from(ethjs_util_1.default.padToEven(ethjs_util_1.default.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new TypeError(
                // tslint:disable-next-line: max-line-length
                "Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjs_util_1.default.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (bn_js_1.default.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new TypeError("invalid type: " + v);
        }
    }
    return v;
}
exports.toBuffer = toBuffer;
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
function addHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjs_util_1.default.isHexPrefixed(str) ? str : '0x' + str;
}
exports.addHexPrefix = addHexPrefix;
function stripHexPrefix(str) {
    return ethjs_util_1.default.stripHexPrefix(str);
}
exports.stripHexPrefix = stripHexPrefix;
function intToHex(n) {
    return ethjs_util_1.default.intToHex(n);
}
exports.intToHex = intToHex;
function intToBuffer(n) {
    return ethjs_util_1.default.intToBuffer(n);
}
exports.intToBuffer = intToBuffer;
/**
 * Converts a `Buffer` into a hex `String`.
 * @param buf `Buffer` object to convert
 */
function bufferToHex(buf) {
    buf = toBuffer(buf);
    return '0x' + buf.toString('hex');
}
exports.bufferToHex = bufferToHex;
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
function bufferToInt(buf) {
    return new bn_js_1.default(toBuffer(buf)).toNumber();
}
exports.bufferToInt = bufferToInt;
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
function unpad(a) {
    a = ethjs_util_1.default.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
}
exports.unpad = unpad;

}).call(this,require("buffer").Buffer)

},{"bn.js":107,"buffer":110,"ethjs-util":117}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// gotta keep it within MAX_SAFE_INTEGER
var extraDigits = 3;
function createRandomId() {
    // 13 time digits
    var datePart = new Date().getTime() * Math.pow(10, extraDigits);
    // 3 random digits
    var extraPart = Math.floor(Math.random() * Math.pow(10, extraDigits));
    // 16 digits
    return datePart + extraPart;
}
exports.createRandomId = createRandomId;

},{}],61:[function(require,module,exports){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, opts) {
    if (opts === void 0) { opts = {}; }
    if (!canCache(payload)) {
        return null;
    }
    var includeBlockRef = opts.includeBlockRef;
    var params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
    return payload.method + ':' + json_stable_stringify_1.default(params);
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    var index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index >= payload.params.length) {
        return null;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    var index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is third param
        case 'eth_getStorageAt':
            return 2;
        // blockTag is second param
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
            return 1;
        // blockTag is first param
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'net_version':
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'net_peerCount':
            return 'block';
        // never cache
        case 'net_peerCount':
        case 'net_listening':
        case 'eth_syncing':
        case 'eth_sign':
        case 'eth_coinbase':
        case 'eth_mining':
        case 'eth_hashrate':
        case 'eth_accounts':
        case 'eth_sendTransaction':
        case 'eth_sendRawTransaction':
        case 'eth_newFilter':
        case 'eth_newBlockFilter':
        case 'eth_newPendingTransactionFilter':
        case 'eth_uninstallFilter':
        case 'eth_getFilterChanges':
        case 'eth_getWork':
        case 'eth_submitWork':
        case 'eth_submitHashrate':
        case 'db_putString':
        case 'db_getString':
        case 'db_putHex':
        case 'db_getHex':
        case 'shh_post':
        case 'shh_newIdentity':
        case 'shh_hasIdentity':
        case 'shh_newGroup':
        case 'shh_addToGroup':
        case 'shh_newFilter':
        case 'shh_uninstallFilter':
        case 'shh_getFilterChanges':
        case 'shh_getMessages':
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;

},{"json-stable-stringify":126}],62:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("./assert");
var eth_util_1 = require("./eth-util");
/*
 * As per https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding
 * Quantities should be represented by the most compact hex representation possible
 * This means that no leading zeroes are allowed. There helpers make it easy
 * to convert to and from integers and their compact hex representation
 */
function bufferToQuantityHex(buffer) {
    buffer = eth_util_1.toBuffer(buffer);
    var hex = buffer.toString('hex');
    var trimmed = eth_util_1.unpad(hex);
    return eth_util_1.addHexPrefix(trimmed);
}
exports.bufferToQuantityHex = bufferToQuantityHex;
function intToQuantityHex(n) {
    assert_1.assert(typeof n === 'number' && n === Math.floor(n), 'intToQuantityHex arg must be an integer');
    var nHex = eth_util_1.toBuffer(n).toString('hex');
    if (nHex[0] === '0') {
        nHex = nHex.substring(1);
    }
    return eth_util_1.addHexPrefix(nHex);
}
exports.intToQuantityHex = intToQuantityHex;
function quantityHexToInt(prefixedQuantityHex) {
    assert_1.assert(typeof prefixedQuantityHex === 'string', 'arg to quantityHexToInt must be a string');
    var quantityHex = eth_util_1.stripHexPrefix(prefixedQuantityHex);
    var isEven = quantityHex.length % 2 === 0;
    if (!isEven) {
        quantityHex = '0' + quantityHex;
    }
    var buf = new Buffer(quantityHex, 'hex');
    return eth_util_1.bufferToInt(buf);
}
exports.quantityHexToInt = quantityHexToInt;

}).call(this,require("buffer").Buffer)

},{"./assert":56,"./eth-util":59,"buffer":110}],63:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var Stoplight = /** @class */ (function (_super) {
    __extends(Stoplight, _super);
    function Stoplight() {
        var _this = _super.call(this) || this;
        _this.isLocked = true;
        return _this;
    }
    Stoplight.prototype.go = function () {
        this.isLocked = false;
        this.emit('unlock');
    };
    Stoplight.prototype.stop = function () {
        this.isLocked = true;
        this.emit('lock');
    };
    Stoplight.prototype.await = function (fn) {
        if (this.isLocked) {
            this.once('unlock', fn);
        }
        else {
            setTimeout(fn);
        }
    };
    return Stoplight;
}(events_1.EventEmitter));
exports.default = Stoplight;

},{"events":109}],64:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = asyncify;

var _initialParams = require('./internal/initialParams');

var _initialParams2 = _interopRequireDefault(_initialParams);

var _setImmediate = require('./internal/setImmediate');

var _setImmediate2 = _interopRequireDefault(_setImmediate);

var _wrapAsync = require('./internal/wrapAsync');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Take a sync function and make it async, passing its return value to a
 * callback. This is useful for plugging sync functions into a waterfall,
 * series, or other async functions. Any arguments passed to the generated
 * function will be passed to the wrapped function (except for the final
 * callback argument). Errors thrown will be passed to the callback.
 *
 * If the function passed to `asyncify` returns a Promise, that promises's
 * resolved/rejected state will be used to call the callback, rather than simply
 * the synchronous return value.
 *
 * This also means you can asyncify ES2017 `async` functions.
 *
 * @name asyncify
 * @static
 * @memberOf module:Utils
 * @method
 * @alias wrapSync
 * @category Util
 * @param {Function} func - The synchronous function, or Promise-returning
 * function to convert to an {@link AsyncFunction}.
 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
 * invoked with `(args..., callback)`.
 * @example
 *
 * // passing a regular synchronous function
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(JSON.parse),
 *     function (data, next) {
 *         // data is the result of parsing the text.
 *         // If there was a parsing error, it would have been caught.
 *     }
 * ], callback);
 *
 * // passing a function returning a promise
 * async.waterfall([
 *     async.apply(fs.readFile, filename, "utf8"),
 *     async.asyncify(function (contents) {
 *         return db.model.create(contents);
 *     }),
 *     function (model, next) {
 *         // `model` is the instantiated model object.
 *         // If there was an error, this function would be skipped.
 *     }
 * ], callback);
 *
 * // es2017 example, though `asyncify` is not needed if your JS environment
 * // supports async functions out of the box
 * var q = async.queue(async.asyncify(async function(file) {
 *     var intermediateStep = await processFile(file);
 *     return await somePromise(intermediateStep)
 * }));
 *
 * q.push(files);
 */
function asyncify(func) {
    if ((0, _wrapAsync.isAsync)(func)) {
        return function (...args /*, callback*/) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
        };
    }

    return (0, _initialParams2.default)(function (args, callback) {
        var result;
        try {
            result = func.apply(this, args);
        } catch (e) {
            return callback(e);
        }
        // if result is Promise object
        if (result && typeof result.then === 'function') {
            return handlePromise(result, callback);
        } else {
            callback(null, result);
        }
    });
}

function handlePromise(promise, callback) {
    return promise.then(value => {
        invokeCallback(callback, null, value);
    }, err => {
        invokeCallback(callback, err && err.message ? err : new Error(err));
    });
}

function invokeCallback(callback, error, value) {
    try {
        callback(error, value);
    } catch (err) {
        (0, _setImmediate2.default)(e => {
            throw e;
        }, err);
    }
}
module.exports = exports['default'];
},{"./internal/initialParams":74,"./internal/setImmediate":82,"./internal/wrapAsync":84}],65:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachOfLimit = require('./internal/eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _withoutIndex = require('./internal/withoutIndex');

var _withoutIndex2 = _interopRequireDefault(_withoutIndex);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
 *
 * @name eachLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfLimit`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachLimit(coll, limit, iteratee, callback) {
  return (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
}
exports.default = (0, _awaitify2.default)(eachLimit, 4);
module.exports = exports['default'];
},{"./internal/awaitify":70,"./internal/eachOfLimit":72,"./internal/withoutIndex":83,"./internal/wrapAsync":84}],66:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isArrayLike = require('./internal/isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _breakLoop = require('./internal/breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

var _eachOfLimit = require('./eachOfLimit');

var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);

var _once = require('./internal/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// eachOf implementation optimized for array-likes
function eachOfArrayLike(coll, iteratee, callback) {
    callback = (0, _once2.default)(callback);
    var index = 0,
        completed = 0,
        { length } = coll,
        canceled = false;
    if (length === 0) {
        callback(null);
    }

    function iteratorCallback(err, value) {
        if (err === false) {
            canceled = true;
        }
        if (canceled === true) return;
        if (err) {
            callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
            callback(null);
        }
    }

    for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
    }
}

// a generic version of eachOf which can handle array, object, and iterator cases.
function eachOfGeneric(coll, iteratee, callback) {
    return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
}

/**
 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
 * to the iteratee.
 *
 * @name eachOf
 * @static
 * @memberOf module:Collections
 * @method
 * @alias forEachOf
 * @category Collection
 * @see [async.each]{@link module:Collections.each}
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - A function to apply to each
 * item in `coll`.
 * The `key` is the item's key, or index in the case of an array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 * @example
 *
 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
 * var configs = {};
 *
 * async.forEachOf(obj, function (value, key, callback) {
 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
 *         if (err) return callback(err);
 *         try {
 *             configs[key] = JSON.parse(data);
 *         } catch (e) {
 *             return callback(e);
 *         }
 *         callback();
 *     });
 * }, function (err) {
 *     if (err) console.error(err.message);
 *     // configs is now a map of JSON data
 *     doSomethingWith(configs);
 * });
 */
function eachOf(coll, iteratee, callback) {
    var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
    return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports.default = (0, _awaitify2.default)(eachOf, 3);
module.exports = exports['default'];
},{"./eachOfLimit":67,"./internal/awaitify":70,"./internal/breakLoop":71,"./internal/isArrayLike":75,"./internal/once":78,"./internal/onlyOnce":79,"./internal/wrapAsync":84}],67:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachOfLimit2 = require('./internal/eachOfLimit');

var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
 * time.
 *
 * @name eachOfLimit
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.eachOf]{@link module:Collections.eachOf}
 * @alias forEachOfLimit
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {number} limit - The maximum number of async operations at a time.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`. The `key` is the item's key, or index in the case of an
 * array.
 * Invoked with (item, key, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachOfLimit(coll, limit, iteratee, callback) {
  return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
}

exports.default = (0, _awaitify2.default)(eachOfLimit, 4);
module.exports = exports['default'];
},{"./internal/awaitify":70,"./internal/eachOfLimit":72,"./internal/wrapAsync":84}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _eachLimit = require('./eachLimit');

var _eachLimit2 = _interopRequireDefault(_eachLimit);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
 *
 * Note, that unlike [`each`]{@link module:Collections.each}, this function applies iteratee to each item
 * in series and therefore the iteratee functions will complete in order.

 * @name eachSeries
 * @static
 * @memberOf module:Collections
 * @method
 * @see [async.each]{@link module:Collections.each}
 * @alias forEachSeries
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each
 * item in `coll`.
 * The array index is not passed to the iteratee.
 * If you need the index, use `eachOfSeries`.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all
 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
 * @returns {Promise} a promise, if a callback is omitted
 */
function eachSeries(coll, iteratee, callback) {
  return (0, _eachLimit2.default)(coll, 1, iteratee, callback);
}
exports.default = (0, _awaitify2.default)(eachSeries, 3);
module.exports = exports['default'];
},{"./eachLimit":65,"./internal/awaitify":70}],69:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = asyncEachOfLimit;

var _breakLoop = require('./breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// for async generators
function asyncEachOfLimit(generator, limit, iteratee, callback) {
    let done = false;
    let canceled = false;
    let awaiting = false;
    let running = 0;
    let idx = 0;

    function replenish() {
        //console.log('replenish')
        if (running >= limit || awaiting || done) return;
        //console.log('replenish awaiting')
        awaiting = true;
        generator.next().then(({ value, done: iterDone }) => {
            //console.log('got value', value)
            if (canceled || done) return;
            awaiting = false;
            if (iterDone) {
                done = true;
                if (running <= 0) {
                    //console.log('done nextCb')
                    callback(null);
                }
                return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
        }).catch(handleError);
    }

    function iterateeCallback(err, result) {
        //console.log('iterateeCallback')
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);

        if (err === false) {
            done = true;
            canceled = true;
            return;
        }

        if (result === _breakLoop2.default || done && running <= 0) {
            done = true;
            //console.log('done iterCb')
            return callback(null);
        }
        replenish();
    }

    function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
    }

    replenish();
}
module.exports = exports['default'];
},{"./breakLoop":71}],70:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = awaitify;
// conditionally promisify a function.
// only return a promise if a callback is omitted
function awaitify(asyncFn, arity = asyncFn.length) {
    if (!arity) throw new Error('arity is undefined');
    function awaitable(...args) {
        if (typeof args[arity - 1] === 'function') {
            return asyncFn.apply(this, args);
        }

        return new Promise((resolve, reject) => {
            args[arity - 1] = (err, ...cbArgs) => {
                if (err) return reject(err);
                resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
        });
    }

    Object.defineProperty(awaitable, 'name', {
        value: `awaitable(${asyncFn.name})`
    });

    return awaitable;
}
module.exports = exports['default'];
},{}],71:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
// A temporary value used to identify if the loop should be broken.
// See #1064, #1293
const breakLoop = {};
exports.default = breakLoop;
module.exports = exports["default"];
},{}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _once = require('./once');

var _once2 = _interopRequireDefault(_once);

var _iterator = require('./iterator');

var _iterator2 = _interopRequireDefault(_iterator);

var _onlyOnce = require('./onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./wrapAsync');

var _asyncEachOfLimit = require('./asyncEachOfLimit');

var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);

var _breakLoop = require('./breakLoop');

var _breakLoop2 = _interopRequireDefault(_breakLoop);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = limit => {
    return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
            throw new RangeError('concurrency limit cannot be less than 1');
        }
        if (!obj) {
            return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
            return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;

        function iterateeCallback(err, value) {
            if (canceled) return;
            running -= 1;
            if (err) {
                done = true;
                callback(err);
            } else if (err === false) {
                done = true;
                canceled = true;
            } else if (value === _breakLoop2.default || done && running <= 0) {
                done = true;
                return callback(null);
            } else if (!looping) {
                replenish();
            }
        }

        function replenish() {
            looping = true;
            while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                    done = true;
                    if (running <= 0) {
                        callback(null);
                    }
                    return;
                }
                running += 1;
                iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
            }
            looping = false;
        }

        replenish();
    };
};

module.exports = exports['default'];
},{"./asyncEachOfLimit":69,"./breakLoop":71,"./iterator":76,"./once":78,"./onlyOnce":79,"./wrapAsync":84}],73:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (coll) {
    return coll[Symbol.iterator] && coll[Symbol.iterator]();
};

module.exports = exports["default"];
},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

exports.default = function (fn) {
    return function (...args /*, callback*/) {
        var callback = args.pop();
        return fn.call(this, args, callback);
    };
};

module.exports = exports["default"];
},{}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = isArrayLike;
function isArrayLike(value) {
    return value && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;
}
module.exports = exports['default'];
},{}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = createIterator;

var _isArrayLike = require('./isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _getIterator = require('./getIterator');

var _getIterator2 = _interopRequireDefault(_getIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function createArrayIterator(coll) {
    var i = -1;
    var len = coll.length;
    return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
    };
}

function createES2015Iterator(iterator) {
    var i = -1;
    return function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return { value: item.value, key: i };
    };
}

function createObjectIterator(obj) {
    var okeys = obj ? Object.keys(obj) : [];
    var i = -1;
    var len = okeys.length;
    return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key } : null;
    };
}

function createIterator(coll) {
    if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
    }

    var iterator = (0, _getIterator2.default)(coll);
    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
}
module.exports = exports['default'];
},{"./getIterator":73,"./isArrayLike":75}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _asyncMap;

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncMap(eachfn, arr, iteratee, callback) {
    arr = arr || [];
    var results = [];
    var counter = 0;
    var _iteratee = (0, _wrapAsync2.default)(iteratee);

    return eachfn(arr, (value, _, iterCb) => {
        var index = counter++;
        _iteratee(value, (err, v) => {
            results[index] = v;
            iterCb(err);
        });
    }, err => {
        callback(err, results);
    });
}
module.exports = exports['default'];
},{"./wrapAsync":84}],78:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = once;
function once(fn) {
    function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    }
    Object.assign(wrapper, fn);
    return wrapper;
}
module.exports = exports["default"];
},{}],79:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = onlyOnce;
function onlyOnce(fn) {
    return function (...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
    };
}
module.exports = exports["default"];
},{}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _isArrayLike = require('./isArrayLike');

var _isArrayLike2 = _interopRequireDefault(_isArrayLike);

var _wrapAsync = require('./wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
    var results = (0, _isArrayLike2.default)(tasks) ? [] : {};

    eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result) => {
            if (result.length < 2) {
                [result] = result;
            }
            results[key] = result;
            taskCb(err);
        });
    }, err => callback(err, results));
}, 3);
module.exports = exports['default'];
},{"./awaitify":70,"./isArrayLike":75,"./wrapAsync":84}],81:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
const PROMISE_SYMBOL = Symbol('promiseCallback');

function promiseCallback() {
    let resolve, reject;
    function callback(err, ...args) {
        if (err) return reject(err);
        resolve(args.length > 1 ? args : args[0]);
    }

    callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
        resolve = res, reject = rej;
    });

    return callback;
}

exports.promiseCallback = promiseCallback;
exports.PROMISE_SYMBOL = PROMISE_SYMBOL;
},{}],82:[function(require,module,exports){
(function (process,setImmediate){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fallback = fallback;
exports.wrap = wrap;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports.default = wrap(_defer);
}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":130,"timers":135}],83:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = _withoutIndex;
function _withoutIndex(iteratee) {
    return (value, index, callback) => iteratee(value, callback);
}
module.exports = exports["default"];
},{}],84:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isAsyncIterable = exports.isAsyncGenerator = exports.isAsync = undefined;

var _asyncify = require('../asyncify');

var _asyncify2 = _interopRequireDefault(_asyncify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isAsync(fn) {
    return fn[Symbol.toStringTag] === 'AsyncFunction';
}

function isAsyncGenerator(fn) {
    return fn[Symbol.toStringTag] === 'AsyncGenerator';
}

function isAsyncIterable(obj) {
    return typeof obj[Symbol.asyncIterator] === 'function';
}

function wrapAsync(asyncFn) {
    if (typeof asyncFn !== 'function') throw new Error('expected a function');
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
}

exports.default = wrapAsync;
exports.isAsync = isAsync;
exports.isAsyncGenerator = isAsyncGenerator;
exports.isAsyncIterable = isAsyncIterable;
},{"../asyncify":64}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _map2 = require('./internal/map');

var _map3 = _interopRequireDefault(_map2);

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Produces a new collection of values by mapping each value in `coll` through
 * the `iteratee` function. The `iteratee` is called with an item from `coll`
 * and a callback for when it has finished processing. Each of these callback
 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
 * `iteratee` passes an error to its callback, the main `callback` (for the
 * `map` function) is immediately called with the error.
 *
 * Note, that since this function applies the `iteratee` to each item in
 * parallel, there is no guarantee that the `iteratee` functions will complete
 * in order. However, the results array will be in the same order as the
 * original `coll`.
 *
 * If `map` is passed an Object, the results will be an Array.  The results
 * will roughly be in the order of the original Objects' keys (but this can
 * vary across JavaScript engines).
 *
 * @name map
 * @static
 * @memberOf module:Collections
 * @method
 * @category Collection
 * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.
 * @param {AsyncFunction} iteratee - An async function to apply to each item in
 * `coll`.
 * The iteratee should complete with the transformed item.
 * Invoked with (item, callback).
 * @param {Function} [callback] - A callback which is called when all `iteratee`
 * functions have finished, or an error occurs. Results is an Array of the
 * transformed items from the `coll`. Invoked with (err, results).
 * @returns {Promise} a promise, if no callback is passed
 * @example
 *
 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
 *     // results is now an array of stats for each file
 * });
 */
function map(coll, iteratee, callback) {
  return (0, _map3.default)(_eachOf2.default, coll, iteratee, callback);
}
exports.default = (0, _awaitify2.default)(map, 3);
module.exports = exports['default'];
},{"./eachOf":66,"./internal/awaitify":70,"./internal/map":77}],86:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parallel;

var _eachOf = require('./eachOf');

var _eachOf2 = _interopRequireDefault(_eachOf);

var _parallel2 = require('./internal/parallel');

var _parallel3 = _interopRequireDefault(_parallel2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Run the `tasks` collection of functions in parallel, without waiting until
 * the previous function has completed. If any of the functions pass an error to
 * its callback, the main `callback` is immediately called with the value of the
 * error. Once the `tasks` have completed, the results are passed to the final
 * `callback` as an array.
 *
 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
 * parallel execution of code.  If your tasks do not use any timers or perform
 * any I/O, they will actually be executed in series.  Any synchronous setup
 * sections for each task will happen one after the other.  JavaScript remains
 * single-threaded.
 *
 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
 * execution of other tasks when a task fails.
 *
 * It is also possible to use an object instead of an array. Each property will
 * be run as a function and the results will be passed to the final `callback`
 * as an object instead of an array. This can be a more readable way of handling
 * results from {@link async.parallel}.
 *
 * @name parallel
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array|Iterable|AsyncIterable|Object} tasks - A collection of
 * [async functions]{@link AsyncFunction} to run.
 * Each async function can complete with any number of optional `result` values.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed successfully. This function gets a results array
 * (or object) containing all the result arguments passed to the task callbacks.
 * Invoked with (err, results).
 * @returns {Promise} a promise, if a callback is not passed
 *
 * @example
 * async.parallel([
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'one');
 *         }, 200);
 *     },
 *     function(callback) {
 *         setTimeout(function() {
 *             callback(null, 'two');
 *         }, 100);
 *     }
 * ],
 * // optional callback
 * function(err, results) {
 *     // the results array will equal ['one','two'] even though
 *     // the second function had a shorter timeout.
 * });
 *
 * // an example using an object instead of an array
 * async.parallel({
 *     one: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 1);
 *         }, 200);
 *     },
 *     two: function(callback) {
 *         setTimeout(function() {
 *             callback(null, 2);
 *         }, 100);
 *     }
 * }, function(err, results) {
 *     // results is now equals to: {one: 1, two: 2}
 * });
 */
function parallel(tasks, callback) {
  return (0, _parallel3.default)(_eachOf2.default, tasks, callback);
}
module.exports = exports['default'];
},{"./eachOf":66,"./internal/parallel":80}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = retry;

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _promiseCallback = require('./internal/promiseCallback');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function constant(value) {
    return function () {
        return value;
    };
}

/**
 * Attempts to get a successful response from `task` no more than `times` times
 * before returning an error. If the task is successful, the `callback` will be
 * passed the result of the successful task. If all attempts fail, the callback
 * will be passed the error and result (if any) of the final attempt.
 *
 * @name retry
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @see [async.retryable]{@link module:ControlFlow.retryable}
 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
 * object with `times` and `interval` or a number.
 * * `times` - The number of attempts to make before giving up.  The default
 *   is `5`.
 * * `interval` - The time to wait between retries, in milliseconds.  The
 *   default is `0`. The interval may also be specified as a function of the
 *   retry count (see example).
 * * `errorFilter` - An optional synchronous function that is invoked on
 *   erroneous result. If it returns `true` the retry attempts will continue;
 *   if the function returns `false` the retry flow is aborted with the current
 *   attempt's error and result being returned to the final callback.
 *   Invoked with (err).
 * * If `opts` is a number, the number specifies the number of times to retry,
 *   with the default interval of `0`.
 * @param {AsyncFunction} task - An async function to retry.
 * Invoked with (callback).
 * @param {Function} [callback] - An optional callback which is called when the
 * task has succeeded, or after the final failed attempt. It receives the `err`
 * and `result` arguments of the last attempt at completing the `task`. Invoked
 * with (err, results).
 * @returns {Promise} a promise if no callback provided
 *
 * @example
 *
 * // The `retry` function can be used as a stand-alone control flow by passing
 * // a callback, as shown below:
 *
 * // try calling apiMethod 3 times
 * async.retry(3, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 3 times, waiting 200 ms between each retry
 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod 10 times with exponential backoff
 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
 * async.retry({
 *   times: 10,
 *   interval: function(retryCount) {
 *     return 50 * Math.pow(2, retryCount);
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod the default 5 times no delay between each retry
 * async.retry(apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // try calling apiMethod only when error condition satisfies, all other
 * // errors will abort the retry control flow and return to final callback
 * async.retry({
 *   errorFilter: function(err) {
 *     return err.message === 'Temporary error'; // only retry on a specific error
 *   }
 * }, apiMethod, function(err, result) {
 *     // do something with the result
 * });
 *
 * // to retry individual methods that are not as reliable within other
 * // control flow functions, use the `retryable` wrapper:
 * async.auto({
 *     users: api.getUsers.bind(api),
 *     payments: async.retryable(3, api.getPayments.bind(api))
 * }, function(err, results) {
 *     // do something with the results
 * });
 *
 */
const DEFAULT_TIMES = 5;
const DEFAULT_INTERVAL = 0;

function retry(opts, task, callback) {
    var options = {
        times: DEFAULT_TIMES,
        intervalFunc: constant(DEFAULT_INTERVAL)
    };

    if (arguments.length < 3 && typeof opts === 'function') {
        callback = task || (0, _promiseCallback.promiseCallback)();
        task = opts;
    } else {
        parseTimes(options, opts);
        callback = callback || (0, _promiseCallback.promiseCallback)();
    }

    if (typeof task !== 'function') {
        throw new Error("Invalid arguments for async.retry");
    }

    var _task = (0, _wrapAsync2.default)(task);

    var attempt = 1;
    function retryAttempt() {
        _task((err, ...args) => {
            if (err === false) return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != 'function' || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
                callback(err, ...args);
            }
        });
    }

    retryAttempt();
    return callback[_promiseCallback.PROMISE_SYMBOL];
}

function parseTimes(acc, t) {
    if (typeof t === 'object') {
        acc.times = +t.times || DEFAULT_TIMES;

        acc.intervalFunc = typeof t.interval === 'function' ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);

        acc.errorFilter = t.errorFilter;
    } else if (typeof t === 'number' || typeof t === 'string') {
        acc.times = +t || DEFAULT_TIMES;
    } else {
        throw new Error("Invalid arguments for async.retry");
    }
}
module.exports = exports['default'];
},{"./internal/promiseCallback":81,"./internal/wrapAsync":84}],88:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _once = require('./internal/once');

var _once2 = _interopRequireDefault(_once);

var _onlyOnce = require('./internal/onlyOnce');

var _onlyOnce2 = _interopRequireDefault(_onlyOnce);

var _wrapAsync = require('./internal/wrapAsync');

var _wrapAsync2 = _interopRequireDefault(_wrapAsync);

var _awaitify = require('./internal/awaitify');

var _awaitify2 = _interopRequireDefault(_awaitify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Runs the `tasks` array of functions in series, each passing their results to
 * the next in the array. However, if any of the `tasks` pass an error to their
 * own callback, the next function is not executed, and the main `callback` is
 * immediately called with the error.
 *
 * @name waterfall
 * @static
 * @memberOf module:ControlFlow
 * @method
 * @category Control Flow
 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
 * to run.
 * Each function should complete with any number of `result` values.
 * The `result` values will be passed as arguments, in order, to the next task.
 * @param {Function} [callback] - An optional callback to run once all the
 * functions have completed. This will be passed the results of the last task's
 * callback. Invoked with (err, [results]).
 * @returns undefined
 * @example
 *
 * async.waterfall([
 *     function(callback) {
 *         callback(null, 'one', 'two');
 *     },
 *     function(arg1, arg2, callback) {
 *         // arg1 now equals 'one' and arg2 now equals 'two'
 *         callback(null, 'three');
 *     },
 *     function(arg1, callback) {
 *         // arg1 now equals 'three'
 *         callback(null, 'done');
 *     }
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 *
 * // Or, with named functions:
 * async.waterfall([
 *     myFirstFunction,
 *     mySecondFunction,
 *     myLastFunction,
 * ], function (err, result) {
 *     // result now equals 'done'
 * });
 * function myFirstFunction(callback) {
 *     callback(null, 'one', 'two');
 * }
 * function mySecondFunction(arg1, arg2, callback) {
 *     // arg1 now equals 'one' and arg2 now equals 'two'
 *     callback(null, 'three');
 * }
 * function myLastFunction(arg1, callback) {
 *     // arg1 now equals 'three'
 *     callback(null, 'done');
 * }
 */
function waterfall(tasks, callback) {
    callback = (0, _once2.default)(callback);
    if (!Array.isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
    if (!tasks.length) return callback();
    var taskIndex = 0;

    function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        task(...args, (0, _onlyOnce2.default)(next));
    }

    function next(err, ...args) {
        if (err === false) return;
        if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
        }
        nextTask(args);
    }

    nextTask([]);
}

exports.default = (0, _awaitify2.default)(waterfall);
module.exports = exports['default'];
},{"./internal/awaitify":70,"./internal/once":78,"./internal/onlyOnce":79,"./internal/wrapAsync":84}],89:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var crypto_utils_1 = require("./crypto_utils");
var logger_1 = require("./logger");
/**
 * Generates a cryptographically random new state. Useful for CSRF protection.
 */
var SIZE = 10; // 10 bytes
var newState = function (crypto) {
    return crypto.generateRandom(SIZE);
};
/**
 * Represents the AuthorizationRequest.
 * For more information look at
 * https://tools.ietf.org/html/rfc6749#section-4.1.1
 */
var AuthorizationRequest = /** @class */ (function () {
    /**
     * Constructs a new AuthorizationRequest.
     * Use a `undefined` value for the `state` parameter, to generate a random
     * state for CSRF protection.
     */
    function AuthorizationRequest(request, crypto, usePkce) {
        if (crypto === void 0) { crypto = new crypto_utils_1.DefaultCrypto(); }
        if (usePkce === void 0) { usePkce = true; }
        this.crypto = crypto;
        this.usePkce = usePkce;
        this.clientId = request.client_id;
        this.redirectUri = request.redirect_uri;
        this.scope = request.scope;
        this.responseType = request.response_type || AuthorizationRequest.RESPONSE_TYPE_CODE;
        this.state = request.state || newState(crypto);
        this.extras = request.extras;
        // read internal properties if available
        this.internal = request.internal;
    }
    AuthorizationRequest.prototype.setupCodeVerifier = function () {
        var _this = this;
        if (!this.usePkce) {
            return Promise.resolve();
        }
        else {
            var codeVerifier_1 = this.crypto.generateRandom(128);
            var challenge = this.crypto.deriveChallenge(codeVerifier_1).catch(function (error) {
                logger_1.log('Unable to generate PKCE challenge. Not using PKCE', error);
                return undefined;
            });
            return challenge.then(function (result) {
                if (result) {
                    // keep track of the code used.
                    _this.internal = _this.internal || {};
                    _this.internal['code_verifier'] = codeVerifier_1;
                    _this.extras = _this.extras || {};
                    _this.extras['code_challenge'] = result;
                    // We always use S256. Plain is not good enough.
                    _this.extras['code_challenge_method'] = 'S256';
                }
            });
        }
    };
    /**
     * Serializes the AuthorizationRequest to a JavaScript Object.
     */
    AuthorizationRequest.prototype.toJson = function () {
        var _this = this;
        // Always make sure that the code verifier is setup when toJson() is called.
        return this.setupCodeVerifier().then(function () {
            return {
                response_type: _this.responseType,
                client_id: _this.clientId,
                redirect_uri: _this.redirectUri,
                scope: _this.scope,
                state: _this.state,
                extras: _this.extras,
                internal: _this.internal
            };
        });
    };
    AuthorizationRequest.RESPONSE_TYPE_TOKEN = 'token';
    AuthorizationRequest.RESPONSE_TYPE_CODE = 'code';
    return AuthorizationRequest;
}());
exports.AuthorizationRequest = AuthorizationRequest;

},{"./crypto_utils":93,"./logger":97}],90:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var logger_1 = require("./logger");
/**
 * Authorization Service notifier.
 * This manages the communication of the AuthorizationResponse to the 3p client.
 */
var AuthorizationNotifier = /** @class */ (function () {
    function AuthorizationNotifier() {
        this.listener = null;
    }
    AuthorizationNotifier.prototype.setAuthorizationListener = function (listener) {
        this.listener = listener;
    };
    /**
     * The authorization complete callback.
     */
    AuthorizationNotifier.prototype.onAuthorizationComplete = function (request, response, error) {
        if (this.listener) {
            // complete authorization request
            this.listener(request, response, error);
        }
    };
    return AuthorizationNotifier;
}());
exports.AuthorizationNotifier = AuthorizationNotifier;
// TODO(rahulrav@): add more built in parameters.
/* built in parameters. */
exports.BUILT_IN_PARAMETERS = ['redirect_uri', 'client_id', 'response_type', 'state', 'scope'];
/**
 * Defines the interface which is capable of handling an authorization request
 * using various methods (iframe / popup / different process etc.).
 */
var AuthorizationRequestHandler = /** @class */ (function () {
    function AuthorizationRequestHandler(utils, crypto) {
        this.utils = utils;
        this.crypto = crypto;
        // notifier send the response back to the client.
        this.notifier = null;
    }
    /**
     * A utility method to be able to build the authorization request URL.
     */
    AuthorizationRequestHandler.prototype.buildRequestUrl = function (configuration, request) {
        // build the query string
        // coerce to any type for convenience
        var requestMap = {
            'redirect_uri': request.redirectUri,
            'client_id': request.clientId,
            'response_type': request.responseType,
            'state': request.state,
            'scope': request.scope
        };
        // copy over extras
        if (request.extras) {
            for (var extra in request.extras) {
                if (request.extras.hasOwnProperty(extra)) {
                    // check before inserting to requestMap
                    if (exports.BUILT_IN_PARAMETERS.indexOf(extra) < 0) {
                        requestMap[extra] = request.extras[extra];
                    }
                }
            }
        }
        var query = this.utils.stringify(requestMap);
        var baseUrl = configuration.authorizationEndpoint;
        var url = baseUrl + "?" + query;
        return url;
    };
    /**
     * Completes the authorization request if necessary & when possible.
     */
    AuthorizationRequestHandler.prototype.completeAuthorizationRequestIfPossible = function () {
        var _this = this;
        // call complete authorization if possible to see there might
        // be a response that needs to be delivered.
        logger_1.log("Checking to see if there is an authorization response to be delivered.");
        if (!this.notifier) {
            logger_1.log("Notifier is not present on AuthorizationRequest handler.\n          No delivery of result will be possible");
        }
        return this.completeAuthorizationRequest().then(function (result) {
            if (!result) {
                logger_1.log("No result is available yet.");
            }
            if (result && _this.notifier) {
                _this.notifier.onAuthorizationComplete(result.request, result.response, result.error);
            }
        });
    };
    /**
     * Sets the default Authorization Service notifier.
     */
    AuthorizationRequestHandler.prototype.setAuthorizationNotifier = function (notifier) {
        this.notifier = notifier;
        return this;
    };
    ;
    return AuthorizationRequestHandler;
}());
exports.AuthorizationRequestHandler = AuthorizationRequestHandler;

},{"./logger":97}],91:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the Authorization Response type.
 * For more information look at
 * https://tools.ietf.org/html/rfc6749#section-4.1.2
 */
var AuthorizationResponse = /** @class */ (function () {
    function AuthorizationResponse(response) {
        this.code = response.code;
        this.state = response.state;
    }
    AuthorizationResponse.prototype.toJson = function () {
        return { code: this.code, state: this.state };
    };
    return AuthorizationResponse;
}());
exports.AuthorizationResponse = AuthorizationResponse;
/**
 * Represents the Authorization error response.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-4.1.2.1
 */
var AuthorizationError = /** @class */ (function () {
    function AuthorizationError(error) {
        this.error = error.error;
        this.errorDescription = error.error_description;
        this.errorUri = error.error_uri;
        this.state = error.state;
    }
    AuthorizationError.prototype.toJson = function () {
        return {
            error: this.error,
            error_description: this.errorDescription,
            error_uri: this.errorUri,
            state: this.state
        };
    };
    return AuthorizationError;
}());
exports.AuthorizationError = AuthorizationError;

},{}],92:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var xhr_1 = require("./xhr");
/**
 * The standard base path for well-known resources on domains.
 * See https://tools.ietf.org/html/rfc5785 for more information.
 */
var WELL_KNOWN_PATH = '.well-known';
/**
 * The standard resource under the well known path at which an OpenID Connect
 * discovery document can be found under an issuer's base URI.
 */
var OPENID_CONFIGURATION = 'openid-configuration';
/**
 * Configuration details required to interact with an authorization service.
 *
 * More information at https://openid.net/specs/openid-connect-discovery-1_0-17.html
 */
var AuthorizationServiceConfiguration = /** @class */ (function () {
    function AuthorizationServiceConfiguration(request) {
        this.authorizationEndpoint = request.authorization_endpoint;
        this.tokenEndpoint = request.token_endpoint;
        this.revocationEndpoint = request.revocation_endpoint;
        this.userInfoEndpoint = request.userinfo_endpoint;
        this.endSessionEndpoint = request.end_session_endpoint;
    }
    AuthorizationServiceConfiguration.prototype.toJson = function () {
        return {
            authorization_endpoint: this.authorizationEndpoint,
            token_endpoint: this.tokenEndpoint,
            revocation_endpoint: this.revocationEndpoint,
            end_session_endpoint: this.endSessionEndpoint,
            userinfo_endpoint: this.userInfoEndpoint
        };
    };
    AuthorizationServiceConfiguration.fetchFromIssuer = function (openIdIssuerUrl, requestor) {
        var fullUrl = openIdIssuerUrl + "/" + WELL_KNOWN_PATH + "/" + OPENID_CONFIGURATION;
        var requestorToUse = requestor || new xhr_1.JQueryRequestor();
        return requestorToUse
            .xhr({ url: fullUrl, dataType: 'json', method: 'GET' })
            .then(function (json) { return new AuthorizationServiceConfiguration(json); });
    };
    return AuthorizationServiceConfiguration;
}());
exports.AuthorizationServiceConfiguration = AuthorizationServiceConfiguration;

},{"./xhr":105}],93:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var base64 = require("base64-js");
var errors_1 = require("./errors");
var HAS_CRYPTO = typeof window !== 'undefined' && !!window.crypto;
var HAS_SUBTLE_CRYPTO = HAS_CRYPTO && !!window.crypto.subtle;
var CHARSET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
function bufferToString(buffer) {
    var state = [];
    for (var i = 0; i < buffer.byteLength; i += 1) {
        var index = buffer[i] % CHARSET.length;
        state.push(CHARSET[index]);
    }
    return state.join('');
}
exports.bufferToString = bufferToString;
function urlSafe(buffer) {
    var encoded = base64.fromByteArray(new Uint8Array(buffer));
    return encoded.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
exports.urlSafe = urlSafe;
// adapted from source: http://stackoverflow.com/a/11058858
// this is used in place of TextEncode as the api is not yet
// well supported: https://caniuse.com/#search=TextEncoder
function textEncodeLite(str) {
    var buf = new ArrayBuffer(str.length);
    var bufView = new Uint8Array(buf);
    for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return bufView;
}
exports.textEncodeLite = textEncodeLite;
/**
 * The default implementation of the `Crypto` interface.
 * This uses the capabilities of the browser.
 */
var DefaultCrypto = /** @class */ (function () {
    function DefaultCrypto() {
    }
    DefaultCrypto.prototype.generateRandom = function (size) {
        var buffer = new Uint8Array(size);
        if (HAS_CRYPTO) {
            window.crypto.getRandomValues(buffer);
        }
        else {
            // fall back to Math.random() if nothing else is available
            for (var i = 0; i < size; i += 1) {
                buffer[i] = (Math.random() * CHARSET.length) | 0;
            }
        }
        return bufferToString(buffer);
    };
    DefaultCrypto.prototype.deriveChallenge = function (code) {
        if (code.length < 43 || code.length > 128) {
            return Promise.reject(new errors_1.AppAuthError('Invalid code length.'));
        }
        if (!HAS_SUBTLE_CRYPTO) {
            return Promise.reject(new errors_1.AppAuthError('window.crypto.subtle is unavailable.'));
        }
        return new Promise(function (resolve, reject) {
            crypto.subtle.digest('SHA-256', textEncodeLite(code)).then(function (buffer) {
                return resolve(urlSafe(new Uint8Array(buffer)));
            }, function (error) { return reject(error); });
        });
    };
    return DefaultCrypto;
}());
exports.DefaultCrypto = DefaultCrypto;

},{"./errors":94,"base64-js":106}],94:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents the AppAuthError type.
 */
var AppAuthError = /** @class */ (function () {
    function AppAuthError(message, extras) {
        this.message = message;
        this.extras = extras;
    }
    return AppAuthError;
}());
exports.AppAuthError = AppAuthError;

},{}],95:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
/* Global flags that control the behavior of App Auth JS. */
/* Logging turned on ? */
exports.IS_LOG = true;
/* Profiling turned on ? */
exports.IS_PROFILE = false;

},{}],96:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./authorization_request"));
__export(require("./authorization_request_handler"));
__export(require("./authorization_response"));
__export(require("./authorization_service_configuration"));
__export(require("./crypto_utils"));
__export(require("./errors"));
__export(require("./flags"));
__export(require("./logger"));
__export(require("./query_string_utils"));
__export(require("./redirect_based_handler"));
__export(require("./revoke_token_request"));
__export(require("./storage"));
__export(require("./token_request"));
__export(require("./token_request_handler"));
__export(require("./token_response"));
__export(require("./xhr"));

},{"./authorization_request":89,"./authorization_request_handler":90,"./authorization_response":91,"./authorization_service_configuration":92,"./crypto_utils":93,"./errors":94,"./flags":95,"./logger":97,"./query_string_utils":98,"./redirect_based_handler":99,"./revoke_token_request":100,"./storage":101,"./token_request":102,"./token_request_handler":103,"./token_response":104,"./xhr":105}],97:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var flags_1 = require("./flags");
function log(message) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (flags_1.IS_LOG) {
        var length_1 = args ? args.length : 0;
        if (length_1 > 0) {
            console.log.apply(console, __spreadArrays([message], args));
        }
        else {
            console.log(message);
        }
    }
}
exports.log = log;
;
// check to see if native support for profiling is available.
var NATIVE_PROFILE_SUPPORT = typeof window !== 'undefined' && !!window.performance && !!console.profile;
/**
 * A decorator that can profile a function.
 */
function profile(target, propertyKey, descriptor) {
    if (flags_1.IS_PROFILE) {
        return performProfile(target, propertyKey, descriptor);
    }
    else {
        // return as-is
        return descriptor;
    }
}
exports.profile = profile;
function performProfile(target, propertyKey, descriptor) {
    var originalCallable = descriptor.value;
    // name must exist
    var name = originalCallable.name;
    if (!name) {
        name = 'anonymous function';
    }
    if (NATIVE_PROFILE_SUPPORT) {
        descriptor.value = function (args) {
            console.profile(name);
            var startTime = window.performance.now();
            var result = originalCallable.call.apply(originalCallable, __spreadArrays([this || window], args));
            var duration = window.performance.now() - startTime;
            console.log(name + " took " + duration + " ms");
            console.profileEnd();
            return result;
        };
    }
    else {
        descriptor.value = function (args) {
            log("Profile start " + name);
            var start = Date.now();
            var result = originalCallable.call.apply(originalCallable, __spreadArrays([this || window], args));
            var duration = Date.now() - start;
            log("Profile end " + name + " took " + duration + " ms.");
            return result;
        };
    }
    return descriptor;
}

},{"./flags":95}],98:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var BasicQueryStringUtils = /** @class */ (function () {
    function BasicQueryStringUtils() {
    }
    BasicQueryStringUtils.prototype.parse = function (input, useHash) {
        if (useHash) {
            return this.parseQueryString(input.hash);
        }
        else {
            return this.parseQueryString(input.search);
        }
    };
    BasicQueryStringUtils.prototype.parseQueryString = function (query) {
        var result = {};
        // if anything starts with ?, # or & remove it
        query = query.trim().replace(/^(\?|#|&)/, '');
        var params = query.split('&');
        for (var i = 0; i < params.length; i += 1) {
            var param = params[i]; // looks something like a=b
            var parts = param.split('=');
            if (parts.length >= 2) {
                var key = decodeURIComponent(parts.shift());
                var value = parts.length > 0 ? parts.join('=') : null;
                if (value) {
                    result[key] = decodeURIComponent(value);
                }
            }
        }
        return result;
    };
    BasicQueryStringUtils.prototype.stringify = function (input) {
        var encoded = [];
        for (var key in input) {
            if (input.hasOwnProperty(key) && input[key]) {
                encoded.push(encodeURIComponent(key) + "=" + encodeURIComponent(input[key]));
            }
        }
        return encoded.join('&');
    };
    return BasicQueryStringUtils;
}());
exports.BasicQueryStringUtils = BasicQueryStringUtils;

},{}],99:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var authorization_request_1 = require("./authorization_request");
var authorization_request_handler_1 = require("./authorization_request_handler");
var authorization_response_1 = require("./authorization_response");
var crypto_utils_1 = require("./crypto_utils");
var logger_1 = require("./logger");
var query_string_utils_1 = require("./query_string_utils");
var storage_1 = require("./storage");
/** key for authorization request. */
var authorizationRequestKey = function (handle) {
    return handle + "_appauth_authorization_request";
};
/** key for authorization service configuration */
var authorizationServiceConfigurationKey = function (handle) {
    return handle + "_appauth_authorization_service_configuration";
};
/** key in local storage which represents the current authorization request. */
var AUTHORIZATION_REQUEST_HANDLE_KEY = 'appauth_current_authorization_request';
/**
 * Represents an AuthorizationRequestHandler which uses a standard
 * redirect based code flow.
 */
var RedirectRequestHandler = /** @class */ (function (_super) {
    __extends(RedirectRequestHandler, _super);
    function RedirectRequestHandler(
    // use the provided storage backend
    // or initialize local storage with the default storage backend which
    // uses window.localStorage
    storageBackend, utils, locationLike, crypto) {
        if (storageBackend === void 0) { storageBackend = new storage_1.LocalStorageBackend(); }
        if (utils === void 0) { utils = new query_string_utils_1.BasicQueryStringUtils(); }
        if (locationLike === void 0) { locationLike = window.location; }
        if (crypto === void 0) { crypto = new crypto_utils_1.DefaultCrypto(); }
        var _this = _super.call(this, utils, crypto) || this;
        _this.storageBackend = storageBackend;
        _this.locationLike = locationLike;
        return _this;
    }
    RedirectRequestHandler.prototype.performAuthorizationRequest = function (configuration, request) {
        var _this = this;
        var handle = this.crypto.generateRandom(10);
        // before you make request, persist all request related data in local storage.
        var persisted = Promise.all([
            this.storageBackend.setItem(AUTHORIZATION_REQUEST_HANDLE_KEY, handle),
            // Calling toJson() adds in the code & challenge when possible
            request.toJson().then(function (result) {
                return _this.storageBackend.setItem(authorizationRequestKey(handle), JSON.stringify(result));
            }),
            this.storageBackend.setItem(authorizationServiceConfigurationKey(handle), JSON.stringify(configuration.toJson())),
        ]);
        persisted.then(function () {
            // make the redirect request
            var url = _this.buildRequestUrl(configuration, request);
            logger_1.log('Making a request to ', request, url);
            _this.locationLike.assign(url);
        });
    };
    /**
     * Attempts to introspect the contents of storage backend and completes the
     * request.
     */
    RedirectRequestHandler.prototype.completeAuthorizationRequest = function () {
        var _this = this;
        // TODO(rahulrav@): handle authorization errors.
        return this.storageBackend.getItem(AUTHORIZATION_REQUEST_HANDLE_KEY).then(function (handle) {
            if (handle) {
                // we have a pending request.
                // fetch authorization request, and check state
                return _this.storageBackend
                    .getItem(authorizationRequestKey(handle))
                    // requires a corresponding instance of result
                    // TODO(rahulrav@): check for inconsitent state here
                    .then(function (result) { return JSON.parse(result); })
                    .then(function (json) { return new authorization_request_1.AuthorizationRequest(json); })
                    .then(function (request) {
                    // check redirect_uri and state
                    var currentUri = "" + _this.locationLike.origin + _this.locationLike.pathname;
                    var queryParams = _this.utils.parse(_this.locationLike, true /* use hash */);
                    var state = queryParams['state'];
                    var code = queryParams['code'];
                    var error = queryParams['error'];
                    logger_1.log('Potential authorization request ', currentUri, queryParams, state, code, error);
                    var shouldNotify = state === request.state;
                    var authorizationResponse = null;
                    var authorizationError = null;
                    if (shouldNotify) {
                        if (error) {
                            // get additional optional info.
                            var errorUri = queryParams['error_uri'];
                            var errorDescription = queryParams['error_description'];
                            authorizationError = new authorization_response_1.AuthorizationError({
                                error: error,
                                error_description: errorDescription,
                                error_uri: errorUri,
                                state: state
                            });
                        }
                        else {
                            authorizationResponse = new authorization_response_1.AuthorizationResponse({ code: code, state: state });
                        }
                        // cleanup state
                        return Promise
                            .all([
                            _this.storageBackend.removeItem(AUTHORIZATION_REQUEST_HANDLE_KEY),
                            _this.storageBackend.removeItem(authorizationRequestKey(handle)),
                            _this.storageBackend.removeItem(authorizationServiceConfigurationKey(handle))
                        ])
                            .then(function () {
                            logger_1.log('Delivering authorization response');
                            return {
                                request: request,
                                response: authorizationResponse,
                                error: authorizationError
                            };
                        });
                    }
                    else {
                        logger_1.log('Mismatched request (state and request_uri) dont match.');
                        return Promise.resolve(null);
                    }
                });
            }
            else {
                return null;
            }
        });
    };
    return RedirectRequestHandler;
}(authorization_request_handler_1.AuthorizationRequestHandler));
exports.RedirectRequestHandler = RedirectRequestHandler;

},{"./authorization_request":89,"./authorization_request_handler":90,"./authorization_response":91,"./crypto_utils":93,"./logger":97,"./query_string_utils":98,"./storage":101}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a revoke token request.
 * For more information look at:
 * https://tools.ietf.org/html/rfc7009#section-2.1
 */
var RevokeTokenRequest = /** @class */ (function () {
    function RevokeTokenRequest(request) {
        this.token = request.token;
        this.tokenTypeHint = request.token_type_hint;
        this.clientId = request.client_id;
        this.clientSecret = request.client_secret;
    }
    /**
     * Serializes a TokenRequest to a JavaScript object.
     */
    RevokeTokenRequest.prototype.toJson = function () {
        var json = { token: this.token };
        if (this.tokenTypeHint) {
            json['token_type_hint'] = this.tokenTypeHint;
        }
        if (this.clientId) {
            json['client_id'] = this.clientId;
        }
        if (this.clientSecret) {
            json['client_secret'] = this.clientSecret;
        }
        return json;
    };
    RevokeTokenRequest.prototype.toStringMap = function () {
        var json = this.toJson();
        // :(
        return json;
    };
    return RevokeTokenRequest;
}());
exports.RevokeTokenRequest = RevokeTokenRequest;

},{}],101:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Asynchronous storage APIs. All methods return a `Promise`.
 * All methods take the `DOMString`
 * IDL type (as it is the lowest common denominator).
 */
var StorageBackend = /** @class */ (function () {
    function StorageBackend() {
    }
    return StorageBackend;
}());
exports.StorageBackend = StorageBackend;
/**
 * A `StorageBackend` backed by `localstorage`.
 */
var LocalStorageBackend = /** @class */ (function (_super) {
    __extends(LocalStorageBackend, _super);
    function LocalStorageBackend(storage) {
        var _this = _super.call(this) || this;
        _this.storage = storage || window.localStorage;
        return _this;
    }
    LocalStorageBackend.prototype.getItem = function (name) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var value = _this.storage.getItem(name);
            if (value) {
                resolve(value);
            }
            else {
                resolve(null);
            }
        });
    };
    LocalStorageBackend.prototype.removeItem = function (name) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.storage.removeItem(name);
            resolve();
        });
    };
    LocalStorageBackend.prototype.clear = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.storage.clear();
            resolve();
        });
    };
    LocalStorageBackend.prototype.setItem = function (name, value) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.storage.setItem(name, value);
            resolve();
        });
    };
    return LocalStorageBackend;
}(StorageBackend));
exports.LocalStorageBackend = LocalStorageBackend;

},{}],102:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GRANT_TYPE_AUTHORIZATION_CODE = 'authorization_code';
exports.GRANT_TYPE_REFRESH_TOKEN = 'refresh_token';
/**
 * Represents an Access Token request.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-4.1.3
 */
var TokenRequest = /** @class */ (function () {
    function TokenRequest(request) {
        this.clientId = request.client_id;
        this.redirectUri = request.redirect_uri;
        this.grantType = request.grant_type;
        this.code = request.code;
        this.refreshToken = request.refresh_token;
        this.extras = request.extras;
    }
    /**
     * Serializes a TokenRequest to a JavaScript object.
     */
    TokenRequest.prototype.toJson = function () {
        return {
            grant_type: this.grantType,
            code: this.code,
            refresh_token: this.refreshToken,
            redirect_uri: this.redirectUri,
            client_id: this.clientId,
            extras: this.extras
        };
    };
    TokenRequest.prototype.toStringMap = function () {
        var map = {
            grant_type: this.grantType,
            client_id: this.clientId,
            redirect_uri: this.redirectUri
        };
        if (this.code) {
            map['code'] = this.code;
        }
        if (this.refreshToken) {
            map['refresh_token'] = this.refreshToken;
        }
        // copy over extras
        if (this.extras) {
            for (var extra in this.extras) {
                if (this.extras.hasOwnProperty(extra) && !map.hasOwnProperty(extra)) {
                    // check before inserting to requestMap
                    map[extra] = this.extras[extra];
                }
            }
        }
        return map;
    };
    return TokenRequest;
}());
exports.TokenRequest = TokenRequest;

},{}],103:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
var query_string_utils_1 = require("./query_string_utils");
var token_response_1 = require("./token_response");
var xhr_1 = require("./xhr");
/**
 * The default token request handler.
 */
var BaseTokenRequestHandler = /** @class */ (function () {
    function BaseTokenRequestHandler(requestor, utils) {
        if (requestor === void 0) { requestor = new xhr_1.JQueryRequestor(); }
        if (utils === void 0) { utils = new query_string_utils_1.BasicQueryStringUtils(); }
        this.requestor = requestor;
        this.utils = utils;
    }
    BaseTokenRequestHandler.prototype.isTokenResponse = function (response) {
        return response.error === undefined;
    };
    BaseTokenRequestHandler.prototype.performRevokeTokenRequest = function (configuration, request) {
        var revokeTokenResponse = this.requestor.xhr({
            url: configuration.revocationEndpoint,
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            data: this.utils.stringify(request.toStringMap())
        });
        return revokeTokenResponse.then(function (response) {
            return true;
        });
    };
    BaseTokenRequestHandler.prototype.performTokenRequest = function (configuration, request) {
        var _this = this;
        var tokenResponse = this.requestor.xhr({
            url: configuration.tokenEndpoint,
            method: 'POST',
            dataType: 'json',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            data: this.utils.stringify(request.toStringMap())
        });
        return tokenResponse.then(function (response) {
            if (_this.isTokenResponse(response)) {
                return new token_response_1.TokenResponse(response);
            }
            else {
                return Promise.reject(new errors_1.AppAuthError(response.error, new token_response_1.TokenError(response)));
            }
        });
    };
    return BaseTokenRequestHandler;
}());
exports.BaseTokenRequestHandler = BaseTokenRequestHandler;

},{"./errors":94,"./query_string_utils":98,"./token_response":104,"./xhr":105}],104:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
// constants
var AUTH_EXPIRY_BUFFER = 10 * 60 * -1; // 10 mins in seconds
/**
 * Returns the instant of time in seconds.
 */
exports.nowInSeconds = function () { return Math.round(new Date().getTime() / 1000); };
/**
 * Represents the Token Response type.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-5.1
 */
var TokenResponse = /** @class */ (function () {
    function TokenResponse(response) {
        this.accessToken = response.access_token;
        this.tokenType = response.token_type || 'bearer';
        this.expiresIn = response.expires_in;
        this.refreshToken = response.refresh_token;
        this.scope = response.scope;
        this.idToken = response.id_token;
        this.issuedAt = response.issued_at || exports.nowInSeconds();
    }
    TokenResponse.prototype.toJson = function () {
        return {
            access_token: this.accessToken,
            id_token: this.idToken,
            refresh_token: this.refreshToken,
            scope: this.scope,
            token_type: this.tokenType,
            issued_at: this.issuedAt,
            expires_in: this.expiresIn
        };
    };
    TokenResponse.prototype.isValid = function (buffer) {
        if (buffer === void 0) { buffer = AUTH_EXPIRY_BUFFER; }
        if (this.expiresIn) {
            var now = exports.nowInSeconds();
            return now < this.issuedAt + this.expiresIn + buffer;
        }
        else {
            return true;
        }
    };
    return TokenResponse;
}());
exports.TokenResponse = TokenResponse;
/**
 * Represents the Token Error type.
 * For more information look at:
 * https://tools.ietf.org/html/rfc6749#section-5.2
 */
var TokenError = /** @class */ (function () {
    function TokenError(tokenError) {
        this.error = tokenError.error;
        this.errorDescription = tokenError.error_description;
        this.errorUri = tokenError.error_uri;
    }
    TokenError.prototype.toJson = function () {
        return {
            error: this.error, error_description: this.errorDescription, error_uri: this.errorUri
        };
    };
    return TokenError;
}());
exports.TokenError = TokenError;

},{}],105:[function(require,module,exports){
"use strict";
/*
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the
 * License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 * express or implied. See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("./errors");
/**
 * An class that abstracts away the ability to make an XMLHttpRequest.
 */
var Requestor = /** @class */ (function () {
    function Requestor() {
    }
    return Requestor;
}());
exports.Requestor = Requestor;
/**
 * Uses $.ajax to makes the Ajax requests.
 */
var JQueryRequestor = /** @class */ (function (_super) {
    __extends(JQueryRequestor, _super);
    function JQueryRequestor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JQueryRequestor.prototype.xhr = function (settings) {
        // NOTE: using jquery to make XHR's as whatwg-fetch requires
        // that I target ES6.
        var xhr = $.ajax(settings);
        return new Promise(function (resolve, reject) {
            xhr.then(function (data, textStatus, jqXhr) {
                resolve(data);
            }, function (jqXhr, textStatus, error) {
                reject(new errors_1.AppAuthError(error));
            });
        });
    };
    return JQueryRequestor;
}(Requestor));
exports.JQueryRequestor = JQueryRequestor;
/**
 * Uses fetch API to make Ajax requests
 */
var FetchRequestor = /** @class */ (function (_super) {
    __extends(FetchRequestor, _super);
    function FetchRequestor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FetchRequestor.prototype.xhr = function (settings) {
        if (!settings.url) {
            return Promise.reject(new errors_1.AppAuthError('A URL must be provided.'));
        }
        var url = new URL(settings.url);
        var requestInit = {};
        requestInit.method = settings.method;
        requestInit.mode = 'cors';
        if (settings.data) {
            if (settings.method && settings.method.toUpperCase() === 'POST') {
                requestInit.body = settings.data;
            }
            else {
                var searchParams = new URLSearchParams(settings.data);
                searchParams.forEach(function (value, key) {
                    url.searchParams.append(key, value);
                });
            }
        }
        // Set the request headers
        requestInit.headers = {};
        if (settings.headers) {
            for (var i in settings.headers) {
                if (settings.headers.hasOwnProperty(i)) {
                    requestInit.headers[i] = settings.headers[i];
                }
            }
        }
        var isJsonDataType = settings.dataType && settings.dataType.toLowerCase() === 'json';
        // Set 'Accept' header value for json requests (Taken from
        // https://github.com/jquery/jquery/blob/e0d941156900a6bff7c098c8ea7290528e468cf8/src/ajax.js#L644
        // )
        if (isJsonDataType) {
            requestInit.headers['Accept'] = 'application/json, text/javascript, */*; q=0.01';
        }
        return fetch(url.toString(), requestInit).then(function (response) {
            if (response.status >= 200 && response.status < 300) {
                var contentType = response.headers.get('content-type');
                if (isJsonDataType || (contentType && contentType.indexOf('application/json') !== -1)) {
                    return response.json();
                }
                else {
                    return response.text();
                }
            }
            else {
                return Promise.reject(new errors_1.AppAuthError(response.status.toString(), response.statusText));
            }
        });
    };
    return FetchRequestor;
}(Requestor));
exports.FetchRequestor = FetchRequestor;
/**
 * Should be used only in the context of testing. Just uses the underlying
 * Promise to mock the behavior of the Requestor.
 */
var TestRequestor = /** @class */ (function (_super) {
    __extends(TestRequestor, _super);
    function TestRequestor(promise) {
        var _this = _super.call(this) || this;
        _this.promise = promise;
        return _this;
    }
    TestRequestor.prototype.xhr = function (settings) {
        return this.promise; // unsafe cast
    };
    return TestRequestor;
}(Requestor));
exports.TestRequestor = TestRequestor;

},{"./errors":94}],106:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],107:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    Buffer = require('buffer').Buffer;
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
    }

    if (base === 16) {
      this._parseHex(number, start);
    } else {
      this._parseBase(number, base, start);
    }

    if (number[0] === '-') {
      this.negative = 1;
    }

    this.strip();

    if (endian !== 'le') return;

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex (str, start, end) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r <<= 4;

      // 'a' - 'f'
      if (c >= 49 && c <= 54) {
        r |= c - 49 + 0xa;

      // 'A' - 'F'
      } else if (c >= 17 && c <= 22) {
        r |= c - 17 + 0xa;

      // '0' - '9'
      } else {
        r |= c & 0xf;
      }
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    // Scan 24-bit chunks and add them to the number
    var off = 0;
    for (i = number.length - 6, j = 0; i >= start; i -= 6) {
      w = parseHex(number, i, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
    if (i + 6 !== start) {
      w = parseHex(number, start, i + 6);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    }
    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      r.strip();
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":108}],108:[function(require,module,exports){

},{}],109:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var objectCreate = Object.create || objectCreatePolyfill
var objectKeys = Object.keys || objectKeysPolyfill
var bind = Function.prototype.bind || functionBindPolyfill

function EventEmitter() {
  if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
    this._events = objectCreate(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

var hasDefineProperty;
try {
  var o = {};
  if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
  hasDefineProperty = o.x === 0;
} catch (err) { hasDefineProperty = false }
if (hasDefineProperty) {
  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      // check whether the input is a positive number (whose value is zero or
      // greater and not a NaN).
      if (typeof arg !== 'number' || arg < 0 || arg !== arg)
        throw new TypeError('"defaultMaxListeners" must be a positive number');
      defaultMaxListeners = arg;
    }
  });
} else {
  EventEmitter.defaultMaxListeners = defaultMaxListeners;
}

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || isNaN(n))
    throw new TypeError('"n" argument must be a positive number');
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function emitNone(handler, isFn, self) {
  if (isFn)
    handler.call(self);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self);
  }
}
function emitOne(handler, isFn, self, arg1) {
  if (isFn)
    handler.call(self, arg1);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1);
  }
}
function emitTwo(handler, isFn, self, arg1, arg2) {
  if (isFn)
    handler.call(self, arg1, arg2);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2);
  }
}
function emitThree(handler, isFn, self, arg1, arg2, arg3) {
  if (isFn)
    handler.call(self, arg1, arg2, arg3);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].call(self, arg1, arg2, arg3);
  }
}

function emitMany(handler, isFn, self, args) {
  if (isFn)
    handler.apply(self, args);
  else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      listeners[i].apply(self, args);
  }
}

EventEmitter.prototype.emit = function emit(type) {
  var er, handler, len, args, i, events;
  var doError = (type === 'error');

  events = this._events;
  if (events)
    doError = (doError && events.error == null);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    if (arguments.length > 1)
      er = arguments[1];
    if (er instanceof Error) {
      throw er; // Unhandled 'error' event
    } else {
      // At least give some kind of context to the user
      var err = new Error('Unhandled "error" event. (' + er + ')');
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  var isFn = typeof handler === 'function';
  len = arguments.length;
  switch (len) {
      // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
      // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i < len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');

  events = target._events;
  if (!events) {
    events = target._events = objectCreate(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener) {
      target.emit('newListener', type,
          listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (!existing) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
          prepend ? [listener, existing] : [existing, listener];
    } else {
      // If we've already got an array, just append.
      if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
    }

    // Check for listener leak
    if (!existing.warned) {
      m = $getMaxListeners(target);
      if (m && m > 0 && existing.length > m) {
        existing.warned = true;
        var w = new Error('Possible EventEmitter memory leak detected. ' +
            existing.length + ' "' + String(type) + '" listeners ' +
            'added. Use emitter.setMaxListeners() to ' +
            'increase limit.');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        if (typeof console === 'object' && console.warn) {
          console.warn('%s: %s', w.name, w.message);
        }
      }
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    switch (arguments.length) {
      case 0:
        return this.listener.call(this.target);
      case 1:
        return this.listener.call(this.target, arguments[0]);
      case 2:
        return this.listener.call(this.target, arguments[0], arguments[1]);
      case 3:
        return this.listener.call(this.target, arguments[0], arguments[1],
            arguments[2]);
      default:
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i)
          args[i] = arguments[i];
        this.listener.apply(this.target, args);
    }
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = bind.call(onceWrapper, state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function')
    throw new TypeError('"listener" argument must be a function');
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function')
        throw new TypeError('"listener" argument must be a function');

      events = this._events;
      if (!events)
        return this;

      list = events[type];
      if (!list)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = objectCreate(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else
          spliceOne(list, position);

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (!events)
        return this;

      // not listening for removeListener, no need to emit
      if (!events.removeListener) {
        if (arguments.length === 0) {
          this._events = objectCreate(null);
          this._eventsCount = 0;
        } else if (events[type]) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = objectKeys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = objectCreate(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (!events)
    return [];

  var evlistener = events[type];
  if (!evlistener)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
};

// About 1.5x faster than the two-arg version of Array#splice().
function spliceOne(list, index) {
  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
    list[i] = list[k];
  list.pop();
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function objectCreatePolyfill(proto) {
  var F = function() {};
  F.prototype = proto;
  return new F;
}
function objectKeysPolyfill(obj) {
  var keys = [];
  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
    keys.push(k);
  }
  return k;
}
function functionBindPolyfill(context) {
  var fn = this;
  return function () {
    return fn.apply(context, arguments);
  };
}

},{}],110:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":106,"buffer":110,"ieee754":119}],111:[function(require,module,exports){
(function (Buffer){
var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this,require("buffer").Buffer)

},{"buffer":110}],112:[function(require,module,exports){
var __root__ = (function (root) {
function F() { this.fetch = false; }
F.prototype = root;
return new F();
})(typeof self !== 'undefined' ? self : this);
(function(self) {

(function(self) {

  if (self.fetch) {
    return
  }

  var support = {
    searchParams: 'URLSearchParams' in self,
    iterable: 'Symbol' in self && 'iterator' in Symbol,
    blob: 'FileReader' in self && 'Blob' in self && (function() {
      try {
        new Blob();
        return true
      } catch(e) {
        return false
      }
    })(),
    formData: 'FormData' in self,
    arrayBuffer: 'ArrayBuffer' in self
  };

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isDataView = function(obj) {
      return obj && DataView.prototype.isPrototypeOf(obj)
    };

    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
      throw new TypeError('Invalid character in header field name')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue+','+value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) { items.push(name); });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) { items.push(value); });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) { items.push([name, value]); });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        throw new Error('unsupported BodyInit type')
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return (methods.indexOf(upcased) > -1) ? upcased : method
  }

  function Request(input, options) {
    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'omit';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);
  }

  Request.prototype.clone = function() {
    return new Request(this, { body: this._bodyInit })
  };

  function decode(body) {
    var form = new FormData();
    body.trim().split('&').forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
      var parts = line.split(':');
      var key = parts.shift().trim();
      if (key) {
        var value = parts.join(':').trim();
        headers.append(key, value);
      }
    });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = 'statusText' in options ? options.statusText : 'OK';
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;

  self.fetch = function(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);
      var xhr = new XMLHttpRequest();

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        resolve(new Response(body, options));
      };

      xhr.onerror = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.ontimeout = function() {
        reject(new TypeError('Network request failed'));
      };

      xhr.open(request.method, request.url, true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr && support.blob) {
        xhr.responseType = 'blob';
      }

      request.headers.forEach(function(value, name) {
        xhr.setRequestHeader(name, value);
      });

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  };
  self.fetch.polyfill = true;
})(typeof self !== 'undefined' ? self : this);
}).call(__root__, void(0));
var fetch = __root__.fetch;
var Response = fetch.Response = __root__.Response;
var Request = fetch.Request = __root__.Request;
var Headers = fetch.Headers = __root__.Headers;
if (typeof module === 'object' && module.exports) {
module.exports = fetch;
// Needed for TypeScript consumers without esModuleInterop.
module.exports.default = fetch;
}

},{}],113:[function(require,module,exports){
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

},{}],114:[function(require,module,exports){
const EthQuery = require('eth-query')
const pify = require('pify')
const SafeEventEmitter = require('safe-event-emitter')

const sec = 1000

const calculateSum = (accumulator, currentValue) => accumulator + currentValue
const blockTrackerEvents = ['sync', 'latest']

class BaseBlockTracker extends SafeEventEmitter {

  //
  // public
  //

  constructor (opts = {}) {
    super()
    // config
    this._blockResetDuration = opts.blockResetDuration || 20 * sec
    // state
    this._blockResetTimeout
    this._currentBlock = null
    this._isRunning = false
    // bind functions for internal use
    this._onNewListener = this._onNewListener.bind(this)
    this._onRemoveListener = this._onRemoveListener.bind(this)
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this)
    // listen for handler changes
    this._setupInternalEvents()
  }

  isRunning () {
    return this._isRunning
  }

  getCurrentBlock () {
    return this._currentBlock
  }

  async getLatestBlock () {
    // return if available
    if (this._currentBlock) return this._currentBlock
    // wait for a new latest block
    const latestBlock = await new Promise(resolve => this.once('latest', resolve))
    // return newly set current block
    return latestBlock
  }

  // dont allow module consumer to remove our internal event listeners
  removeAllListeners (eventName) {
    // perform default behavior, preserve fn arity
    if (eventName) {
      super.removeAllListeners(eventName)
    } else {
      super.removeAllListeners()
    }
    // re-add internal events
    this._setupInternalEvents()
    // trigger stop check just in case
    this._onRemoveListener()
  }

  //
  // to be implemented in subclass
  //

  _start () {
    // default behavior is noop
  }

  _end () {
    // default behavior is noop
  }

  //
  // private
  //

  _setupInternalEvents () {
    // first remove listeners for idempotence
    this.removeListener('newListener', this._onNewListener)
    this.removeListener('removeListener', this._onRemoveListener)
    // then add them
    this.on('newListener', this._onNewListener)
    this.on('removeListener', this._onRemoveListener)
  }

  _onNewListener (eventName, handler) {
    // `newListener` is called *before* the listener is added
    if (!blockTrackerEvents.includes(eventName)) return
    this._maybeStart()
  }

  _onRemoveListener (eventName, handler) {
    // `removeListener` is called *after* the listener is removed
    if (this._getBlockTrackerEventCount() > 0) return
    this._maybeEnd()
  }

  _maybeStart () {
    if (this._isRunning) return
    this._isRunning = true
    // cancel setting latest block to stale
    this._cancelBlockResetTimeout()
    this._start()
  }

  _maybeEnd () {
    if (!this._isRunning) return
    this._isRunning = false
    this._setupBlockResetTimeout()
    this._end()
  }

  _getBlockTrackerEventCount () {
    return blockTrackerEvents
      .map(eventName => this.listenerCount(eventName))
      .reduce(calculateSum)
  }

  _newPotentialLatest (newBlock) {
    const currentBlock = this._currentBlock
    // only update if blok number is higher
    if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) return
    this._setCurrentBlock(newBlock)
  }

  _setCurrentBlock (newBlock) {
    const oldBlock = this._currentBlock
    this._currentBlock = newBlock
    this.emit('latest', newBlock)
    this.emit('sync', { oldBlock, newBlock })
  }

  _setupBlockResetTimeout () {
    // clear any existing timeout
    this._cancelBlockResetTimeout()
    // clear latest block when stale
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration)
    // nodejs - dont hold process open
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref()
    }
  }

  _cancelBlockResetTimeout () {
    clearTimeout(this._blockResetTimeout)
  }

  _resetCurrentBlock () {
    this._currentBlock = null
  }

}

module.exports = BaseBlockTracker

function hexToInt(hexInt) {
  return Number.parseInt(hexInt, 16)
}

},{"eth-query":116,"pify":113,"safe-event-emitter":132}],115:[function(require,module,exports){
const pify = require('pify')
const BaseBlockTracker = require('./base')

const sec = 1000

class PollingBlockTracker extends BaseBlockTracker {

  constructor (opts = {}) {
    // parse + validate args
    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.')
    const pollingInterval = opts.pollingInterval || 20 * sec
    const retryTimeout = opts.retryTimeout || pollingInterval / 10
    const keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true
    const setSkipCacheFlag = opts.setSkipCacheFlag || false
    // BaseBlockTracker constructor
    super(Object.assign({
      blockResetDuration: pollingInterval,
    }, opts))
    // config
    this._provider = opts.provider
    this._pollingInterval = pollingInterval
    this._retryTimeout = retryTimeout
    this._keepEventLoopActive = keepEventLoopActive
    this._setSkipCacheFlag = setSkipCacheFlag
  }

  //
  // public
  //

  // trigger block polling
  async checkForLatestBlock () {
    await this._updateLatestBlock()
    return await this.getLatestBlock()
  }

  //
  // private
  //

  _start () {
    this._performSync().catch(err => this.emit('error', err))
  }

  async _performSync () {
    while (this._isRunning) {
      try {
        await this._updateLatestBlock()
        await timeout(this._pollingInterval, !this._keepEventLoopActive)
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`)
        try {
          this.emit('error', newErr)
        } catch (emitErr) {
          console.error(newErr)
        }
        await timeout(this._retryTimeout, !this._keepEventLoopActive)
      }
    }
  }

  async _updateLatestBlock () {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock()
    this._newPotentialLatest(latestBlock)
  }

  async _fetchLatestBlock () {
    const req = { jsonrpc: "2.0", id: 1, method: 'eth_blockNumber', params: [] }
    if (this._setSkipCacheFlag) req.skipCache = true
    const res = await pify((cb) => this._provider.sendAsync(req, cb))()
    if (res.error) throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`)
    return res.result
  }

}

module.exports = PollingBlockTracker

function timeout (duration, unref) {
  return new Promise(resolve => {
    const timoutRef = setTimeout(resolve, duration)
    // don't keep process open
    if (timoutRef.unref && unref) {
      timoutRef.unref()
    }
  })
}

},{"./base":114,"pify":113}],116:[function(require,module,exports){
const extend = require('xtend')
const createRandomId = require('json-rpc-random-id')()

module.exports = EthQuery


function EthQuery(provider){
  const self = this
  self.currentProvider = provider
}

//
// base queries
//

// default block
EthQuery.prototype.getBalance =                          generateFnWithDefaultBlockFor(2, 'eth_getBalance')
EthQuery.prototype.getCode =                             generateFnWithDefaultBlockFor(2, 'eth_getCode')
EthQuery.prototype.getTransactionCount =                 generateFnWithDefaultBlockFor(2, 'eth_getTransactionCount')
EthQuery.prototype.getStorageAt =                        generateFnWithDefaultBlockFor(3, 'eth_getStorageAt')
EthQuery.prototype.call =                                generateFnWithDefaultBlockFor(2, 'eth_call')
// standard
EthQuery.prototype.protocolVersion =                     generateFnFor('eth_protocolVersion')
EthQuery.prototype.syncing =                             generateFnFor('eth_syncing')
EthQuery.prototype.coinbase =                            generateFnFor('eth_coinbase')
EthQuery.prototype.mining =                              generateFnFor('eth_mining')
EthQuery.prototype.hashrate =                            generateFnFor('eth_hashrate')
EthQuery.prototype.gasPrice =                            generateFnFor('eth_gasPrice')
EthQuery.prototype.accounts =                            generateFnFor('eth_accounts')
EthQuery.prototype.blockNumber =                         generateFnFor('eth_blockNumber')
EthQuery.prototype.getBlockTransactionCountByHash =      generateFnFor('eth_getBlockTransactionCountByHash')
EthQuery.prototype.getBlockTransactionCountByNumber =    generateFnFor('eth_getBlockTransactionCountByNumber')
EthQuery.prototype.getUncleCountByBlockHash =            generateFnFor('eth_getUncleCountByBlockHash')
EthQuery.prototype.getUncleCountByBlockNumber =          generateFnFor('eth_getUncleCountByBlockNumber')
EthQuery.prototype.sign =                                generateFnFor('eth_sign')
EthQuery.prototype.sendTransaction =                     generateFnFor('eth_sendTransaction')
EthQuery.prototype.sendRawTransaction =                  generateFnFor('eth_sendRawTransaction')
EthQuery.prototype.estimateGas =                         generateFnFor('eth_estimateGas')
EthQuery.prototype.getBlockByHash =                      generateFnFor('eth_getBlockByHash')
EthQuery.prototype.getBlockByNumber =                    generateFnFor('eth_getBlockByNumber')
EthQuery.prototype.getTransactionByHash =                generateFnFor('eth_getTransactionByHash')
EthQuery.prototype.getTransactionByBlockHashAndIndex =   generateFnFor('eth_getTransactionByBlockHashAndIndex')
EthQuery.prototype.getTransactionByBlockNumberAndIndex = generateFnFor('eth_getTransactionByBlockNumberAndIndex')
EthQuery.prototype.getTransactionReceipt =               generateFnFor('eth_getTransactionReceipt')
EthQuery.prototype.getUncleByBlockHashAndIndex =         generateFnFor('eth_getUncleByBlockHashAndIndex')
EthQuery.prototype.getUncleByBlockNumberAndIndex =       generateFnFor('eth_getUncleByBlockNumberAndIndex')
EthQuery.prototype.getCompilers =                        generateFnFor('eth_getCompilers')
EthQuery.prototype.compileLLL =                          generateFnFor('eth_compileLLL')
EthQuery.prototype.compileSolidity =                     generateFnFor('eth_compileSolidity')
EthQuery.prototype.compileSerpent =                      generateFnFor('eth_compileSerpent')
EthQuery.prototype.newFilter =                           generateFnFor('eth_newFilter')
EthQuery.prototype.newBlockFilter =                      generateFnFor('eth_newBlockFilter')
EthQuery.prototype.newPendingTransactionFilter =         generateFnFor('eth_newPendingTransactionFilter')
EthQuery.prototype.uninstallFilter =                     generateFnFor('eth_uninstallFilter')
EthQuery.prototype.getFilterChanges =                    generateFnFor('eth_getFilterChanges')
EthQuery.prototype.getFilterLogs =                       generateFnFor('eth_getFilterLogs')
EthQuery.prototype.getLogs =                             generateFnFor('eth_getLogs')
EthQuery.prototype.getWork =                             generateFnFor('eth_getWork')
EthQuery.prototype.submitWork =                          generateFnFor('eth_submitWork')
EthQuery.prototype.submitHashrate =                      generateFnFor('eth_submitHashrate')

// network level

EthQuery.prototype.sendAsync = function(opts, cb){
  const self = this
  self.currentProvider.sendAsync(createPayload(opts), function(err, response){
    if (!err && response.error) err = new Error('EthQuery - RPC Error - '+response.error.message)
    if (err) return cb(err)
    cb(null, response.result)
  })
}

// util

function generateFnFor(methodName){
  return function(){
    const self = this
    var args = [].slice.call(arguments)
    var cb = args.pop()
    self.sendAsync({
      method: methodName,
      params: args,
    }, cb)
  }
}

function generateFnWithDefaultBlockFor(argCount, methodName){
  return function(){
    const self = this
    var args = [].slice.call(arguments)
    var cb = args.pop()
    // set optional default block param
    if (args.length < argCount) args.push('latest')
    self.sendAsync({
      method: methodName,
      params: args,
    }, cb)
  }
}

function createPayload(data){
  return extend({
    // defaults
    id: createRandomId(),
    jsonrpc: '2.0',
    params: [],
    // user-specified
  }, data)
}

},{"json-rpc-random-id":125,"xtend":143}],117:[function(require,module,exports){
(function (Buffer){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this,require("buffer").Buffer)

},{"buffer":110,"is-hex-prefixed":122,"strip-hex-prefix":134}],118:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

},{}],119:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],120:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],121:[function(require,module,exports){
'use strict';
var toString = Object.prototype.toString;

module.exports = function (x) {
	return toString.call(x) === '[object Function]';
};

},{}],122:[function(require,module,exports){
/**
 * Returns a `Boolean` on whether or not the a `String` starts with '0x'
 * @param {String} str the string input value
 * @return {Boolean} a boolean if it is or is not hex prefixed
 * @throws if the str input is not a string
 */
module.exports = function isHexPrefixed(str) {
  if (typeof str !== 'string') {
    throw new Error("[is-hex-prefixed] value must be type 'string', is currently type " + (typeof str) + ", while checking isHexPrefixed.");
  }

  return str.slice(0, 2) === '0x';
}

},{}],123:[function(require,module,exports){
module.exports = require('./lib/errors');
},{"./lib/errors":124}],124:[function(require,module,exports){
var inherits = require('inherits');

var JsonRpcError = function(message, code, data) {
  if (!(this instanceof JsonRpcError)) {
    return new JsonRpcError(message, code, data);
  }

  this.message = message;
  this.code = code;

  if (typeof data !== 'undefined') {
    this.data = data;
  }
};

inherits(JsonRpcError, Error);

var ParseError = function() {
  if (!(this instanceof ParseError)) {
    return new ParseError();
  }

  JsonRpcError.call(this, 'Parse error', -32700);
};

inherits(ParseError, JsonRpcError);

var InvalidRequest = function() {
  if (!(this instanceof InvalidRequest)) {
    return new InvalidRequest();
  }

  JsonRpcError.call(this, 'Invalid Request', -32600);
};

inherits(InvalidRequest, JsonRpcError);

var MethodNotFound = function() {
  if (!(this instanceof MethodNotFound)) {
    return new MethodNotFound();
  }

  JsonRpcError.call(this, 'Method not found', -32601);
};

inherits(MethodNotFound, JsonRpcError);

var InvalidParams = function() {
  if (!(this instanceof InvalidParams)) {
    return new InvalidParams();
  }

  JsonRpcError.call(this, 'Invalid params', -32602);
};

inherits(InvalidParams, JsonRpcError);

var InternalError = function(err) {
  var message;

  if (!(this instanceof InternalError)) {
    return new InternalError(err);
  }

  if (err && err.message) {
    message = err.message;
  } else {
    message = 'Internal error';
  }

  JsonRpcError.call(this, message, -32603);
};

inherits(InternalError, JsonRpcError);

var ServerError = function(code) {
  if (code < -32099 || code > -32000) {
    throw new Error('Invalid error code');
  }

  if (!(this instanceof ServerError)) {
    return new ServerError(code);
  }

  JsonRpcError.call(this, 'Server error', code);
};

inherits(ServerError, JsonRpcError);

JsonRpcError.ParseError = ParseError;
JsonRpcError.InvalidRequest = InvalidRequest;
JsonRpcError.MethodNotFound = MethodNotFound;
JsonRpcError.InvalidParams = InvalidParams;
JsonRpcError.InternalError = InternalError;
JsonRpcError.ServerError = ServerError;

module.exports = JsonRpcError;



},{"inherits":120}],125:[function(require,module,exports){
module.exports = IdIterator

function IdIterator(opts){
  opts = opts || {}
  var max = opts.max || Number.MAX_SAFE_INTEGER
  var idCounter = typeof opts.start !== 'undefined' ? opts.start : Math.floor(Math.random() * max)

  return function createRandomId () {
    idCounter = idCounter % max
    return idCounter++
  }

}
},{}],126:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":127}],127:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":128,"./lib/stringify":129}],128:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],129:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],130:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],131:[function(require,module,exports){
'use strict';
var isFn = require('is-fn');
var setImmediate = require('set-immediate-shim');

module.exports = function (promise) {
	if (!isFn(promise.then)) {
		throw new TypeError('Expected a promise');
	}

	return function (cb) {
		promise.then(function (data) {
			setImmediate(cb, null, data);
		}, function (err) {
			setImmediate(cb, err);
		});
	};
};

},{"is-fn":121,"set-immediate-shim":133}],132:[function(require,module,exports){
const util = require('util')
const EventEmitter = require('events/')

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
}

module.exports = SafeEventEmitter


function SafeEventEmitter() {
  EventEmitter.call(this)
}

util.inherits(SafeEventEmitter, EventEmitter)

SafeEventEmitter.prototype.emit = function (type) {
  // copied from https://github.com/Gozala/events/blob/master/events.js
  // modified lines are commented with "edited:"
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    // edited: using safeApply
    safeApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      // edited: using safeApply
      safeApply(listeners[i], this, args);
  }

  return true;
}

function safeApply(handler, context, args) {
  try {
    ReflectApply(handler, context, args)
  } catch (err) {
    // throw error after timeout so as not to interupt the stack
    setTimeout(() => {
      throw err
    })
  }
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

},{"events/":118,"util":137}],133:[function(require,module,exports){
(function (setImmediate){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this,require("timers").setImmediate)

},{"timers":135}],134:[function(require,module,exports){
var isHexPrefixed = require('is-hex-prefixed');

/**
 * Removes '0x' from a given `String` is present
 * @param {String} str the string value
 * @return {String|Optional} a string by pass if necessary
 */
module.exports = function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}

},{"is-hex-prefixed":122}],135:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":130,"timers":135}],136:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],137:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":136,"_process":130,"inherits":120}],138:[function(require,module,exports){
var v1 = require('./v1');
var v4 = require('./v4');

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;

},{"./v1":141,"./v4":142}],139:[function(require,module,exports){
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;

},{}],140:[function(require,module,exports){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

},{}],141:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;

},{"./lib/bytesToUuid":139,"./lib/rng":140}],142:[function(require,module,exports){
var rng = require('./lib/rng');
var bytesToUuid = require('./lib/bytesToUuid');

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;

},{"./lib/bytesToUuid":139,"./lib/rng":140}],143:[function(require,module,exports){
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],144:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * A token that provides access to Bitski on behalf of a user.
   */

  class AccessToken {
    constructor(token, expiresIn) {
      this.expiresAt = undefined;
      this.token = token;

      if (expiresIn) {
        this.expiresAt = Math.floor(Date.now() / 1000) + expiresIn;
      }
    }

    get expired() {
      if (this.expiresAt) {
        const now = Math.floor(Date.now() / 1000);
        const expiresIn = this.expiresAt - now;
        return expiresIn <= 0;
      }

      return false;
    }

  }

  exports.AccessToken = AccessToken;
});

},{}],145:[function(require,module,exports){
"use strict";

var __importStar = void 0 && (void 0).__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
  result["default"] = mod;
  return result;
};

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine", "./errors/provider-error", "./subproviders/nonce-tracker", "./subproviders/transaction-validator", "./subproviders/typed-data"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = __importStar(require("@bitski/provider-engine"));

  const provider_error_1 = require("./errors/provider-error");

  const nonce_tracker_1 = require("./subproviders/nonce-tracker");

  const transaction_validator_1 = require("./subproviders/transaction-validator");

  const typed_data_1 = require("./subproviders/typed-data");

  class BitskiEngine extends provider_engine_1.default {
    constructor(options) {
      super(options);
      options = options || {}; // Handles static responses

      this.addProvider(new provider_engine_1.DefaultFixtureSubprovider()); // Monitors requests to eth_getTransactionCount and eth_sendTransaction to track
      // pending transactions

      this.addProvider(new nonce_tracker_1.NonceTrackerSubprovider()); // Sanitizes transaction params, removing anything invalid

      this.addProvider(new provider_engine_1.SanitizerSubprovider());
      const enableValidator = !(options && options.disableValidation === true);

      if (enableValidator) {
        // Ensures that transactions are well formed (nonce, gas, gasPrice, from) before they are sent to Bitski
        this.addProvider(new transaction_validator_1.TransactionValidatorSubprovider(options.minGasPrice));
        this.addProvider(new typed_data_1.TypedDataSanitizerSubprovider());
      }

      const enableCache = !(options && options.disableCaching === true);

      if (enableCache) {
        // Block Cache - caches certain requests by their block number
        this.addProvider(new provider_engine_1.BlockCacheSubprovider());
      } // Handles subscriptions and filters


      const filterAndSubsSubprovider = new provider_engine_1.SubscriptionSubprovider(); // Watch for updates from subscriptions
      // @ts-ignore

      filterAndSubsSubprovider.on('data', (_, notification) => {
        this.onMessage(notification);
      });
      this.addProvider(filterAndSubsSubprovider);

      if (enableCache) {
        // Debounces duplicate requests that occur at the same time
        this.addProvider(new provider_engine_1.InflightCacheSubprovider());
      }
    }

    supportsSubscriptions() {
      return this._pollForBlocks;
    }

    subscribe() {
      let subscribeMethod = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'eth_subscribe';
      let subscriptionMethod = arguments.length > 1 ? arguments[1] : undefined;
      let parameters = arguments.length > 2 ? arguments[2] : undefined;

      if (!this._pollForBlocks) {
        return Promise.reject(provider_error_1.ProviderError.SubscriptionsUnavailable());
      }

      parameters.unshift(subscriptionMethod);
      return this.send(subscribeMethod, parameters);
    }

    unsubscribe(subscriptionId) {
      let unsubscribeMethod = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'eth_unsubscribe';

      if (!this._pollForBlocks) {
        return Promise.reject(provider_error_1.ProviderError.SubscriptionsUnavailable());
      }

      return this.send(unsubscribeMethod, [subscriptionId]).then(response => {
        if (response) {
          // @ts-ignore
          this.removeAllListeners(subscriptionId);
        }

        return response;
      });
    }

    onMessage(notification) {
      // Re-emit (previous behavior ~ web3 1.0.0-beta.37)
      // @ts-ignore
      this.emit('data', null, notification);

      if (notification && notification.params && notification.params.subscription) {
        // Current web3 behavior - emit subscription id
        // @ts-ignore
        this.emit(notification.params.subscription, notification.params);
      }
    }

  }

  exports.BitskiEngine = BitskiEngine;
});

},{"./errors/provider-error":147,"./subproviders/nonce-tracker":152,"./subproviders/transaction-validator":153,"./subproviders/typed-data":154,"@bitski/provider-engine":161}],146:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  }); // JSON-RPC methods that require Authorization header

  exports.AUTHENTICATED_METHODS = ['eth_accounts', 'eth_sendTransaction', 'eth_signTransaction', 'eth_signTypedData', 'personal_sign', 'eth_sign']; // Error messages that are usually transient and should be retried

  exports.RETRIABLE_ERRORS = [// ignore server overload errors
  'Gateway timeout', 'ETIMEDOUT', 'ENOTFOUND', // ignore server sent html error pages
  // or truncated json responses
  'SyntaxError', 'ECONNRESET', 'EHOSTUNREACH', 'Timeout out while waiting for response']; // Errors that indicate the access token is not valid

  exports.UNAUTHORIZED_ERRORS = ['Missing auth', 'Invalid client id', 'Not Authorized'];
});

},{}],147:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var ProviderErrorCode;

  (function (ProviderErrorCode) {
    // Thrown when accessing subscription features when they are disabled.
    ProviderErrorCode[ProviderErrorCode["SubscriptionsUnavailable"] = 4000] = "SubscriptionsUnavailable"; // Thrown when request is missing required params or data

    ProviderErrorCode[ProviderErrorCode["InvalidRequest"] = 4001] = "InvalidRequest";
  })(ProviderErrorCode = exports.ProviderErrorCode || (exports.ProviderErrorCode = {}));

  class ProviderError extends Error {
    constructor(message, code) {
      super(message);
      this.name = 'ProviderError'; // Maintains proper stack trace for where our error was thrown (only available on V8)
      // @ts-ignore

      if (Error.captureStackTrace) {
        // @ts-ignore
        Error.captureStackTrace(this, ProviderError);
      }

      this.code = code;
    }

    static SubscriptionsUnavailable() {
      return new ProviderError('Subscriptions are disabled. Enable block polling to use this feature.', ProviderErrorCode.SubscriptionsUnavailable);
    }

    static InvalidRequest(reason) {
      return new ProviderError("Invalid request: ".concat(reason), ProviderErrorCode.InvalidRequest);
    }

  }

  exports.ProviderError = ProviderError;
});

},{}],148:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  /**
   * Represents an error that is received from the server
   * You can access the response code via the code property, and the URI from the requestURI property.
   * The retried property will indicate whether or not the request failed after multiple tries.
   */

  class ServerError extends Error {
    constructor(message, code, requestURI) {
      let retried = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      super(message);
      this.name = 'ServerError'; // Maintains proper stack trace for where our error was thrown (only available on V8)
      // @ts-ignore

      if (Error.captureStackTrace) {
        // @ts-ignore
        Error.captureStackTrace(this, ServerError);
      }

      this.code = code;
      this.requestURI = requestURI;
      this.retried = retried;
    }

  }

  exports.ServerError = ServerError;
});

},{}],149:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "./bitski-engine", "./auth/access-token", "./subproviders/authenticated-fetch", "./network", "./errors/server-error", "./errors/provider-error"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var bitski_engine_1 = require("./bitski-engine");

  exports.BitskiEngine = bitski_engine_1.BitskiEngine;

  var access_token_1 = require("./auth/access-token");

  exports.AccessToken = access_token_1.AccessToken;

  var authenticated_fetch_1 = require("./subproviders/authenticated-fetch");

  exports.AuthenticatedFetchSubprovider = authenticated_fetch_1.AuthenticatedFetchSubprovider;

  var network_1 = require("./network");

  exports.Mainnet = network_1.Mainnet;
  exports.Rinkeby = network_1.Rinkeby;
  exports.Kovan = network_1.Kovan;

  var server_error_1 = require("./errors/server-error");

  exports.ServerError = server_error_1.ServerError;

  var provider_error_1 = require("./errors/provider-error");

  exports.ProviderError = provider_error_1.ProviderError;
  exports.ProviderErrorCode = provider_error_1.ProviderErrorCode;
});

},{"./auth/access-token":144,"./bitski-engine":145,"./errors/provider-error":147,"./errors/server-error":148,"./network":150,"./subproviders/authenticated-fetch":151}],150:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.Mainnet = {
    chainId: 1,
    rpcUrl: 'https://api.bitski.com/v1/web3/mainnet'
  };
  exports.Rinkeby = {
    chainId: 4,
    rpcUrl: 'https://api.bitski.com/v1/web3/rinkeby'
  };
  exports.Kovan = {
    chainId: 42,
    rpcUrl: 'https://api.bitski.com/v1/web3/kovan'
  };
});

},{}],151:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine", "async/retry", "../constants", "../errors/server-error"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");

  const retry_1 = __importDefault(require("async/retry"));

  const constants_1 = require("../constants");

  const server_error_1 = require("../errors/server-error");
  /*
   * Subprovider that fetches over HTTP and manages authentication headers
   */


  class AuthenticatedFetchSubprovider extends provider_engine_1.FetchSubprovider {
    constructor(rpcUrl, debug, accessTokenProvider) {
      let defaultHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      super({
        rpcUrl
      });
      this.authenticatedMethods = constants_1.AUTHENTICATED_METHODS;
      this.accessTokenProvider = accessTokenProvider;
      this.defaultHeaders = defaultHeaders;
    }

    handleRequest(payload, next, end) {
      if (this.requiresAuthentication(payload)) {
        return this.handleAuthenticatedRequest(payload, next, end);
      } else {
        return this.handleUnauthenticatedRequest(payload, next, end);
      }
    }

    handleAuthenticatedRequest(payload, next, end) {
      this.accessTokenProvider.getAccessToken().then(accessToken => {
        const parameters = this.generateParameters(payload, accessToken);
        return this.sendRequest(parameters, next, end);
      }).catch(error => {
        end(error);
      });
    }

    handleUnauthenticatedRequest(payload, next, end) {
      const parameters = this.generateParameters(payload);
      return this.sendRequest(parameters, next, end);
    }

    requiresAuthentication(payload) {
      return this.authenticatedMethods.some(method => method === payload.method);
    }

    generateParameters(payload, accessToken) {
      // overwrite id to not conflict with other concurrent users
      const newPayload = this.createPayload(payload); // remove extra parameter from request

      delete newPayload.origin;
      let headers = {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      };
      headers = Object.assign({}, headers, this.defaultHeaders);
      const originDomain = payload.origin;

      if (this.originHttpHeaderKey && originDomain) {
        headers[this.originHttpHeaderKey] = originDomain;
      }

      if (accessToken) {
        headers.Authorization = "Bearer ".concat(accessToken);
      }

      const requestParameters = {
        body: JSON.stringify(newPayload),
        headers,
        method: 'POST'
      };
      return requestParameters;
    }

    sendRequest(parameters, next, end) {
      retry_1.default({
        errorFilter: this.isErrorRetriable,
        interval: 1000,
        times: 5
      }, cb => this._submitRequest(parameters, cb), (err, result) => {
        // ends on retriable error
        if (err && this.isErrorRetriable(err)) {
          const retriesExhaustedErr = new server_error_1.ServerError(err.message, 200, this.rpcUrl, true);
          return end(retriesExhaustedErr);
        }

        if (err && this.isUnauthorizedError(err)) {
          return this.accessTokenProvider.invalidateToken().then(() => {
            return end(err);
          });
        } // otherwise continue normally


        return end(err, result);
      });
    }

    isErrorRetriable(err) {
      const errMsg = err.toString();
      return constants_1.RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase));
    }

    isUnauthorizedError(err) {
      return constants_1.UNAUTHORIZED_ERRORS.some(phrase => err.message.includes(phrase));
    }

  }

  exports.AuthenticatedFetchSubprovider = AuthenticatedFetchSubprovider;
});

},{"../constants":146,"../errors/server-error":148,"@bitski/provider-engine":161,"async/retry":214}],152:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");
  /**
   * A subprovider that tracks and automatically increments the nonce on the client.
   * Heavily based on the provider-engine NonceTrackerSubprovider, but modified for
   * Bitski's transaction flow.
   */


  class NonceTrackerSubprovider extends provider_engine_1.Subprovider {
    constructor() {
      super();
      this.nonceCache = new Map();
    }

    handleRequest(payload, next, end) {
      switch (payload.method) {
        case 'eth_getTransactionCount':
          this.handleTransactionCountRequest(payload, next, end);
          return;

        case 'eth_sendTransaction':
          this.handleSendTransactionRequest(payload, next);
          return;

        default:
          next();
          return;
      }
    } // Return cached result if present


    handleTransactionCountRequest(payload, next, end) {
      const blockTag = payload.params.length > 1 ? payload.params[1] : null; // Only handle pending tag

      if (blockTag !== 'pending') {
        next();
        return;
      }

      const address = payload.params[0].toLowerCase();
      const cachedResult = this.nonceCache.get(address); // Return cached result it we have it

      if (cachedResult) {
        end(null, cachedResult);
        return;
      } // Fallthrough and populate cache


      next((err, result, cb) => {
        if (!err) {
          this.nonceCache.set(address, result);
        }

        cb();
      });
    }

    toHex(num) {
      const base16 = num.toString(16);
      let hex = base16;

      if (base16.length % 2 !== 0) {
        hex = '0' + base16;
      }

      return '0x' + hex;
    }

    fromHex(str) {
      return parseInt(str, 16);
    }

    nextNonce(nonce) {
      const submittedNonce = this.fromHex(nonce);
      const nextNonce = submittedNonce + 1;
      return this.toHex(nextNonce);
    } // Increment next nonce for address


    handleSendTransactionRequest(payload, next) {
      // Submit the request, then monitor the result
      next((err, result, cb) => {
        const transaction = payload.params.length > 0 ? payload.params[0] : {};
        const submittedNonce = transaction.nonce;
        const address = transaction.from;

        if (!err) {
          if (submittedNonce && address) {
            // Increment nonce
            const nextNonce = this.nextNonce(submittedNonce);
            this.nonceCache.set(address, nextNonce);
          }
        } else {
          // Remove cached value if we encounter an error
          this.nonceCache.delete(address);
        }

        cb();
      });
    }

  }

  exports.NonceTrackerSubprovider = NonceTrackerSubprovider;
});

},{"@bitski/provider-engine":161}],153:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");
  /**
   * A subprovider that automatically populates missing transaction details.
   * This is needed because it has become common to submit transactions with
   * only some of the parameters and rely on the provider or node to fill in the rest.
   */


  class TransactionValidatorSubprovider extends provider_engine_1.Subprovider {
    constructor() {
      let minGasPrice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      super();
      this.minGasPrice = minGasPrice;
    }

    handleRequest(payload, next, _) {
      // Only handle transactions
      if (payload.method === 'eth_sendTransaction' || payload.method === 'eth_signTransaction') {
        this.populateTransactionFields(payload).then(() => {
          // Payload was modified. Continue.
          next();
        }).catch(() => {
          // Fall through if we cannot populate fields
          next();
        });
      } else {
        next();
      }
    } // Examine transaction and populate missing params


    async populateTransactionFields(payload) {
      const params = payload.params || [];
      let transaction = {};

      if (params.length > 0) {
        transaction = params[0];
      }

      const promises = []; // Populate missing from with default account

      if (transaction.from === undefined) {
        const accounts = await this.getAccounts();
        transaction.from = accounts[0];
      } // Populate missing gasPrice


      if (transaction.gasPrice === undefined) {
        promises.push(this.estimateGasPrice());
      } else {
        promises.push(transaction.gasPrice);
      } // Populate missing nonce


      if (transaction.nonce === undefined) {
        promises.push(this.getNonce(transaction.from));
      } else {
        promises.push(transaction.nonce);
      } // Populate missing gas


      if (transaction.gas === undefined) {
        promises.push(this.estimateGas(transaction));
      } else {
        promises.push(transaction.gas);
      } // Execute promises


      const values = await Promise.all(promises); // Update parameters with loaded values. Must be very careful with the indexes here.

      transaction.gasPrice = values[0];
      transaction.nonce = values[1];
      transaction.gas = values[2]; // Set the params on the payload

      payload.params[0] = transaction;
      return payload;
    }

    async getNonce(address) {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_getTransactionCount',
        params: [address, 'latest']
      };
      return this.performRequest(request);
    }

    async getAccounts() {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_accounts',
        params: []
      };
      return this.performRequest(request);
    }

    async estimateGas(transaction) {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_estimateGas',
        params: [transaction]
      };
      return this.performRequest(request);
    }

    async estimateGasPrice() {
      const request = {
        id: 0,
        jsonrpc: '2.0',
        method: 'eth_gasPrice',
        params: []
      };
      return this.performRequest(request).then(gasPrice => {
        if (gasPrice === '0x0') {
          return "0x".concat(this.minGasPrice.toString(16));
        }

        return gasPrice;
      });
    } // Wraps emitPayload in a promise


    performRequest(payload) {
      return new Promise((fulfill, reject) => {
        this.emitPayload(payload, (err, result) => {
          if (err) {
            reject(err);
          } else {
            fulfill(result.result);
          }
        });
      });
    }

  }

  exports.TransactionValidatorSubprovider = TransactionValidatorSubprovider;
});

},{"@bitski/provider-engine":161}],154:[function(require,module,exports){
"use strict";

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "@bitski/provider-engine", "../errors/provider-error", "../utils/parse-utils"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const provider_engine_1 = require("@bitski/provider-engine");

  const provider_error_1 = require("../errors/provider-error");

  const parse_utils_1 = require("../utils/parse-utils");

  class TypedDataSanitizerSubprovider extends provider_engine_1.Subprovider {
    handleRequest(payload, next, end) {
      if (payload.method === 'eth_signTypedData' || payload.method === 'eth_signTypedData_v3') {
        try {
          this.sanitizePayload(payload);
        } catch (err) {
          return end(err, undefined);
        }
      }

      next();
    }

    sanitizePayload(payload) {
      const typedData = this.extractTypedData(payload); // create map of types

      const typeMapping = createTypeMapping(typedData); // sanitize domain

      sanitizeDomain(typedData, typeMapping); // sanitize message

      sanitizeMessage(typedData, typeMapping); // Re-assign typed data to params in case it has been parsed
      // from a string.

      payload.params[1] = typedData;
    } // Given a JSON-RPC request, extract the typed data from the params


    extractTypedData(payload) {
      if (!payload.params || payload.params.length < 2) {
        throw provider_error_1.ProviderError.InvalidRequest('Missing params for typed data');
      } // Some implementations pass typed data as a string


      if (typeof payload.params[1] === 'string') {
        return JSON.parse(payload.params[1]);
      }

      return payload.params[1];
    }

  }

  exports.TypedDataSanitizerSubprovider = TypedDataSanitizerSubprovider;
  /**
   * Sanitizes the `domain` values from the TypedData
   *
   * @param typedData TypedData payload
   * @param typeMapping a TypeMapping pre-generated from the TypedData
   */

  function sanitizeDomain(typedData, typeMapping) {
    if (typeof typedData.domain === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing domain for typed data');
    }

    if (typeof typedData.types.EIP712Domain === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing type definition for domain');
    }

    sanitizeType('EIP712Domain', typedData.domain, typeMapping);
  }

  exports.sanitizeDomain = sanitizeDomain;
  /**
   * Sanitizes the `message` values from the TypedData
   *
   * @param typedData TypedData payload
   * @param typeMapping a TypeMapping pre-generated from the TypedData
   */

  function sanitizeMessage(typedData, typeMapping) {
    if (typeof typedData.message === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing message in typed data');
    }

    if (typeof typedData.primaryType !== 'string') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing primary type in typed data');
    }

    sanitizeType(typedData.primaryType, typedData.message, typeMapping);
  }

  exports.sanitizeMessage = sanitizeMessage;
  /**
   * Recursively examines each value and determines type from the type mapping to
   * format and sanitize the value if needed.
   *
   * Currently this will only convert number values into a consistent hex format,
   * but in the future additional transformations may be necessary.
   *
   * @param typeName Name of the type we are starting from
   * @param values The root object containing the keys and values
   * @param typeMapping The type mapping that represents this data
   */

  function sanitizeType(typeName, values, typeMapping) {
    // For each key in the 'values' object...
    Object.keys(values).forEach(key => {
      // Find the type name associated from the mapping
      const type = typeMapping[typeName][key];

      if (type === undefined) {// Do nothing if we don't have a type for this key
      } else if (isArray(type)) {
        // find the base type (left side of the brackets)
        const baseType = type.split('[')[0];

        if (typeof values[key].length === 'undefined') {
          throw new TypeError("Could not parse ".concat(values[key], " for type ").concat(type, ". Expected array."));
        } // If base type is a struct, iterate through each instance of struct


        if (typeMapping[baseType]) {
          // values[key] is expected to be an array, where each element
          // is an object that represents the struct named baseType.
          values[key].forEach(itemValues => {
            sanitizeType(baseType, itemValues, typeMapping);
          });
        } else if (baseType.startsWith('uint') || baseType.startsWith('int')) {
          // If we have an array of primitive types that are numbers, we need to encode the numbers as hex
          const numberValues = values[key].map(numberValue => {
            return parse_utils_1.encodeNumber(numberValue, baseType, true);
          });
          values[key] = numberValues;
        } else {// Do nothing with regular array values
          // int8[], etc should already be strings
        }
      } else if (typeMapping[type]) {
        // If type name is a custom struct, it should live in the type mapping
        // We need to recursively check the custom types until we get to primitive values
        sanitizeType(type, values[key], typeMapping);
      } else if (type.startsWith('uint') || type.startsWith('int')) {
        // Finally, if we have a primitive type that is a number, we need to encode the numbers as hex
        values[key] = parse_utils_1.encodeNumber(values[key], type, true);
      }
    });
  }

  exports.sanitizeType = sanitizeType;
  /**
   * Returns true if type name indicates that an array
   * @param typeName solidity type name
   */

  function isArray(typeName) {
    if (typeName.includes('[') && typeName.includes(']')) {
      return true;
    }

    return false;
  }
  /**
   * Maps the type definitions from the typed data for easy look-up.
   * Top level keys represent the structs defined, while top-level values
   * are an object keyed by property with string values of the type name.
   *
   * For example:
   * {
   *    EIP712Domain: {
   *      name: 'string',
   *      version: 'string',
   *      chainId: 'uint256'
   *    }
   * }
   * @param typedData The TypedData to map
   * @returns {TypeMapping} the mapped data schema
   */


  function createTypeMapping(typedData) {
    if (typeof typedData.types === 'undefined') {
      throw provider_error_1.ProviderError.InvalidRequest('Missing type definitions for typed data');
    } // Go through each of the top level keys. These represent the custom types.


    return Object.keys(typedData.types).reduce((acc, current) => {
      // Reduce into a new single object
      // Set a key for each type, reduce array of property names and types to an object
      acc[current] = typedData.types[current].reduce((acc2, typeDef) => {
        // For each type, set the key as the property name, and the value as the type name
        acc2[typeDef.name] = typeDef.type;
        return acc2;
      }, {});
      return acc;
    }, {});
  }

  exports.createTypeMapping = createTypeMapping;
});

},{"../errors/provider-error":147,"../utils/parse-utils":155,"@bitski/provider-engine":161}],155:[function(require,module,exports){
"use strict";

var __importDefault = void 0 && (void 0).__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

(function (factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    var v = factory(require, exports);
    if (v !== undefined) module.exports = v;
  } else if (typeof define === "function" && define.amd) {
    define(["require", "exports", "bn.js"], factory);
  }
})(function (require, exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  const bn_js_1 = __importDefault(require("bn.js"));
  /**
   * parseNumber
   * Converts a value that represents a number into a hex value.
   * @param arg {string | number | BN} A number value to convert to hex.
   * Can be a regular number, base-10 string, base-16 string, or BN instance.
   * @returns {BN} BN instance representing the number
   *
   * (Adapted from ethereumjs-abi)
   */


  function parseNumber(arg) {
    const type = typeof arg;

    if (type === 'string') {
      if (arg.substr(0, 2) === '0x') {
        return new bn_js_1.default(arg.substr(2), 16);
      } else {
        return new bn_js_1.default(arg, 10);
      }
    } else if (type === 'number') {
      return new bn_js_1.default(arg);
    } else if (arg.toArray) {
      // assume this is a BN for the moment, replace with BN.isBN soon
      return arg;
    } else {
      throw new Error('Argument is not a number');
    }
  }

  function parseBitWidth(type, offset) {
    // default to 256 bit if not specified
    let size = 256; // If type string is longer than offset, parse bits from the type string

    if (type.length > offset) {
      size = parseInt(type.substr(offset), 10);
    } // bit width must be a multiple of 8, and in the range 8-256.


    if (size % 8 || size < 8 || size > 256) {
      throw new Error("Invalid bit width ".concat(type));
    }

    return size;
  }
  /**
   * encodeNumber
   * Takes a decimal string, hex string, regular number, or BN instance and returns a hex string in the specified format.
   * Typically these conversions are done in web3, but until web3 adds direct support, this is necessary for normalizing
   * numbers eth_signTypedData payloads.
   * @param num The value to convert
   * @param type The solidity ABI type to format the data as (eg. uint256, int8, etc). Only supports int and uint variants.
   * @param compact boolean (default false). Whether to use compact encoding for uints, or pad with zeroes.
   * @returns {string} A hex string formatted as the specified type.
   */


  function encodeNumber(num, type) {
    let compact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    if (type.startsWith('uint')) {
      const size = parseBitWidth(type, 4); // start after 'uint'

      const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.

      const parsed = parseNumber(num); // uint can never be negative

      if (parsed.isNeg()) {
        throw new Error('Supplied uint is negative');
      } // Convert to hex, and prepend 0x


      if (compact) {
        return '0x' + parsed.toString(16);
      }

      return '0x' + parsed.toString(16, length);
    } else if (type.startsWith('int')) {
      // bit width must be a multiple of 8, and in the range 8-256.
      const size = parseBitWidth(type, 3);
      const length = size / 4; // length in characters for the string. hex is 1 character for 4 bits.

      const parsed = parseNumber(num); // Convert to twos complement at the bit size from the type, then convert value to hex

      return '0x' + parsed.toTwos(size).toString(16, length);
    } else {
      throw new Error('Invalid type passed');
    }
  }

  exports.encodeNumber = encodeNumber;
});

},{"bn.js":216}],156:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"./errors/provider-engine-error":159,"./util/create-payload":185,"dup":29,"events":109}],157:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],158:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],159:[function(require,module,exports){
arguments[4][32][0].apply(exports,arguments)
},{"dup":32}],160:[function(require,module,exports){
arguments[4][33][0].apply(exports,arguments)
},{"dup":33}],161:[function(require,module,exports){
arguments[4][34][0].apply(exports,arguments)
},{"./errors/block-tracker-error":157,"./errors/gas-price-error":158,"./errors/provider-engine-error":159,"./errors/subscription-error":160,"./provider-engine":162,"./subprovider":163,"./subproviders/index":178,"dup":34}],162:[function(require,module,exports){
arguments[4][35][0].apply(exports,arguments)
},{"./base-provider":156,"./errors/provider-engine-error":159,"./util/block-tracker":184,"./util/stoplight":190,"async/eachSeries":195,"dup":35}],163:[function(require,module,exports){
arguments[4][36][0].apply(exports,arguments)
},{"./util/create-payload":185,"dup":36,"events":109}],164:[function(require,module,exports){
arguments[4][37][0].apply(exports,arguments)
},{"../../util/eth-util":186,"../../util/rpc-cache-utils":188,"./cache-strategy":165,"clone":217,"dup":37}],165:[function(require,module,exports){
arguments[4][38][0].apply(exports,arguments)
},{"dup":38}],166:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"./cache-strategy":165,"./perma-cache-strategy":167,"dup":39}],167:[function(require,module,exports){
arguments[4][40][0].apply(exports,arguments)
},{"../../util/rpc-cache-utils":188,"./cache-strategy":165,"clone":217,"dup":40}],168:[function(require,module,exports){
arguments[4][41][0].apply(exports,arguments)
},{"../subprovider":163,"../util/eth-util":186,"../util/rpc-cache-utils":188,"./cache-strategies/block-strategy":164,"./cache-strategies/conditional-perma-strategy":166,"bn.js":216,"dup":41}],169:[function(require,module,exports){
arguments[4][42][0].apply(exports,arguments)
},{"./fixture":176,"dup":42,"xtend":239}],170:[function(require,module,exports){
arguments[4][43][0].apply(exports,arguments)
},{"../subprovider":163,"../util/create-payload":185,"async/asyncify":191,"async/retry":214,"async/waterfall":215,"cross-fetch":218,"dup":43,"json-rpc-error":228,"promise-to-callback":235}],171:[function(require,module,exports){
arguments[4][44][0].apply(exports,arguments)
},{"../subprovider":163,"../util/eth-util":186,"../util/stoplight":190,"./filters/block-filter":172,"./filters/log-filter":174,"./filters/pending-tx-filter":175,"async/parallel":213,"dup":44}],172:[function(require,module,exports){
arguments[4][45][0].apply(exports,arguments)
},{"./filter":173,"dup":45}],173:[function(require,module,exports){
arguments[4][46][0].apply(exports,arguments)
},{"dup":46,"events":109}],174:[function(require,module,exports){
arguments[4][47][0].apply(exports,arguments)
},{"./filter":173,"dup":47}],175:[function(require,module,exports){
arguments[4][48][0].apply(exports,arguments)
},{"./filter":173,"dup":48}],176:[function(require,module,exports){
arguments[4][49][0].apply(exports,arguments)
},{"../subprovider":163,"dup":49}],177:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"../errors/gas-price-error":158,"../subprovider":163,"async/map":212,"dup":50}],178:[function(require,module,exports){
arguments[4][51][0].apply(exports,arguments)
},{"./cache":168,"./default-fixture":169,"./fetch":170,"./filters":171,"./fixture":176,"./gasprice":177,"./inflight-cache":179,"./provider":180,"./sanitizer":181,"./subscriptions":182,"dup":51}],179:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"../subprovider":163,"../util/rpc-cache-utils":188,"clone":217,"dup":52}],180:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"../subprovider":163,"dup":53,"json-rpc-error":228}],181:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"../subprovider":163,"../util/eth-util":186,"dup":54}],182:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"../errors/subscription-error":160,"../util/eth-util":186,"../util/rpc-hex-encoding":189,"./filters":171,"dup":55}],183:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"dup":56}],184:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"../errors/block-tracker-error":157,"./create-payload":185,"./eth-util":186,"dup":57,"eth-block-tracker":221,"events":109}],185:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"./random-id":187,"dup":58,"xtend":239}],186:[function(require,module,exports){
(function (Buffer){
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bn_js_1 = __importDefault(require("bn.js"));
var ethjs_util_1 = __importDefault(require("ethjs-util"));
// Methods from ethereumjs-util
/**
 * Attempts to turn a value into a `Buffer`. As input it supports
 * `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param v the value
 */
function toBuffer(v) {
    if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
            v = Buffer.from(v);
        }
        else if (typeof v === 'string') {
            if (ethjs_util_1.default.isHexString(v)) {
                v = Buffer.from(ethjs_util_1.default.padToEven(ethjs_util_1.default.stripHexPrefix(v)), 'hex');
            }
            else {
                throw new TypeError(
                // tslint:disable-next-line: max-line-length
                "Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + v);
            }
        }
        else if (typeof v === 'number') {
            v = ethjs_util_1.default.intToBuffer(v);
        }
        else if (v === null || v === undefined) {
            v = Buffer.allocUnsafe(0);
        }
        else if (bn_js_1.default.isBN(v)) {
            v = v.toArrayLike(Buffer);
        }
        else if (v.toArray) {
            // converts a BN to a Buffer
            v = Buffer.from(v.toArray());
        }
        else {
            throw new TypeError("invalid type: " + v);
        }
    }
    return v;
}
exports.toBuffer = toBuffer;
/**
 * Adds "0x" to a given `String` if it does not already start with "0x".
 */
function addHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return ethjs_util_1.default.isHexPrefixed(str) ? str : '0x' + str;
}
exports.addHexPrefix = addHexPrefix;
function stripHexPrefix(str) {
    return ethjs_util_1.default.stripHexPrefix(str);
}
exports.stripHexPrefix = stripHexPrefix;
function intToHex(n) {
    return ethjs_util_1.default.intToHex(n);
}
exports.intToHex = intToHex;
function intToBuffer(n) {
    return ethjs_util_1.default.intToBuffer(n);
}
exports.intToBuffer = intToBuffer;
/**
 * Converts a `Buffer` into a hex `String`.
 * @param buf `Buffer` object to convert
 */
function bufferToHex(buf) {
    buf = toBuffer(buf);
    return '0x' + buf.toString('hex');
}
exports.bufferToHex = bufferToHex;
/**
 * Converts a `Buffer` to a `Number`.
 * @param buf `Buffer` object to convert
 * @throws If the input number exceeds 53 bits.
 */
function bufferToInt(buf) {
    return new bn_js_1.default(toBuffer(buf)).toNumber();
}
exports.bufferToInt = bufferToInt;
/**
 * Trims leading zeros from a `Buffer` or an `Array`.
 * @param a (Buffer|Array|String)
 * @return (Buffer|Array|String)
 */
function unpad(a) {
    a = ethjs_util_1.default.stripHexPrefix(a);
    var first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
}
exports.unpad = unpad;

}).call(this,require("buffer").Buffer)

},{"bn.js":216,"buffer":110,"ethjs-util":223}],187:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"dup":60}],188:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"dup":61,"json-stable-stringify":231}],189:[function(require,module,exports){
(function (Buffer){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("./assert");
var eth_util_1 = require("./eth-util");
/*
 * As per https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding
 * Quantities should be represented by the most compact hex representation possible
 * This means that no leading zeroes are allowed. There helpers make it easy
 * to convert to and from integers and their compact hex representation
 */
function bufferToQuantityHex(buffer) {
    buffer = eth_util_1.toBuffer(buffer);
    var hex = buffer.toString('hex');
    var trimmed = eth_util_1.unpad(hex);
    return eth_util_1.addHexPrefix(trimmed);
}
exports.bufferToQuantityHex = bufferToQuantityHex;
function intToQuantityHex(n) {
    assert_1.assert(typeof n === 'number' && n === Math.floor(n), 'intToQuantityHex arg must be an integer');
    var nHex = eth_util_1.toBuffer(n).toString('hex');
    if (nHex[0] === '0') {
        nHex = nHex.substring(1);
    }
    return eth_util_1.addHexPrefix(nHex);
}
exports.intToQuantityHex = intToQuantityHex;
function quantityHexToInt(prefixedQuantityHex) {
    assert_1.assert(typeof prefixedQuantityHex === 'string', 'arg to quantityHexToInt must be a string');
    var quantityHex = eth_util_1.stripHexPrefix(prefixedQuantityHex);
    var isEven = quantityHex.length % 2 === 0;
    if (!isEven) {
        quantityHex = '0' + quantityHex;
    }
    var buf = new Buffer(quantityHex, 'hex');
    return eth_util_1.bufferToInt(buf);
}
exports.quantityHexToInt = quantityHexToInt;

}).call(this,require("buffer").Buffer)

},{"./assert":183,"./eth-util":186,"buffer":110}],190:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"dup":63,"events":109}],191:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"./internal/initialParams":201,"./internal/setImmediate":209,"./internal/wrapAsync":211,"dup":64}],192:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"./internal/awaitify":197,"./internal/eachOfLimit":199,"./internal/withoutIndex":210,"./internal/wrapAsync":211,"dup":65}],193:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"./eachOfLimit":194,"./internal/awaitify":197,"./internal/breakLoop":198,"./internal/isArrayLike":202,"./internal/once":205,"./internal/onlyOnce":206,"./internal/wrapAsync":211,"dup":66}],194:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"./internal/awaitify":197,"./internal/eachOfLimit":199,"./internal/wrapAsync":211,"dup":67}],195:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"./eachLimit":192,"./internal/awaitify":197,"dup":68}],196:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"./breakLoop":198,"dup":69}],197:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],198:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"dup":71}],199:[function(require,module,exports){
arguments[4][72][0].apply(exports,arguments)
},{"./asyncEachOfLimit":196,"./breakLoop":198,"./iterator":203,"./once":205,"./onlyOnce":206,"./wrapAsync":211,"dup":72}],200:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],201:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"dup":74}],202:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],203:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"./getIterator":200,"./isArrayLike":202,"dup":76}],204:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./wrapAsync":211,"dup":77}],205:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"dup":78}],206:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"dup":79}],207:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"./awaitify":197,"./isArrayLike":202,"./wrapAsync":211,"dup":80}],208:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"dup":81}],209:[function(require,module,exports){
(function (process,setImmediate){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fallback = fallback;
exports.wrap = wrap;
var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
var hasNextTick = exports.hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

function fallback(fn) {
    setTimeout(fn, 0);
}

function wrap(defer) {
    return (fn, ...args) => defer(() => fn(...args));
}

var _defer;

if (hasSetImmediate) {
    _defer = setImmediate;
} else if (hasNextTick) {
    _defer = process.nextTick;
} else {
    _defer = fallback;
}

exports.default = wrap(_defer);
}).call(this,require('_process'),require("timers").setImmediate)

},{"_process":130,"timers":135}],210:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"dup":83}],211:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"../asyncify":191,"dup":84}],212:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"./eachOf":193,"./internal/awaitify":197,"./internal/map":204,"dup":85}],213:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./eachOf":193,"./internal/parallel":207,"dup":86}],214:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"./internal/promiseCallback":208,"./internal/wrapAsync":211,"dup":87}],215:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"./internal/awaitify":197,"./internal/once":205,"./internal/onlyOnce":206,"./internal/wrapAsync":211,"dup":88}],216:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"buffer":108,"dup":107}],217:[function(require,module,exports){
(function (Buffer){
var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if (typeof module === 'object' && module.exports) {
  module.exports = clone;
}

}).call(this,require("buffer").Buffer)

},{"buffer":110}],218:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"dup":112}],219:[function(require,module,exports){
arguments[4][113][0].apply(exports,arguments)
},{"dup":113}],220:[function(require,module,exports){
arguments[4][114][0].apply(exports,arguments)
},{"dup":114,"eth-query":222,"pify":219,"safe-event-emitter":236}],221:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"./base":220,"dup":115,"pify":219}],222:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"dup":116,"json-rpc-random-id":230,"xtend":239}],223:[function(require,module,exports){
(function (Buffer){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this,require("buffer").Buffer)

},{"buffer":110,"is-hex-prefixed":227,"strip-hex-prefix":238}],224:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"dup":118}],225:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],226:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"dup":121}],227:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"dup":122}],228:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./lib/errors":229,"dup":123}],229:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"dup":124,"inherits":225}],230:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"dup":125}],231:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"dup":126,"jsonify":232}],232:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"./lib/parse":233,"./lib/stringify":234,"dup":127}],233:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"dup":128}],234:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"dup":129}],235:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"dup":131,"is-fn":226,"set-immediate-shim":237}],236:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"dup":132,"events/":224,"util":137}],237:[function(require,module,exports){
(function (setImmediate){
'use strict';
module.exports = typeof setImmediate === 'function' ? setImmediate :
	function setImmediate() {
		var args = [].slice.apply(arguments);
		args.splice(1, 0, 0);
		setTimeout.apply(null, args);
	};

}).call(this,require("timers").setImmediate)

},{"timers":135}],238:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"dup":134,"is-hex-prefixed":227}],239:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"dup":143}]},{},[8])(8)
});

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJkaXN0L2VzbS9hdXRoL2FjY2Vzcy10b2tlbi5qcyIsImRpc3QvZXNtL2F1dGgvb2F1dGgtbWFuYWdlci5qcyIsImRpc3QvZXNtL2F1dGgvb3BlbmlkLWF1dGgtcHJvdmlkZXIuanMiLCJkaXN0L2VzbS9hdXRoL3BvcHVwLWhhbmRsZXIuanMiLCJkaXN0L2VzbS9hdXRoL3Rva2VuLXN0b3JlLmpzIiwiZGlzdC9lc20vYXV0aC91c2VyLXN0b3JlLmpzIiwiZGlzdC9lc20vYXV0aC91c2VyLmpzIiwiZGlzdC9lc20vYml0c2tpLmpzIiwiZGlzdC9lc20vY29tcG9uZW50cy9jb25uZWN0LWJ1dHRvbi5qcyIsImRpc3QvZXNtL2NvbXBvbmVudHMvZGlhbG9nLmpzIiwiZGlzdC9lc20vY29uc3RhbnRzLmpzIiwiZGlzdC9lc20vZXJyb3JzL2F1dGhlbnRpY2F0aW9uLWVycm9yLmpzIiwiZGlzdC9lc20vZXJyb3JzL3BhcnNlLWVycm9yLmpzIiwiZGlzdC9lc20vZXJyb3JzL3NpZ25lci1lcnJvci5qcyIsImRpc3QvZXNtL3Byb3ZpZGVycy9iaXRza2ktYnJvd3Nlci1lbmdpbmUuanMiLCJkaXN0L2VzbS9zaWduaW5nL3RyYW5zYWN0aW9uLXNpZ25lci5qcyIsImRpc3QvZXNtL3N0eWxlcy9jb25uZWN0LWJ1dHRvbi5qcyIsImRpc3QvZXNtL3N0eWxlcy9kaWFsb2cuanMiLCJkaXN0L2VzbS9zdHlsZXMvaW5kZXguanMiLCJkaXN0L2VzbS9zdWJwcm92aWRlcnMvYXV0aGVudGljYXRlZC1jYWNoZS5qcyIsImRpc3QvZXNtL3N1YnByb3ZpZGVycy9yZW1vdGUtYWNjb3VudHMuanMiLCJkaXN0L2VzbS9zdWJwcm92aWRlcnMvc2lnbmF0dXJlLmpzIiwiZGlzdC9lc20vdXRpbHMvY2FsbGJhY2suanMiLCJkaXN0L2VzbS91dGlscy9sb2NhbHN0b3JhZ2Utc3RvcmUuanMiLCJkaXN0L2VzbS91dGlscy9uby1oYXNoLXF1ZXJ5LXN0cmluZy11dGlscy5qcyIsImRpc3QvZXNtL3V0aWxzL3BvcHVwLXZhbGlkYXRvci5qcyIsImRpc3QvZXNtL3V0aWxzL3JlcXVlc3QtdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9iYXNlLXByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvZXJyb3JzL2Jsb2NrLXRyYWNrZXItZXJyb3IuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9lcnJvcnMvZ2FzLXByaWNlLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvZXJyb3JzL3Byb3ZpZGVyLWVuZ2luZS1lcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L2Vycm9ycy9zdWJzY3JpcHRpb24tZXJyb3IuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3Byb3ZpZGVyLWVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2NhY2hlLXN0cmF0ZWdpZXMvYmxvY2stc3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvY2FjaGUtc3RyYXRlZ2llcy9jYWNoZS1zdHJhdGVneS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9jYWNoZS1zdHJhdGVnaWVzL2NvbmRpdGlvbmFsLXBlcm1hLXN0cmF0ZWd5LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2NhY2hlLXN0cmF0ZWdpZXMvcGVybWEtY2FjaGUtc3RyYXRlZ3kuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvY2FjaGUuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZGVmYXVsdC1maXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2ZpbHRlcnMuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZmlsdGVycy9ibG9jay1maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZmlsdGVycy9maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZmlsdGVycy9sb2ctZmlsdGVyLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3Qvc3VicHJvdmlkZXJzL2ZpbHRlcnMvcGVuZGluZy10eC1maWx0ZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvZml4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9nYXNwcmljZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9pbmZsaWdodC1jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9wcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3N1YnByb3ZpZGVycy9zYW5pdGl6ZXIuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC9zdWJwcm92aWRlcnMvc3Vic2NyaXB0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3V0aWwvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9ibG9jay10cmFja2VyLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9jcmVhdGUtcGF5bG9hZC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3V0aWwvZXRoLXV0aWwuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvZGlzdC91dGlsL3JhbmRvbS1pZC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3V0aWwvcnBjLWNhY2hlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9ycGMtaGV4LWVuY29kaW5nLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9zdG9wbGlnaHQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2FzeW5jaWZ5LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9lYWNoTGltaXQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2VhY2hPZi5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvZWFjaE9mTGltaXQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2VhY2hTZXJpZXMuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2FzeW5jRWFjaE9mTGltaXQuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2F3YWl0aWZ5LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9icmVha0xvb3AuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2VhY2hPZkxpbWl0LmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9nZXRJdGVyYXRvci5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvaW5pdGlhbFBhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvaXNBcnJheUxpa2UuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL2l0ZXJhdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9tYXAuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL29uY2UuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL29ubHlPbmNlLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9wYXJhbGxlbC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvcHJvbWlzZUNhbGxiYWNrLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9zZXRJbW1lZGlhdGUuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL2ludGVybmFsL3dpdGhvdXRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvaW50ZXJuYWwvd3JhcEFzeW5jLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9tYXAuanMiLCJub2RlX21vZHVsZXMvQGJpdHNraS9wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2FzeW5jL3BhcmFsbGVsLmpzIiwibm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9hc3luYy9yZXRyeS5qcyIsIm5vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvYXN5bmMvd2F0ZXJmYWxsLmpzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvYXV0aG9yaXphdGlvbl9yZXF1ZXN0LnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2hhbmRsZXIudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9hdXRob3JpemF0aW9uX3Jlc3BvbnNlLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvYXV0aG9yaXphdGlvbl9zZXJ2aWNlX2NvbmZpZ3VyYXRpb24udHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9jcnlwdG9fdXRpbHMudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9lcnJvcnMudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy9mbGFncy50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL2luZGV4LnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvbG9nZ2VyLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvcXVlcnlfc3RyaW5nX3V0aWxzLnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvcmVkaXJlY3RfYmFzZWRfaGFuZGxlci50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL3Jldm9rZV90b2tlbl9yZXF1ZXN0LnRzIiwibm9kZV9tb2R1bGVzL0BvcGVuaWQvYXBwYXV0aC9zcmMvc3RvcmFnZS50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL3Rva2VuX3JlcXVlc3QudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy90b2tlbl9yZXF1ZXN0X2hhbmRsZXIudHMiLCJub2RlX21vZHVsZXMvQG9wZW5pZC9hcHBhdXRoL3NyYy90b2tlbl9yZXNwb25zZS50cyIsIm5vZGVfbW9kdWxlcy9Ab3BlbmlkL2FwcGF1dGgvc3JjL3hoci50cyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jbG9uZS9jbG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9jcm9zcy1mZXRjaC9kaXN0L2Jyb3dzZXItcG9ueWZpbGwuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvZXRoLWJsb2NrLXRyYWNrZXIvc3JjL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvZXRoLXF1ZXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V0aGpzLXV0aWwvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWZuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWhleC1wcmVmaXhlZC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtZXJyb3IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1ycGMtZXJyb3IvbGliL2Vycm9ycy5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXJwYy1yYW5kb20taWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbi1zdGFibGUtc3RyaW5naWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlLXRvLWNhbGxiYWNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtZXZlbnQtZW1pdHRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zZXQtaW1tZWRpYXRlLXNoaW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyaXAtaGV4LXByZWZpeC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIm5vZGVfbW9kdWxlcy91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dWlkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvbGliL2J5dGVzVG9VdWlkLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvbGliL3JuZy1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJub2RlX21vZHVsZXMvdXVpZC92NC5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCIuLi9wcm92aWRlci9saWIvYXV0aC9hY2Nlc3MtdG9rZW4uanMiLCIuLi9wcm92aWRlci9saWIvYml0c2tpLWVuZ2luZS5qcyIsIi4uL3Byb3ZpZGVyL2xpYi9jb25zdGFudHMuanMiLCIuLi9wcm92aWRlci9saWIvZXJyb3JzL3Byb3ZpZGVyLWVycm9yLmpzIiwiLi4vcHJvdmlkZXIvbGliL2Vycm9ycy9zZXJ2ZXItZXJyb3IuanMiLCIuLi9wcm92aWRlci9saWIvaW5kZXguanMiLCIuLi9wcm92aWRlci9saWIvbmV0d29yay5qcyIsIi4uL3Byb3ZpZGVyL2xpYi9zdWJwcm92aWRlcnMvYXV0aGVudGljYXRlZC1mZXRjaC5qcyIsIi4uL3Byb3ZpZGVyL2xpYi9zdWJwcm92aWRlcnMvbm9uY2UtdHJhY2tlci5qcyIsIi4uL3Byb3ZpZGVyL2xpYi9zdWJwcm92aWRlcnMvdHJhbnNhY3Rpb24tdmFsaWRhdG9yLmpzIiwiLi4vcHJvdmlkZXIvbGliL3N1YnByb3ZpZGVycy90eXBlZC1kYXRhLmpzIiwiLi4vcHJvdmlkZXIvbGliL3V0aWxzL3BhcnNlLXV0aWxzLmpzIiwiLi4vcHJvdmlkZXIvbm9kZV9tb2R1bGVzL0BiaXRza2kvcHJvdmlkZXItZW5naW5lL2Rpc3QvdXRpbC9ldGgtdXRpbC5qcyIsIi4uL3Byb3ZpZGVyL25vZGVfbW9kdWxlcy9AYml0c2tpL3Byb3ZpZGVyLWVuZ2luZS9kaXN0L3V0aWwvcnBjLWhleC1lbmNvZGluZy5qcyIsIi4uL3Byb3ZpZGVyL25vZGVfbW9kdWxlcy9hc3luYy9pbnRlcm5hbC9zZXRJbW1lZGlhdGUuanMiLCIuLi9wcm92aWRlci9ub2RlX21vZHVsZXMvY2xvbmUvY2xvbmUuanMiLCIuLi9wcm92aWRlci9ub2RlX21vZHVsZXMvZXRoanMtdXRpbC9saWIvaW5kZXguanMiLCIuLi9wcm92aWRlci9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIi4uL3Byb3ZpZGVyL25vZGVfbW9kdWxlcy9zZXQtaW1tZWRpYXRlLXNoaW0vaW5kZXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0FDQUE7OztBQUdPLE1BQU0sV0FBTixDQUFrQjtBQUNyQjs7Ozs7O0FBTUEsRUFBQSxXQUFXLENBQUMsS0FBRCxFQUFRLFNBQVIsRUFBbUIsS0FBbkIsRUFBMEI7QUFDakMsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxTQUFLLFNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbjJHQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2d0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuQkEsQ0FBQyxVQUFVLE9BQVYsRUFBbUI7QUFDaEIsTUFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsT0FBTyxNQUFNLENBQUMsT0FBZCxLQUEwQixRQUE1RCxFQUFzRTtBQUNsRSxRQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FBZjtBQUNBLFFBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUIsTUFBTSxDQUFDLE9BQVAsR0FBaUIsQ0FBakI7QUFDeEIsR0FIRCxNQUlLLElBQUksT0FBTyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE1BQU0sQ0FBQyxHQUEzQyxFQUFnRDtBQUNqRCxJQUFBLE1BQU0sQ0FBQyxDQUFDLFNBQUQsRUFBWSxTQUFaLENBQUQsRUFBeUIsT0FBekIsQ0FBTjtBQUNIO0FBQ0osQ0FSRCxFQVFHLFVBQVUsT0FBVixFQUFtQixPQUFuQixFQUE0QjtBQUMzQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUE3QztBQUNBOzs7O0FBR0EsUUFBTSxXQUFOLENBQWtCO0FBQ2QsSUFBQSxXQUFXLENBQUMsS0FBRCxFQUFRLFNBQVIsRUFBbUI7QUFDMUIsV0FBSyxTQUFMLEdBQWlCLFNBQWpCO0FBQ0EsV0FBSyxLQUFMLEdBQWEsS0FBYjs7QUFDQSxVQUFJLFNBQUosRUFBZTtBQUNYLGFBQUssU0FBTCxHQUFpQixJQUFJLENBQUMsS0FBTCxDQUFXLElBQUksQ0FBQyxHQUFMLEtBQWEsSUFBeEIsSUFBZ0MsU0FBakQ7QUFDSDtBQUNKOztBQUNELFFBQUksT0FBSixHQUFjO0FBQ1YsVUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFDaEIsY0FBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEtBQUwsQ0FBVyxJQUFJLENBQUMsR0FBTCxLQUFhLElBQXhCLENBQVo7QUFDQSxjQUFNLFNBQVMsR0FBRyxLQUFLLFNBQUwsR0FBaUIsR0FBbkM7QUFDQSxlQUFPLFNBQVMsSUFBSSxDQUFwQjtBQUNIOztBQUNELGFBQU8sS0FBUDtBQUNIOztBQWZhOztBQWlCbEIsRUFBQSxPQUFPLENBQUMsV0FBUixHQUFzQixXQUF0QjtBQUNILENBaENEOzs7OztBQ0FBLElBQUksWUFBWSxHQUFJLFVBQVEsU0FBSyxZQUFkLElBQStCLFVBQVUsR0FBVixFQUFlO0FBQzdELE1BQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxVQUFmLEVBQTJCLE9BQU8sR0FBUDtBQUMzQixNQUFJLE1BQU0sR0FBRyxFQUFiO0FBQ0EsTUFBSSxHQUFHLElBQUksSUFBWCxFQUFpQixLQUFLLElBQUksQ0FBVCxJQUFjLEdBQWQsRUFBbUIsSUFBSSxNQUFNLENBQUMsY0FBUCxDQUFzQixJQUF0QixDQUEyQixHQUEzQixFQUFnQyxDQUFoQyxDQUFKLEVBQXdDLE1BQU0sQ0FBQyxDQUFELENBQU4sR0FBWSxHQUFHLENBQUMsQ0FBRCxDQUFmO0FBQzVFLEVBQUEsTUFBTSxDQUFDLFNBQUQsQ0FBTixHQUFvQixHQUFwQjtBQUNBLFNBQU8sTUFBUDtBQUNILENBTkQ7O0FBT0EsQ0FBQyxVQUFVLE9BQVYsRUFBbUI7QUFDaEIsTUFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsT0FBTyxNQUFNLENBQUMsT0FBZCxLQUEwQixRQUE1RCxFQUFzRTtBQUNsRSxRQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FBZjtBQUNBLFFBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUIsTUFBTSxDQUFDLE9BQVAsR0FBaUIsQ0FBakI7QUFDeEIsR0FIRCxNQUlLLElBQUksT0FBTyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE1BQU0sQ0FBQyxHQUEzQyxFQUFnRDtBQUNqRCxJQUFBLE1BQU0sQ0FBQyxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLHlCQUF2QixFQUFrRCx5QkFBbEQsRUFBNkUsOEJBQTdFLEVBQTZHLHNDQUE3RyxFQUFxSiwyQkFBckosQ0FBRCxFQUFvTCxPQUFwTCxDQUFOO0FBQ0g7QUFDSixDQVJELEVBUUcsVUFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTRCO0FBQzNCOztBQUNBLEVBQUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRSxJQUFBLEtBQUssRUFBRTtBQUFULEdBQTdDOztBQUNBLFFBQU0saUJBQWlCLEdBQUcsWUFBWSxDQUFDLE9BQU8sQ0FBQyx5QkFBRCxDQUFSLENBQXRDOztBQUNBLFFBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLHlCQUFELENBQWhDOztBQUNBLFFBQU0sZUFBZSxHQUFHLE9BQU8sQ0FBQyw4QkFBRCxDQUEvQjs7QUFDQSxRQUFNLHVCQUF1QixHQUFHLE9BQU8sQ0FBQyxzQ0FBRCxDQUF2Qzs7QUFDQSxRQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsMkJBQUQsQ0FBNUI7O0FBQ0EsUUFBTSxZQUFOLFNBQTJCLGlCQUFpQixDQUFDLE9BQTdDLENBQXFEO0FBQ2pELElBQUEsV0FBVyxDQUFDLE9BQUQsRUFBVTtBQUNqQixZQUFNLE9BQU47QUFDQSxNQUFBLE9BQU8sR0FBRyxPQUFPLElBQUksRUFBckIsQ0FGaUIsQ0FHakI7O0FBQ0EsV0FBSyxXQUFMLENBQWlCLElBQUksaUJBQWlCLENBQUMseUJBQXRCLEVBQWpCLEVBSmlCLENBS2pCO0FBQ0E7O0FBQ0EsV0FBSyxXQUFMLENBQWlCLElBQUksZUFBZSxDQUFDLHVCQUFwQixFQUFqQixFQVBpQixDQVFqQjs7QUFDQSxXQUFLLFdBQUwsQ0FBaUIsSUFBSSxpQkFBaUIsQ0FBQyxvQkFBdEIsRUFBakI7QUFDQSxZQUFNLGVBQWUsR0FBRyxFQUFFLE9BQU8sSUFBSSxPQUFPLENBQUMsaUJBQVIsS0FBOEIsSUFBM0MsQ0FBeEI7O0FBQ0EsVUFBSSxlQUFKLEVBQXFCO0FBQ2pCO0FBQ0EsYUFBSyxXQUFMLENBQWlCLElBQUksdUJBQXVCLENBQUMsK0JBQTVCLENBQTRELE9BQU8sQ0FBQyxXQUFwRSxDQUFqQjtBQUNBLGFBQUssV0FBTCxDQUFpQixJQUFJLFlBQVksQ0FBQyw2QkFBakIsRUFBakI7QUFDSDs7QUFDRCxZQUFNLFdBQVcsR0FBRyxFQUFFLE9BQU8sSUFBSSxPQUFPLENBQUMsY0FBUixLQUEyQixJQUF4QyxDQUFwQjs7QUFDQSxVQUFJLFdBQUosRUFBaUI7QUFDYjtBQUNBLGFBQUssV0FBTCxDQUFpQixJQUFJLGlCQUFpQixDQUFDLHFCQUF0QixFQUFqQjtBQUNILE9BcEJnQixDQXFCakI7OztBQUNBLFlBQU0sd0JBQXdCLEdBQUcsSUFBSSxpQkFBaUIsQ0FBQyx1QkFBdEIsRUFBakMsQ0F0QmlCLENBdUJqQjtBQUNBOztBQUNBLE1BQUEsd0JBQXdCLENBQUMsRUFBekIsQ0FBNEIsTUFBNUIsRUFBb0MsQ0FBQyxDQUFELEVBQUksWUFBSixLQUFxQjtBQUNyRCxhQUFLLFNBQUwsQ0FBZSxZQUFmO0FBQ0gsT0FGRDtBQUdBLFdBQUssV0FBTCxDQUFpQix3QkFBakI7O0FBQ0EsVUFBSSxXQUFKLEVBQWlCO0FBQ2I7QUFDQSxhQUFLLFdBQUwsQ0FBaUIsSUFBSSxpQkFBaUIsQ0FBQyx3QkFBdEIsRUFBakI7QUFDSDtBQUNKOztBQUNELElBQUEscUJBQXFCLEdBQUc7QUFDcEIsYUFBTyxLQUFLLGNBQVo7QUFDSDs7QUFDRCxJQUFBLFNBQVMsR0FBb0U7QUFBQSxVQUFuRSxlQUFtRSx1RUFBakQsZUFBaUQ7QUFBQSxVQUFoQyxrQkFBZ0M7QUFBQSxVQUFaLFVBQVk7O0FBQ3pFLFVBQUksQ0FBQyxLQUFLLGNBQVYsRUFBMEI7QUFDdEIsZUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLGdCQUFnQixDQUFDLGFBQWpCLENBQStCLHdCQUEvQixFQUFmLENBQVA7QUFDSDs7QUFDRCxNQUFBLFVBQVUsQ0FBQyxPQUFYLENBQW1CLGtCQUFuQjtBQUNBLGFBQU8sS0FBSyxJQUFMLENBQVUsZUFBVixFQUEyQixVQUEzQixDQUFQO0FBQ0g7O0FBQ0QsSUFBQSxXQUFXLENBQUMsY0FBRCxFQUF3RDtBQUFBLFVBQXZDLGlCQUF1Qyx1RUFBbkIsaUJBQW1COztBQUMvRCxVQUFJLENBQUMsS0FBSyxjQUFWLEVBQTBCO0FBQ3RCLGVBQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxnQkFBZ0IsQ0FBQyxhQUFqQixDQUErQix3QkFBL0IsRUFBZixDQUFQO0FBQ0g7O0FBQ0QsYUFBTyxLQUFLLElBQUwsQ0FBVSxpQkFBVixFQUE2QixDQUFDLGNBQUQsQ0FBN0IsRUFBK0MsSUFBL0MsQ0FBcUQsUUFBRCxJQUFjO0FBQ3JFLFlBQUksUUFBSixFQUFjO0FBQ1Y7QUFDQSxlQUFLLGtCQUFMLENBQXdCLGNBQXhCO0FBQ0g7O0FBQ0QsZUFBTyxRQUFQO0FBQ0gsT0FOTSxDQUFQO0FBT0g7O0FBQ0QsSUFBQSxTQUFTLENBQUMsWUFBRCxFQUFlO0FBQ3BCO0FBQ0E7QUFDQSxXQUFLLElBQUwsQ0FBVSxNQUFWLEVBQWtCLElBQWxCLEVBQXdCLFlBQXhCOztBQUNBLFVBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxNQUE3QixJQUF1QyxZQUFZLENBQUMsTUFBYixDQUFvQixZQUEvRCxFQUE2RTtBQUN6RTtBQUNBO0FBQ0EsYUFBSyxJQUFMLENBQVUsWUFBWSxDQUFDLE1BQWIsQ0FBb0IsWUFBOUIsRUFBNEMsWUFBWSxDQUFDLE1BQXpEO0FBQ0g7QUFDSjs7QUFsRWdEOztBQW9FckQsRUFBQSxPQUFPLENBQUMsWUFBUixHQUF1QixZQUF2QjtBQUNILENBckZEOzs7OztBQ1BBLENBQUMsVUFBVSxPQUFWLEVBQW1CO0FBQ2hCLE1BQUksT0FBTyxNQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU8sTUFBTSxDQUFDLE9BQWQsS0FBMEIsUUFBNUQsRUFBc0U7QUFDbEUsUUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQUQsRUFBVSxPQUFWLENBQWY7QUFDQSxRQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLENBQWpCO0FBQ3hCLEdBSEQsTUFJSyxJQUFJLE9BQU8sTUFBUCxLQUFrQixVQUFsQixJQUFnQyxNQUFNLENBQUMsR0FBM0MsRUFBZ0Q7QUFDakQsSUFBQSxNQUFNLENBQUMsQ0FBQyxTQUFELEVBQVksU0FBWixDQUFELEVBQXlCLE9BQXpCLENBQU47QUFDSDtBQUNKLENBUkQsRUFRRyxVQUFVLE9BQVYsRUFBbUIsT0FBbkIsRUFBNEI7QUFDM0I7O0FBQ0EsRUFBQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLElBQUEsS0FBSyxFQUFFO0FBQVQsR0FBN0MsRUFGMkIsQ0FHM0I7O0FBQ0EsRUFBQSxPQUFPLENBQUMscUJBQVIsR0FBZ0MsQ0FDNUIsY0FENEIsRUFFNUIscUJBRjRCLEVBRzVCLHFCQUg0QixFQUk1QixtQkFKNEIsRUFLNUIsZUFMNEIsRUFNNUIsVUFONEIsQ0FBaEMsQ0FKMkIsQ0FZM0I7O0FBQ0EsRUFBQSxPQUFPLENBQUMsZ0JBQVIsR0FBMkIsQ0FDdkI7QUFDQSxtQkFGdUIsRUFHdkIsV0FIdUIsRUFJdkIsV0FKdUIsRUFLdkI7QUFDQTtBQUNBLGVBUHVCLEVBUXZCLFlBUnVCLEVBU3ZCLGNBVHVCLEVBVXZCLHdDQVZ1QixDQUEzQixDQWIyQixDQXlCM0I7O0FBQ0EsRUFBQSxPQUFPLENBQUMsbUJBQVIsR0FBOEIsQ0FDMUIsY0FEMEIsRUFFMUIsbUJBRjBCLEVBRzFCLGdCQUgwQixDQUE5QjtBQUtILENBdkNEOzs7OztBQ0FBLENBQUMsVUFBVSxPQUFWLEVBQW1CO0FBQ2hCLE1BQUksT0FBTyxNQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU8sTUFBTSxDQUFDLE9BQWQsS0FBMEIsUUFBNUQsRUFBc0U7QUFDbEUsUUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQUQsRUFBVSxPQUFWLENBQWY7QUFDQSxRQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLENBQWpCO0FBQ3hCLEdBSEQsTUFJSyxJQUFJLE9BQU8sTUFBUCxLQUFrQixVQUFsQixJQUFnQyxNQUFNLENBQUMsR0FBM0MsRUFBZ0Q7QUFDakQsSUFBQSxNQUFNLENBQUMsQ0FBQyxTQUFELEVBQVksU0FBWixDQUFELEVBQXlCLE9BQXpCLENBQU47QUFDSDtBQUNKLENBUkQsRUFRRyxVQUFVLE9BQVYsRUFBbUIsT0FBbkIsRUFBNEI7QUFDM0I7O0FBQ0EsRUFBQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztBQUFFLElBQUEsS0FBSyxFQUFFO0FBQVQsR0FBN0M7QUFDQSxNQUFJLGlCQUFKOztBQUNBLEdBQUMsVUFBVSxpQkFBVixFQUE2QjtBQUMxQjtBQUNBLElBQUEsaUJBQWlCLENBQUMsaUJBQWlCLENBQUMsMEJBQUQsQ0FBakIsR0FBZ0QsSUFBakQsQ0FBakIsR0FBMEUsMEJBQTFFLENBRjBCLENBRzFCOztBQUNBLElBQUEsaUJBQWlCLENBQUMsaUJBQWlCLENBQUMsZ0JBQUQsQ0FBakIsR0FBc0MsSUFBdkMsQ0FBakIsR0FBZ0UsZ0JBQWhFO0FBQ0gsR0FMRCxFQUtHLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyxpQkFBUixLQUE4QixPQUFPLENBQUMsaUJBQVIsR0FBNEIsRUFBMUQsQ0FMdkI7O0FBTUEsUUFBTSxhQUFOLFNBQTRCLEtBQTVCLENBQWtDO0FBQzlCLElBQUEsV0FBVyxDQUFDLE9BQUQsRUFBVSxJQUFWLEVBQWdCO0FBQ3ZCLFlBQU0sT0FBTjtBQUNBLFdBQUssSUFBTCxHQUFZLGVBQVosQ0FGdUIsQ0FHdkI7QUFDQTs7QUFDQSxVQUFJLEtBQUssQ0FBQyxpQkFBVixFQUE2QjtBQUN6QjtBQUNBLFFBQUEsS0FBSyxDQUFDLGlCQUFOLENBQXdCLElBQXhCLEVBQThCLGFBQTlCO0FBQ0g7O0FBQ0QsV0FBSyxJQUFMLEdBQVksSUFBWjtBQUNIOztBQUNELFdBQU8sd0JBQVAsR0FBa0M7QUFDOUIsYUFBTyxJQUFJLGFBQUosQ0FBa0IsdUVBQWxCLEVBQTJGLGlCQUFpQixDQUFDLHdCQUE3RyxDQUFQO0FBQ0g7O0FBQ0QsV0FBTyxjQUFQLENBQXNCLE1BQXRCLEVBQThCO0FBQzFCLGFBQU8sSUFBSSxhQUFKLDRCQUFzQyxNQUF0QyxHQUFnRCxpQkFBaUIsQ0FBQyxjQUFsRSxDQUFQO0FBQ0g7O0FBakI2Qjs7QUFtQmxDLEVBQUEsT0FBTyxDQUFDLGFBQVIsR0FBd0IsYUFBeEI7QUFDSCxDQXRDRDs7Ozs7QUNBQSxDQUFDLFVBQVUsT0FBVixFQUFtQjtBQUNoQixNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFFBQTVELEVBQXNFO0FBQ2xFLFFBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFmO0FBQ0EsUUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQixNQUFNLENBQUMsT0FBUCxHQUFpQixDQUFqQjtBQUN4QixHQUhELE1BSUssSUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsTUFBTSxDQUFDLEdBQTNDLEVBQWdEO0FBQ2pELElBQUEsTUFBTSxDQUFDLENBQUMsU0FBRCxFQUFZLFNBQVosQ0FBRCxFQUF5QixPQUF6QixDQUFOO0FBQ0g7QUFDSixDQVJELEVBUUcsVUFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTRCO0FBQzNCOztBQUNBLEVBQUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRSxJQUFBLEtBQUssRUFBRTtBQUFULEdBQTdDO0FBQ0E7Ozs7OztBQUtBLFFBQU0sV0FBTixTQUEwQixLQUExQixDQUFnQztBQUM1QixJQUFBLFdBQVcsQ0FBQyxPQUFELEVBQVUsSUFBVixFQUFnQixVQUFoQixFQUE2QztBQUFBLFVBQWpCLE9BQWlCLHVFQUFQLEtBQU87QUFDcEQsWUFBTSxPQUFOO0FBQ0EsV0FBSyxJQUFMLEdBQVksYUFBWixDQUZvRCxDQUdwRDtBQUNBOztBQUNBLFVBQUksS0FBSyxDQUFDLGlCQUFWLEVBQTZCO0FBQ3pCO0FBQ0EsUUFBQSxLQUFLLENBQUMsaUJBQU4sQ0FBd0IsSUFBeEIsRUFBOEIsV0FBOUI7QUFDSDs7QUFDRCxXQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsV0FBSyxPQUFMLEdBQWUsT0FBZjtBQUNIOztBQWIyQjs7QUFlaEMsRUFBQSxPQUFPLENBQUMsV0FBUixHQUFzQixXQUF0QjtBQUNILENBaENEOzs7OztBQ0FBLENBQUMsVUFBVSxPQUFWLEVBQW1CO0FBQ2hCLE1BQUksT0FBTyxNQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU8sTUFBTSxDQUFDLE9BQWQsS0FBMEIsUUFBNUQsRUFBc0U7QUFDbEUsUUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQUQsRUFBVSxPQUFWLENBQWY7QUFDQSxRQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLENBQWpCO0FBQ3hCLEdBSEQsTUFJSyxJQUFJLE9BQU8sTUFBUCxLQUFrQixVQUFsQixJQUFnQyxNQUFNLENBQUMsR0FBM0MsRUFBZ0Q7QUFDakQsSUFBQSxNQUFNLENBQUMsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1QixpQkFBdkIsRUFBMEMscUJBQTFDLEVBQWlFLG9DQUFqRSxFQUF1RyxXQUF2RyxFQUFvSCx1QkFBcEgsRUFBNkkseUJBQTdJLENBQUQsRUFBMEssT0FBMUssQ0FBTjtBQUNIO0FBQ0osQ0FSRCxFQVFHLFVBQVUsT0FBVixFQUFtQixPQUFuQixFQUE0QjtBQUMzQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUE3Qzs7QUFDQSxNQUFJLGVBQWUsR0FBRyxPQUFPLENBQUMsaUJBQUQsQ0FBN0I7O0FBQ0EsRUFBQSxPQUFPLENBQUMsWUFBUixHQUF1QixlQUFlLENBQUMsWUFBdkM7O0FBQ0EsTUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLHFCQUFELENBQTVCOztBQUNBLEVBQUEsT0FBTyxDQUFDLFdBQVIsR0FBc0IsY0FBYyxDQUFDLFdBQXJDOztBQUNBLE1BQUkscUJBQXFCLEdBQUcsT0FBTyxDQUFDLG9DQUFELENBQW5DOztBQUNBLEVBQUEsT0FBTyxDQUFDLDZCQUFSLEdBQXdDLHFCQUFxQixDQUFDLDZCQUE5RDs7QUFDQSxNQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsV0FBRCxDQUF2Qjs7QUFDQSxFQUFBLE9BQU8sQ0FBQyxPQUFSLEdBQWtCLFNBQVMsQ0FBQyxPQUE1QjtBQUNBLEVBQUEsT0FBTyxDQUFDLE9BQVIsR0FBa0IsU0FBUyxDQUFDLE9BQTVCO0FBQ0EsRUFBQSxPQUFPLENBQUMsS0FBUixHQUFnQixTQUFTLENBQUMsS0FBMUI7O0FBQ0EsTUFBSSxjQUFjLEdBQUcsT0FBTyxDQUFDLHVCQUFELENBQTVCOztBQUNBLEVBQUEsT0FBTyxDQUFDLFdBQVIsR0FBc0IsY0FBYyxDQUFDLFdBQXJDOztBQUNBLE1BQUksZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLHlCQUFELENBQTlCOztBQUNBLEVBQUEsT0FBTyxDQUFDLGFBQVIsR0FBd0IsZ0JBQWdCLENBQUMsYUFBekM7QUFDQSxFQUFBLE9BQU8sQ0FBQyxpQkFBUixHQUE0QixnQkFBZ0IsQ0FBQyxpQkFBN0M7QUFDSCxDQTFCRDs7Ozs7QUNBQSxDQUFDLFVBQVUsT0FBVixFQUFtQjtBQUNoQixNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFFBQTVELEVBQXNFO0FBQ2xFLFFBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFmO0FBQ0EsUUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQixNQUFNLENBQUMsT0FBUCxHQUFpQixDQUFqQjtBQUN4QixHQUhELE1BSUssSUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsTUFBTSxDQUFDLEdBQTNDLEVBQWdEO0FBQ2pELElBQUEsTUFBTSxDQUFDLENBQUMsU0FBRCxFQUFZLFNBQVosQ0FBRCxFQUF5QixPQUF6QixDQUFOO0FBQ0g7QUFDSixDQVJELEVBUUcsVUFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTRCO0FBQzNCOztBQUNBLEVBQUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRSxJQUFBLEtBQUssRUFBRTtBQUFULEdBQTdDO0FBQ0EsRUFBQSxPQUFPLENBQUMsT0FBUixHQUFrQjtBQUNkLElBQUEsT0FBTyxFQUFFLENBREs7QUFFZCxJQUFBLE1BQU0sRUFBRTtBQUZNLEdBQWxCO0FBSUEsRUFBQSxPQUFPLENBQUMsT0FBUixHQUFrQjtBQUNkLElBQUEsT0FBTyxFQUFFLENBREs7QUFFZCxJQUFBLE1BQU0sRUFBRTtBQUZNLEdBQWxCO0FBSUEsRUFBQSxPQUFPLENBQUMsS0FBUixHQUFnQjtBQUNaLElBQUEsT0FBTyxFQUFFLEVBREc7QUFFWixJQUFBLE1BQU0sRUFBRTtBQUZJLEdBQWhCO0FBSUgsQ0F2QkQ7Ozs7O0FDQUEsSUFBSSxlQUFlLEdBQUksVUFBUSxTQUFLLGVBQWQsSUFBa0MsVUFBVSxHQUFWLEVBQWU7QUFDbkUsU0FBUSxHQUFHLElBQUksR0FBRyxDQUFDLFVBQVosR0FBMEIsR0FBMUIsR0FBZ0M7QUFBRSxlQUFXO0FBQWIsR0FBdkM7QUFDSCxDQUZEOztBQUdBLENBQUMsVUFBVSxPQUFWLEVBQW1CO0FBQ2hCLE1BQUksT0FBTyxNQUFQLEtBQWtCLFFBQWxCLElBQThCLE9BQU8sTUFBTSxDQUFDLE9BQWQsS0FBMEIsUUFBNUQsRUFBc0U7QUFDbEUsUUFBSSxDQUFDLEdBQUcsT0FBTyxDQUFDLE9BQUQsRUFBVSxPQUFWLENBQWY7QUFDQSxRQUFJLENBQUMsS0FBSyxTQUFWLEVBQXFCLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLENBQWpCO0FBQ3hCLEdBSEQsTUFJSyxJQUFJLE9BQU8sTUFBUCxLQUFrQixVQUFsQixJQUFnQyxNQUFNLENBQUMsR0FBM0MsRUFBZ0Q7QUFDakQsSUFBQSxNQUFNLENBQUMsQ0FBQyxTQUFELEVBQVksU0FBWixFQUF1Qix5QkFBdkIsRUFBa0QsYUFBbEQsRUFBaUUsY0FBakUsRUFBaUYsd0JBQWpGLENBQUQsRUFBNkcsT0FBN0csQ0FBTjtBQUNIO0FBQ0osQ0FSRCxFQVFHLFVBQVUsT0FBVixFQUFtQixPQUFuQixFQUE0QjtBQUMzQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUE3Qzs7QUFDQSxRQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyx5QkFBRCxDQUFqQzs7QUFDQSxRQUFNLE9BQU8sR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLGFBQUQsQ0FBUixDQUEvQjs7QUFDQSxRQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsY0FBRCxDQUEzQjs7QUFDQSxRQUFNLGNBQWMsR0FBRyxPQUFPLENBQUMsd0JBQUQsQ0FBOUI7QUFDQTs7Ozs7QUFHQSxRQUFNLDZCQUFOLFNBQTRDLGlCQUFpQixDQUFDLGdCQUE5RCxDQUErRTtBQUMzRSxJQUFBLFdBQVcsQ0FBQyxNQUFELEVBQVMsS0FBVCxFQUFnQixtQkFBaEIsRUFBMEQ7QUFBQSxVQUFyQixjQUFxQix1RUFBSixFQUFJO0FBQ2pFLFlBQU07QUFBRSxRQUFBO0FBQUYsT0FBTjtBQUNBLFdBQUssb0JBQUwsR0FBNEIsV0FBVyxDQUFDLHFCQUF4QztBQUNBLFdBQUssbUJBQUwsR0FBMkIsbUJBQTNCO0FBQ0EsV0FBSyxjQUFMLEdBQXNCLGNBQXRCO0FBQ0g7O0FBQ0QsSUFBQSxhQUFhLENBQUMsT0FBRCxFQUFVLElBQVYsRUFBZ0IsR0FBaEIsRUFBcUI7QUFDOUIsVUFBSSxLQUFLLHNCQUFMLENBQTRCLE9BQTVCLENBQUosRUFBMEM7QUFDdEMsZUFBTyxLQUFLLDBCQUFMLENBQWdDLE9BQWhDLEVBQXlDLElBQXpDLEVBQStDLEdBQS9DLENBQVA7QUFDSCxPQUZELE1BR0s7QUFDRCxlQUFPLEtBQUssNEJBQUwsQ0FBa0MsT0FBbEMsRUFBMkMsSUFBM0MsRUFBaUQsR0FBakQsQ0FBUDtBQUNIO0FBQ0o7O0FBQ0QsSUFBQSwwQkFBMEIsQ0FBQyxPQUFELEVBQVUsSUFBVixFQUFnQixHQUFoQixFQUFxQjtBQUMzQyxXQUFLLG1CQUFMLENBQXlCLGNBQXpCLEdBQTBDLElBQTFDLENBQWdELFdBQUQsSUFBaUI7QUFDNUQsY0FBTSxVQUFVLEdBQUcsS0FBSyxrQkFBTCxDQUF3QixPQUF4QixFQUFpQyxXQUFqQyxDQUFuQjtBQUNBLGVBQU8sS0FBSyxXQUFMLENBQWlCLFVBQWpCLEVBQTZCLElBQTdCLEVBQW1DLEdBQW5DLENBQVA7QUFDSCxPQUhELEVBR0csS0FISCxDQUdVLEtBQUQsSUFBVztBQUNoQixRQUFBLEdBQUcsQ0FBQyxLQUFELENBQUg7QUFDSCxPQUxEO0FBTUg7O0FBQ0QsSUFBQSw0QkFBNEIsQ0FBQyxPQUFELEVBQVUsSUFBVixFQUFnQixHQUFoQixFQUFxQjtBQUM3QyxZQUFNLFVBQVUsR0FBRyxLQUFLLGtCQUFMLENBQXdCLE9BQXhCLENBQW5CO0FBQ0EsYUFBTyxLQUFLLFdBQUwsQ0FBaUIsVUFBakIsRUFBNkIsSUFBN0IsRUFBbUMsR0FBbkMsQ0FBUDtBQUNIOztBQUNELElBQUEsc0JBQXNCLENBQUMsT0FBRCxFQUFVO0FBQzVCLGFBQU8sS0FBSyxvQkFBTCxDQUEwQixJQUExQixDQUFnQyxNQUFELElBQVksTUFBTSxLQUFLLE9BQU8sQ0FBQyxNQUE5RCxDQUFQO0FBQ0g7O0FBQ0QsSUFBQSxrQkFBa0IsQ0FBQyxPQUFELEVBQVUsV0FBVixFQUF1QjtBQUNyQztBQUNBLFlBQU0sVUFBVSxHQUFHLEtBQUssYUFBTCxDQUFtQixPQUFuQixDQUFuQixDQUZxQyxDQUdyQzs7QUFDQSxhQUFPLFVBQVUsQ0FBQyxNQUFsQjtBQUNBLFVBQUksT0FBTyxHQUFHO0FBQ1Ysa0JBQVUsa0JBREE7QUFFVix3QkFBZ0I7QUFGTixPQUFkO0FBSUEsTUFBQSxPQUFPLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLE9BQWxCLEVBQTJCLEtBQUssY0FBaEMsQ0FBVjtBQUNBLFlBQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxNQUE3Qjs7QUFDQSxVQUFJLEtBQUssbUJBQUwsSUFBNEIsWUFBaEMsRUFBOEM7QUFDMUMsUUFBQSxPQUFPLENBQUMsS0FBSyxtQkFBTixDQUFQLEdBQW9DLFlBQXBDO0FBQ0g7O0FBQ0QsVUFBSSxXQUFKLEVBQWlCO0FBQ2IsUUFBQSxPQUFPLENBQUMsYUFBUixvQkFBa0MsV0FBbEM7QUFDSDs7QUFDRCxZQUFNLGlCQUFpQixHQUFHO0FBQ3RCLFFBQUEsSUFBSSxFQUFFLElBQUksQ0FBQyxTQUFMLENBQWUsVUFBZixDQURnQjtBQUV0QixRQUFBLE9BRnNCO0FBR3RCLFFBQUEsTUFBTSxFQUFFO0FBSGMsT0FBMUI7QUFLQSxhQUFPLGlCQUFQO0FBQ0g7O0FBQ0QsSUFBQSxXQUFXLENBQUMsVUFBRCxFQUFhLElBQWIsRUFBbUIsR0FBbkIsRUFBd0I7QUFDL0IsTUFBQSxPQUFPLENBQUMsT0FBUixDQUFnQjtBQUNaLFFBQUEsV0FBVyxFQUFFLEtBQUssZ0JBRE47QUFFWixRQUFBLFFBQVEsRUFBRSxJQUZFO0FBR1osUUFBQSxLQUFLLEVBQUU7QUFISyxPQUFoQixFQUlJLEVBQUQsSUFBUSxLQUFLLGNBQUwsQ0FBb0IsVUFBcEIsRUFBZ0MsRUFBaEMsQ0FKWCxFQUlnRCxDQUFDLEdBQUQsRUFBTSxNQUFOLEtBQWlCO0FBQzdEO0FBQ0EsWUFBSSxHQUFHLElBQUksS0FBSyxnQkFBTCxDQUFzQixHQUF0QixDQUFYLEVBQXVDO0FBQ25DLGdCQUFNLG1CQUFtQixHQUFHLElBQUksY0FBYyxDQUFDLFdBQW5CLENBQStCLEdBQUcsQ0FBQyxPQUFuQyxFQUE0QyxHQUE1QyxFQUFpRCxLQUFLLE1BQXRELEVBQThELElBQTlELENBQTVCO0FBQ0EsaUJBQU8sR0FBRyxDQUFDLG1CQUFELENBQVY7QUFDSDs7QUFDRCxZQUFJLEdBQUcsSUFBSSxLQUFLLG1CQUFMLENBQXlCLEdBQXpCLENBQVgsRUFBMEM7QUFDdEMsaUJBQU8sS0FBSyxtQkFBTCxDQUF5QixlQUF6QixHQUEyQyxJQUEzQyxDQUFnRCxNQUFNO0FBQ3pELG1CQUFPLEdBQUcsQ0FBQyxHQUFELENBQVY7QUFDSCxXQUZNLENBQVA7QUFHSCxTQVY0RCxDQVc3RDs7O0FBQ0EsZUFBTyxHQUFHLENBQUMsR0FBRCxFQUFNLE1BQU4sQ0FBVjtBQUNILE9BakJEO0FBa0JIOztBQUNELElBQUEsZ0JBQWdCLENBQUMsR0FBRCxFQUFNO0FBQ2xCLFlBQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxRQUFKLEVBQWY7QUFDQSxhQUFPLFdBQVcsQ0FBQyxnQkFBWixDQUE2QixJQUE3QixDQUFtQyxNQUFELElBQVksTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsTUFBaEIsQ0FBOUMsQ0FBUDtBQUNIOztBQUNELElBQUEsbUJBQW1CLENBQUMsR0FBRCxFQUFNO0FBQ3JCLGFBQU8sV0FBVyxDQUFDLG1CQUFaLENBQWdDLElBQWhDLENBQXNDLE1BQUQsSUFBWSxHQUFHLENBQUMsT0FBSixDQUFZLFFBQVosQ0FBcUIsTUFBckIsQ0FBakQsQ0FBUDtBQUNIOztBQWhGMEU7O0FBa0YvRSxFQUFBLE9BQU8sQ0FBQyw2QkFBUixHQUF3Qyw2QkFBeEM7QUFDSCxDQXJHRDs7Ozs7QUNIQSxDQUFDLFVBQVUsT0FBVixFQUFtQjtBQUNoQixNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFFBQTVELEVBQXNFO0FBQ2xFLFFBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFmO0FBQ0EsUUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQixNQUFNLENBQUMsT0FBUCxHQUFpQixDQUFqQjtBQUN4QixHQUhELE1BSUssSUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsTUFBTSxDQUFDLEdBQTNDLEVBQWdEO0FBQ2pELElBQUEsTUFBTSxDQUFDLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIseUJBQXZCLENBQUQsRUFBb0QsT0FBcEQsQ0FBTjtBQUNIO0FBQ0osQ0FSRCxFQVFHLFVBQVUsT0FBVixFQUFtQixPQUFuQixFQUE0QjtBQUMzQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUE3Qzs7QUFDQSxRQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyx5QkFBRCxDQUFqQztBQUNBOzs7Ozs7O0FBS0EsUUFBTSx1QkFBTixTQUFzQyxpQkFBaUIsQ0FBQyxXQUF4RCxDQUFvRTtBQUNoRSxJQUFBLFdBQVcsR0FBRztBQUNWO0FBQ0EsV0FBSyxVQUFMLEdBQWtCLElBQUksR0FBSixFQUFsQjtBQUNIOztBQUNELElBQUEsYUFBYSxDQUFDLE9BQUQsRUFBVSxJQUFWLEVBQWdCLEdBQWhCLEVBQXFCO0FBQzlCLGNBQVEsT0FBTyxDQUFDLE1BQWhCO0FBQ0ksYUFBSyx5QkFBTDtBQUNJLGVBQUssNkJBQUwsQ0FBbUMsT0FBbkMsRUFBNEMsSUFBNUMsRUFBa0QsR0FBbEQ7QUFDQTs7QUFDSixhQUFLLHFCQUFMO0FBQ0ksZUFBSyw0QkFBTCxDQUFrQyxPQUFsQyxFQUEyQyxJQUEzQztBQUNBOztBQUNKO0FBQ0ksVUFBQSxJQUFJO0FBQ0o7QUFUUjtBQVdILEtBakIrRCxDQWtCaEU7OztBQUNBLElBQUEsNkJBQTZCLENBQUMsT0FBRCxFQUFVLElBQVYsRUFBZ0IsR0FBaEIsRUFBcUI7QUFDOUMsWUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLE1BQVIsQ0FBZSxNQUFmLEdBQXdCLENBQXhCLEdBQTRCLE9BQU8sQ0FBQyxNQUFSLENBQWUsQ0FBZixDQUE1QixHQUFnRCxJQUFqRSxDQUQ4QyxDQUU5Qzs7QUFDQSxVQUFJLFFBQVEsS0FBSyxTQUFqQixFQUE0QjtBQUN4QixRQUFBLElBQUk7QUFDSjtBQUNIOztBQUNELFlBQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxNQUFSLENBQWUsQ0FBZixFQUFrQixXQUFsQixFQUFoQjtBQUNBLFlBQU0sWUFBWSxHQUFHLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixPQUFwQixDQUFyQixDQVI4QyxDQVM5Qzs7QUFDQSxVQUFJLFlBQUosRUFBa0I7QUFDZCxRQUFBLEdBQUcsQ0FBQyxJQUFELEVBQU8sWUFBUCxDQUFIO0FBQ0E7QUFDSCxPQWI2QyxDQWM5Qzs7O0FBQ0EsTUFBQSxJQUFJLENBQUMsQ0FBQyxHQUFELEVBQU0sTUFBTixFQUFjLEVBQWQsS0FBcUI7QUFDdEIsWUFBSSxDQUFDLEdBQUwsRUFBVTtBQUNOLGVBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixPQUFwQixFQUE2QixNQUE3QjtBQUNIOztBQUNELFFBQUEsRUFBRTtBQUNMLE9BTEcsQ0FBSjtBQU1IOztBQUNELElBQUEsS0FBSyxDQUFDLEdBQUQsRUFBTTtBQUNQLFlBQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxRQUFKLENBQWEsRUFBYixDQUFmO0FBQ0EsVUFBSSxHQUFHLEdBQUcsTUFBVjs7QUFDQSxVQUFJLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLENBQWhCLEtBQXNCLENBQTFCLEVBQTZCO0FBQ3pCLFFBQUEsR0FBRyxHQUFHLE1BQU0sTUFBWjtBQUNIOztBQUNELGFBQU8sT0FBTyxHQUFkO0FBQ0g7O0FBQ0QsSUFBQSxPQUFPLENBQUMsR0FBRCxFQUFNO0FBQ1QsYUFBTyxRQUFRLENBQUMsR0FBRCxFQUFNLEVBQU4sQ0FBZjtBQUNIOztBQUNELElBQUEsU0FBUyxDQUFDLEtBQUQsRUFBUTtBQUNiLFlBQU0sY0FBYyxHQUFHLEtBQUssT0FBTCxDQUFhLEtBQWIsQ0FBdkI7QUFDQSxZQUFNLFNBQVMsR0FBRyxjQUFjLEdBQUcsQ0FBbkM7QUFDQSxhQUFPLEtBQUssS0FBTCxDQUFXLFNBQVgsQ0FBUDtBQUNILEtBeEQrRCxDQXlEaEU7OztBQUNBLElBQUEsNEJBQTRCLENBQUMsT0FBRCxFQUFVLElBQVYsRUFBZ0I7QUFDeEM7QUFDQSxNQUFBLElBQUksQ0FBQyxDQUFDLEdBQUQsRUFBTSxNQUFOLEVBQWMsRUFBZCxLQUFxQjtBQUN0QixjQUFNLFdBQVcsR0FBRyxPQUFPLENBQUMsTUFBUixDQUFlLE1BQWYsR0FBd0IsQ0FBeEIsR0FBNEIsT0FBTyxDQUFDLE1BQVIsQ0FBZSxDQUFmLENBQTVCLEdBQWdELEVBQXBFO0FBQ0EsY0FBTSxjQUFjLEdBQUcsV0FBVyxDQUFDLEtBQW5DO0FBQ0EsY0FBTSxPQUFPLEdBQUcsV0FBVyxDQUFDLElBQTVCOztBQUNBLFlBQUksQ0FBQyxHQUFMLEVBQVU7QUFDTixjQUFJLGNBQWMsSUFBSSxPQUF0QixFQUErQjtBQUMzQjtBQUNBLGtCQUFNLFNBQVMsR0FBRyxLQUFLLFNBQUwsQ0FBZSxjQUFmLENBQWxCO0FBQ0EsaUJBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixPQUFwQixFQUE2QixTQUE3QjtBQUNIO0FBQ0osU0FORCxNQU9LO0FBQ0Q7QUFDQSxlQUFLLFVBQUwsQ0FBZ0IsTUFBaEIsQ0FBdUIsT0FBdkI7QUFDSDs7QUFDRCxRQUFBLEVBQUU7QUFDTCxPQWhCRyxDQUFKO0FBaUJIOztBQTdFK0Q7O0FBK0VwRSxFQUFBLE9BQU8sQ0FBQyx1QkFBUixHQUFrQyx1QkFBbEM7QUFDSCxDQWpHRDs7Ozs7QUNBQSxDQUFDLFVBQVUsT0FBVixFQUFtQjtBQUNoQixNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFFBQTVELEVBQXNFO0FBQ2xFLFFBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFmO0FBQ0EsUUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQixNQUFNLENBQUMsT0FBUCxHQUFpQixDQUFqQjtBQUN4QixHQUhELE1BSUssSUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsTUFBTSxDQUFDLEdBQTNDLEVBQWdEO0FBQ2pELElBQUEsTUFBTSxDQUFDLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIseUJBQXZCLENBQUQsRUFBb0QsT0FBcEQsQ0FBTjtBQUNIO0FBQ0osQ0FSRCxFQVFHLFVBQVUsT0FBVixFQUFtQixPQUFuQixFQUE0QjtBQUMzQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUE3Qzs7QUFDQSxRQUFNLGlCQUFpQixHQUFHLE9BQU8sQ0FBQyx5QkFBRCxDQUFqQztBQUNBOzs7Ozs7O0FBS0EsUUFBTSwrQkFBTixTQUE4QyxpQkFBaUIsQ0FBQyxXQUFoRSxDQUE0RTtBQUN4RSxJQUFBLFdBQVcsR0FBa0I7QUFBQSxVQUFqQixXQUFpQix1RUFBSCxDQUFHO0FBQ3pCO0FBQ0EsV0FBSyxXQUFMLEdBQW1CLFdBQW5CO0FBQ0g7O0FBQ0QsSUFBQSxhQUFhLENBQUMsT0FBRCxFQUFVLElBQVYsRUFBZ0IsQ0FBaEIsRUFBbUI7QUFDNUI7QUFDQSxVQUFJLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLHFCQUFuQixJQUE0QyxPQUFPLENBQUMsTUFBUixLQUFtQixxQkFBbkUsRUFBMEY7QUFDdEYsYUFBSyx5QkFBTCxDQUErQixPQUEvQixFQUF3QyxJQUF4QyxDQUE2QyxNQUFNO0FBQy9DO0FBQ0EsVUFBQSxJQUFJO0FBQ1AsU0FIRCxFQUdHLEtBSEgsQ0FHUyxNQUFNO0FBQ1g7QUFDQSxVQUFBLElBQUk7QUFDUCxTQU5EO0FBT0gsT0FSRCxNQVNLO0FBQ0QsUUFBQSxJQUFJO0FBQ1A7QUFDSixLQW5CdUUsQ0FvQnhFOzs7QUFDQSxVQUFNLHlCQUFOLENBQWdDLE9BQWhDLEVBQXlDO0FBQ3JDLFlBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxNQUFSLElBQWtCLEVBQWpDO0FBQ0EsVUFBSSxXQUFXLEdBQUcsRUFBbEI7O0FBQ0EsVUFBSSxNQUFNLENBQUMsTUFBUCxHQUFnQixDQUFwQixFQUF1QjtBQUNuQixRQUFBLFdBQVcsR0FBRyxNQUFNLENBQUMsQ0FBRCxDQUFwQjtBQUNIOztBQUNELFlBQU0sUUFBUSxHQUFHLEVBQWpCLENBTnFDLENBT3JDOztBQUNBLFVBQUksV0FBVyxDQUFDLElBQVosS0FBcUIsU0FBekIsRUFBb0M7QUFDaEMsY0FBTSxRQUFRLEdBQUcsTUFBTSxLQUFLLFdBQUwsRUFBdkI7QUFDQSxRQUFBLFdBQVcsQ0FBQyxJQUFaLEdBQW1CLFFBQVEsQ0FBQyxDQUFELENBQTNCO0FBQ0gsT0FYb0MsQ0FZckM7OztBQUNBLFVBQUksV0FBVyxDQUFDLFFBQVosS0FBeUIsU0FBN0IsRUFBd0M7QUFDcEMsUUFBQSxRQUFRLENBQUMsSUFBVCxDQUFjLEtBQUssZ0JBQUwsRUFBZDtBQUNILE9BRkQsTUFHSztBQUNELFFBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFXLENBQUMsUUFBMUI7QUFDSCxPQWxCb0MsQ0FtQnJDOzs7QUFDQSxVQUFJLFdBQVcsQ0FBQyxLQUFaLEtBQXNCLFNBQTFCLEVBQXFDO0FBQ2pDLFFBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxLQUFLLFFBQUwsQ0FBYyxXQUFXLENBQUMsSUFBMUIsQ0FBZDtBQUNILE9BRkQsTUFHSztBQUNELFFBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFXLENBQUMsS0FBMUI7QUFDSCxPQXpCb0MsQ0EwQnJDOzs7QUFDQSxVQUFJLFdBQVcsQ0FBQyxHQUFaLEtBQW9CLFNBQXhCLEVBQW1DO0FBQy9CLFFBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxLQUFLLFdBQUwsQ0FBaUIsV0FBakIsQ0FBZDtBQUNILE9BRkQsTUFHSztBQUNELFFBQUEsUUFBUSxDQUFDLElBQVQsQ0FBYyxXQUFXLENBQUMsR0FBMUI7QUFDSCxPQWhDb0MsQ0FpQ3JDOzs7QUFDQSxZQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFSLENBQVksUUFBWixDQUFyQixDQWxDcUMsQ0FtQ3JDOztBQUNBLE1BQUEsV0FBVyxDQUFDLFFBQVosR0FBdUIsTUFBTSxDQUFDLENBQUQsQ0FBN0I7QUFDQSxNQUFBLFdBQVcsQ0FBQyxLQUFaLEdBQW9CLE1BQU0sQ0FBQyxDQUFELENBQTFCO0FBQ0EsTUFBQSxXQUFXLENBQUMsR0FBWixHQUFrQixNQUFNLENBQUMsQ0FBRCxDQUF4QixDQXRDcUMsQ0F1Q3JDOztBQUNBLE1BQUEsT0FBTyxDQUFDLE1BQVIsQ0FBZSxDQUFmLElBQW9CLFdBQXBCO0FBQ0EsYUFBTyxPQUFQO0FBQ0g7O0FBQ0QsVUFBTSxRQUFOLENBQWUsT0FBZixFQUF3QjtBQUNwQixZQUFNLE9BQU8sR0FBRztBQUNaLFFBQUEsRUFBRSxFQUFFLENBRFE7QUFFWixRQUFBLE9BQU8sRUFBRSxLQUZHO0FBR1osUUFBQSxNQUFNLEVBQUUseUJBSEk7QUFJWixRQUFBLE1BQU0sRUFBRSxDQUFDLE9BQUQsRUFBVSxRQUFWO0FBSkksT0FBaEI7QUFNQSxhQUFPLEtBQUssY0FBTCxDQUFvQixPQUFwQixDQUFQO0FBQ0g7O0FBQ0QsVUFBTSxXQUFOLEdBQW9CO0FBQ2hCLFlBQU0sT0FBTyxHQUFHO0FBQ1osUUFBQSxFQUFFLEVBQUUsQ0FEUTtBQUVaLFFBQUEsT0FBTyxFQUFFLEtBRkc7QUFHWixRQUFBLE1BQU0sRUFBRSxjQUhJO0FBSVosUUFBQSxNQUFNLEVBQUU7QUFKSSxPQUFoQjtBQU1BLGFBQU8sS0FBSyxjQUFMLENBQW9CLE9BQXBCLENBQVA7QUFDSDs7QUFDRCxVQUFNLFdBQU4sQ0FBa0IsV0FBbEIsRUFBK0I7QUFDM0IsWUFBTSxPQUFPLEdBQUc7QUFDWixRQUFBLEVBQUUsRUFBRSxDQURRO0FBRVosUUFBQSxPQUFPLEVBQUUsS0FGRztBQUdaLFFBQUEsTUFBTSxFQUFFLGlCQUhJO0FBSVosUUFBQSxNQUFNLEVBQUUsQ0FBQyxXQUFEO0FBSkksT0FBaEI7QUFNQSxhQUFPLEtBQUssY0FBTCxDQUFvQixPQUFwQixDQUFQO0FBQ0g7O0FBQ0QsVUFBTSxnQkFBTixHQUF5QjtBQUNyQixZQUFNLE9BQU8sR0FBRztBQUNaLFFBQUEsRUFBRSxFQUFFLENBRFE7QUFFWixRQUFBLE9BQU8sRUFBRSxLQUZHO0FBR1osUUFBQSxNQUFNLEVBQUUsY0FISTtBQUlaLFFBQUEsTUFBTSxFQUFFO0FBSkksT0FBaEI7QUFNQSxhQUFPLEtBQUssY0FBTCxDQUFvQixPQUFwQixFQUE2QixJQUE3QixDQUFtQyxRQUFELElBQWM7QUFDbkQsWUFBSSxRQUFRLEtBQUssS0FBakIsRUFBd0I7QUFDcEIsNkJBQVksS0FBSyxXQUFMLENBQWlCLFFBQWpCLENBQTBCLEVBQTFCLENBQVo7QUFDSDs7QUFDRCxlQUFPLFFBQVA7QUFDSCxPQUxNLENBQVA7QUFNSCxLQXhHdUUsQ0F5R3hFOzs7QUFDQSxJQUFBLGNBQWMsQ0FBQyxPQUFELEVBQVU7QUFDcEIsYUFBTyxJQUFJLE9BQUosQ0FBWSxDQUFDLE9BQUQsRUFBVSxNQUFWLEtBQXFCO0FBQ3BDLGFBQUssV0FBTCxDQUFpQixPQUFqQixFQUEwQixDQUFDLEdBQUQsRUFBTSxNQUFOLEtBQWlCO0FBQ3ZDLGNBQUksR0FBSixFQUFTO0FBQ0wsWUFBQSxNQUFNLENBQUMsR0FBRCxDQUFOO0FBQ0gsV0FGRCxNQUdLO0FBQ0QsWUFBQSxPQUFPLENBQUMsTUFBTSxDQUFDLE1BQVIsQ0FBUDtBQUNIO0FBQ0osU0FQRDtBQVFILE9BVE0sQ0FBUDtBQVVIOztBQXJIdUU7O0FBdUg1RSxFQUFBLE9BQU8sQ0FBQywrQkFBUixHQUEwQywrQkFBMUM7QUFDSCxDQXpJRDs7Ozs7QUNBQSxDQUFDLFVBQVUsT0FBVixFQUFtQjtBQUNoQixNQUFJLE9BQU8sTUFBUCxLQUFrQixRQUFsQixJQUE4QixPQUFPLE1BQU0sQ0FBQyxPQUFkLEtBQTBCLFFBQTVELEVBQXNFO0FBQ2xFLFFBQUksQ0FBQyxHQUFHLE9BQU8sQ0FBQyxPQUFELEVBQVUsT0FBVixDQUFmO0FBQ0EsUUFBSSxDQUFDLEtBQUssU0FBVixFQUFxQixNQUFNLENBQUMsT0FBUCxHQUFpQixDQUFqQjtBQUN4QixHQUhELE1BSUssSUFBSSxPQUFPLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsTUFBTSxDQUFDLEdBQTNDLEVBQWdEO0FBQ2pELElBQUEsTUFBTSxDQUFDLENBQUMsU0FBRCxFQUFZLFNBQVosRUFBdUIseUJBQXZCLEVBQWtELDBCQUFsRCxFQUE4RSxzQkFBOUUsQ0FBRCxFQUF3RyxPQUF4RyxDQUFOO0FBQ0g7QUFDSixDQVJELEVBUUcsVUFBVSxPQUFWLEVBQW1CLE9BQW5CLEVBQTRCO0FBQzNCOztBQUNBLEVBQUEsTUFBTSxDQUFDLGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0IsWUFBL0IsRUFBNkM7QUFBRSxJQUFBLEtBQUssRUFBRTtBQUFULEdBQTdDOztBQUNBLFFBQU0saUJBQWlCLEdBQUcsT0FBTyxDQUFDLHlCQUFELENBQWpDOztBQUNBLFFBQU0sZ0JBQWdCLEdBQUcsT0FBTyxDQUFDLDBCQUFELENBQWhDOztBQUNBLFFBQU0sYUFBYSxHQUFHLE9BQU8sQ0FBQyxzQkFBRCxDQUE3Qjs7QUFDQSxRQUFNLDZCQUFOLFNBQTRDLGlCQUFpQixDQUFDLFdBQTlELENBQTBFO0FBQ3RFLElBQUEsYUFBYSxDQUFDLE9BQUQsRUFBVSxJQUFWLEVBQWdCLEdBQWhCLEVBQXFCO0FBQzlCLFVBQUksT0FBTyxDQUFDLE1BQVIsS0FBbUIsbUJBQW5CLElBQTBDLE9BQU8sQ0FBQyxNQUFSLEtBQW1CLHNCQUFqRSxFQUF5RjtBQUNyRixZQUFJO0FBQ0EsZUFBSyxlQUFMLENBQXFCLE9BQXJCO0FBQ0gsU0FGRCxDQUdBLE9BQU8sR0FBUCxFQUFZO0FBQ1IsaUJBQU8sR0FBRyxDQUFDLEdBQUQsRUFBTSxTQUFOLENBQVY7QUFDSDtBQUNKOztBQUNELE1BQUEsSUFBSTtBQUNQOztBQUNELElBQUEsZUFBZSxDQUFDLE9BQUQsRUFBVTtBQUNyQixZQUFNLFNBQVMsR0FBRyxLQUFLLGdCQUFMLENBQXNCLE9BQXRCLENBQWxCLENBRHFCLENBRXJCOztBQUNBLFlBQU0sV0FBVyxHQUFHLGlCQUFpQixDQUFDLFNBQUQsQ0FBckMsQ0FIcUIsQ0FJckI7O0FBQ0EsTUFBQSxjQUFjLENBQUMsU0FBRCxFQUFZLFdBQVosQ0FBZCxDQUxxQixDQU1yQjs7QUFDQSxNQUFBLGVBQWUsQ0FBQyxTQUFELEVBQVksV0FBWixDQUFmLENBUHFCLENBUXJCO0FBQ0E7O0FBQ0EsTUFBQSxPQUFPLENBQUMsTUFBUixDQUFlLENBQWYsSUFBb0IsU0FBcEI7QUFDSCxLQXZCcUUsQ0F3QnRFOzs7QUFDQSxJQUFBLGdCQUFnQixDQUFDLE9BQUQsRUFBVTtBQUN0QixVQUFJLENBQUMsT0FBTyxDQUFDLE1BQVQsSUFBbUIsT0FBTyxDQUFDLE1BQVIsQ0FBZSxNQUFmLEdBQXdCLENBQS9DLEVBQWtEO0FBQzlDLGNBQU0sZ0JBQWdCLENBQUMsYUFBakIsQ0FBK0IsY0FBL0IsQ0FBOEMsK0JBQTlDLENBQU47QUFDSCxPQUhxQixDQUl0Qjs7O0FBQ0EsVUFBSSxPQUFPLE9BQU8sQ0FBQyxNQUFSLENBQWUsQ0FBZixDQUFQLEtBQTZCLFFBQWpDLEVBQTJDO0FBQ3ZDLGVBQU8sSUFBSSxDQUFDLEtBQUwsQ0FBVyxPQUFPLENBQUMsTUFBUixDQUFlLENBQWYsQ0FBWCxDQUFQO0FBQ0g7O0FBQ0QsYUFBTyxPQUFPLENBQUMsTUFBUixDQUFlLENBQWYsQ0FBUDtBQUNIOztBQWxDcUU7O0FBb0MxRSxFQUFBLE9BQU8sQ0FBQyw2QkFBUixHQUF3Qyw2QkFBeEM7QUFDQTs7Ozs7OztBQU1BLFdBQVMsY0FBVCxDQUF3QixTQUF4QixFQUFtQyxXQUFuQyxFQUFnRDtBQUM1QyxRQUFJLE9BQU8sU0FBUyxDQUFDLE1BQWpCLEtBQTRCLFdBQWhDLEVBQTZDO0FBQ3pDLFlBQU0sZ0JBQWdCLENBQUMsYUFBakIsQ0FBK0IsY0FBL0IsQ0FBOEMsK0JBQTlDLENBQU47QUFDSDs7QUFDRCxRQUFJLE9BQU8sU0FBUyxDQUFDLEtBQVYsQ0FBZ0IsWUFBdkIsS0FBd0MsV0FBNUMsRUFBeUQ7QUFDckQsWUFBTSxnQkFBZ0IsQ0FBQyxhQUFqQixDQUErQixjQUEvQixDQUE4QyxvQ0FBOUMsQ0FBTjtBQUNIOztBQUNELElBQUEsWUFBWSxDQUFDLGNBQUQsRUFBaUIsU0FBUyxDQUFDLE1BQTNCLEVBQW1DLFdBQW5DLENBQVo7QUFDSDs7QUFDRCxFQUFBLE9BQU8sQ0FBQyxjQUFSLEdBQXlCLGNBQXpCO0FBQ0E7Ozs7Ozs7QUFNQSxXQUFTLGVBQVQsQ0FBeUIsU0FBekIsRUFBb0MsV0FBcEMsRUFBaUQ7QUFDN0MsUUFBSSxPQUFPLFNBQVMsQ0FBQyxPQUFqQixLQUE2QixXQUFqQyxFQUE4QztBQUMxQyxZQUFNLGdCQUFnQixDQUFDLGFBQWpCLENBQStCLGNBQS9CLENBQThDLCtCQUE5QyxDQUFOO0FBQ0g7O0FBQ0QsUUFBSSxPQUFPLFNBQVMsQ0FBQyxXQUFqQixLQUFpQyxRQUFyQyxFQUErQztBQUMzQyxZQUFNLGdCQUFnQixDQUFDLGFBQWpCLENBQStCLGNBQS9CLENBQThDLG9DQUE5QyxDQUFOO0FBQ0g7O0FBQ0QsSUFBQSxZQUFZLENBQUMsU0FBUyxDQUFDLFdBQVgsRUFBd0IsU0FBUyxDQUFDLE9BQWxDLEVBQTJDLFdBQTNDLENBQVo7QUFDSDs7QUFDRCxFQUFBLE9BQU8sQ0FBQyxlQUFSLEdBQTBCLGVBQTFCO0FBQ0E7Ozs7Ozs7Ozs7OztBQVdBLFdBQVMsWUFBVCxDQUFzQixRQUF0QixFQUFnQyxNQUFoQyxFQUF3QyxXQUF4QyxFQUFxRDtBQUNqRDtBQUNBLElBQUEsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFaLEVBQW9CLE9BQXBCLENBQTZCLEdBQUQsSUFBUztBQUNqQztBQUNBLFlBQU0sSUFBSSxHQUFHLFdBQVcsQ0FBQyxRQUFELENBQVgsQ0FBc0IsR0FBdEIsQ0FBYjs7QUFDQSxVQUFJLElBQUksS0FBSyxTQUFiLEVBQXdCLENBQ3BCO0FBQ0gsT0FGRCxNQUdLLElBQUksT0FBTyxDQUFDLElBQUQsQ0FBWCxFQUFtQjtBQUNwQjtBQUNBLGNBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsR0FBWCxFQUFnQixDQUFoQixDQUFqQjs7QUFDQSxZQUFJLE9BQU8sTUFBTSxDQUFDLEdBQUQsQ0FBTixDQUFZLE1BQW5CLEtBQThCLFdBQWxDLEVBQStDO0FBQzNDLGdCQUFNLElBQUksU0FBSiwyQkFBaUMsTUFBTSxDQUFDLEdBQUQsQ0FBdkMsdUJBQXlELElBQXpELHVCQUFOO0FBQ0gsU0FMbUIsQ0FNcEI7OztBQUNBLFlBQUksV0FBVyxDQUFDLFFBQUQsQ0FBZixFQUEyQjtBQUN2QjtBQUNBO0FBQ0EsVUFBQSxNQUFNLENBQUMsR0FBRCxDQUFOLENBQVksT0FBWixDQUFxQixVQUFELElBQWdCO0FBQ2hDLFlBQUEsWUFBWSxDQUFDLFFBQUQsRUFBVyxVQUFYLEVBQXVCLFdBQXZCLENBQVo7QUFDSCxXQUZEO0FBR0gsU0FORCxNQU9LLElBQUksUUFBUSxDQUFDLFVBQVQsQ0FBb0IsTUFBcEIsS0FBK0IsUUFBUSxDQUFDLFVBQVQsQ0FBb0IsS0FBcEIsQ0FBbkMsRUFBK0Q7QUFDaEU7QUFDQSxnQkFBTSxZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUQsQ0FBTixDQUFZLEdBQVosQ0FBaUIsV0FBRCxJQUFpQjtBQUNsRCxtQkFBTyxhQUFhLENBQUMsWUFBZCxDQUEyQixXQUEzQixFQUF3QyxRQUF4QyxFQUFrRCxJQUFsRCxDQUFQO0FBQ0gsV0FGb0IsQ0FBckI7QUFHQSxVQUFBLE1BQU0sQ0FBQyxHQUFELENBQU4sR0FBYyxZQUFkO0FBQ0gsU0FOSSxNQU9BLENBQ0Q7QUFDQTtBQUNIO0FBQ0osT0F6QkksTUEwQkEsSUFBSSxXQUFXLENBQUMsSUFBRCxDQUFmLEVBQXVCO0FBQ3hCO0FBQ0E7QUFDQSxRQUFBLFlBQVksQ0FBQyxJQUFELEVBQU8sTUFBTSxDQUFDLEdBQUQsQ0FBYixFQUFvQixXQUFwQixDQUFaO0FBQ0gsT0FKSSxNQUtBLElBQUksSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsTUFBaEIsS0FBMkIsSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBL0IsRUFBdUQ7QUFDeEQ7QUFDQSxRQUFBLE1BQU0sQ0FBQyxHQUFELENBQU4sR0FBYyxhQUFhLENBQUMsWUFBZCxDQUEyQixNQUFNLENBQUMsR0FBRCxDQUFqQyxFQUF3QyxJQUF4QyxFQUE4QyxJQUE5QyxDQUFkO0FBQ0g7QUFDSixLQXpDRDtBQTBDSDs7QUFDRCxFQUFBLE9BQU8sQ0FBQyxZQUFSLEdBQXVCLFlBQXZCO0FBQ0E7Ozs7O0FBSUEsV0FBUyxPQUFULENBQWlCLFFBQWpCLEVBQTJCO0FBQ3ZCLFFBQUksUUFBUSxDQUFDLFFBQVQsQ0FBa0IsR0FBbEIsS0FBMEIsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsR0FBbEIsQ0FBOUIsRUFBc0Q7QUFDbEQsYUFBTyxJQUFQO0FBQ0g7O0FBQ0QsV0FBTyxLQUFQO0FBQ0g7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBZ0JBLFdBQVMsaUJBQVQsQ0FBMkIsU0FBM0IsRUFBc0M7QUFDbEMsUUFBSSxPQUFPLFNBQVMsQ0FBQyxLQUFqQixLQUEyQixXQUEvQixFQUE0QztBQUN4QyxZQUFNLGdCQUFnQixDQUFDLGFBQWpCLENBQStCLGNBQS9CLENBQThDLHlDQUE5QyxDQUFOO0FBQ0gsS0FIaUMsQ0FJbEM7OztBQUNBLFdBQU8sTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFTLENBQUMsS0FBdEIsRUFBNkIsTUFBN0IsQ0FBb0MsQ0FBQyxHQUFELEVBQU0sT0FBTixLQUFrQjtBQUN6RDtBQUNBO0FBQ0EsTUFBQSxHQUFHLENBQUMsT0FBRCxDQUFILEdBQWUsU0FBUyxDQUFDLEtBQVYsQ0FBZ0IsT0FBaEIsRUFBeUIsTUFBekIsQ0FBZ0MsQ0FBQyxJQUFELEVBQU8sT0FBUCxLQUFtQjtBQUM5RDtBQUNBLFFBQUEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFULENBQUosR0FBcUIsT0FBTyxDQUFDLElBQTdCO0FBQ0EsZUFBTyxJQUFQO0FBQ0gsT0FKYyxFQUlaLEVBSlksQ0FBZjtBQUtBLGFBQU8sR0FBUDtBQUNILEtBVE0sRUFTSixFQVRJLENBQVA7QUFVSDs7QUFDRCxFQUFBLE9BQU8sQ0FBQyxpQkFBUixHQUE0QixpQkFBNUI7QUFDSCxDQXZMRDs7Ozs7QUNBQSxJQUFJLGVBQWUsR0FBSSxVQUFRLFNBQUssZUFBZCxJQUFrQyxVQUFVLEdBQVYsRUFBZTtBQUNuRSxTQUFRLEdBQUcsSUFBSSxHQUFHLENBQUMsVUFBWixHQUEwQixHQUExQixHQUFnQztBQUFFLGVBQVc7QUFBYixHQUF2QztBQUNILENBRkQ7O0FBR0EsQ0FBQyxVQUFVLE9BQVYsRUFBbUI7QUFDaEIsTUFBSSxPQUFPLE1BQVAsS0FBa0IsUUFBbEIsSUFBOEIsT0FBTyxNQUFNLENBQUMsT0FBZCxLQUEwQixRQUE1RCxFQUFzRTtBQUNsRSxRQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsT0FBRCxFQUFVLE9BQVYsQ0FBZjtBQUNBLFFBQUksQ0FBQyxLQUFLLFNBQVYsRUFBcUIsTUFBTSxDQUFDLE9BQVAsR0FBaUIsQ0FBakI7QUFDeEIsR0FIRCxNQUlLLElBQUksT0FBTyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE1BQU0sQ0FBQyxHQUEzQyxFQUFnRDtBQUNqRCxJQUFBLE1BQU0sQ0FBQyxDQUFDLFNBQUQsRUFBWSxTQUFaLEVBQXVCLE9BQXZCLENBQUQsRUFBa0MsT0FBbEMsQ0FBTjtBQUNIO0FBQ0osQ0FSRCxFQVFHLFVBQVUsT0FBVixFQUFtQixPQUFuQixFQUE0QjtBQUMzQjs7QUFDQSxFQUFBLE1BQU0sQ0FBQyxjQUFQLENBQXNCLE9BQXRCLEVBQStCLFlBQS9CLEVBQTZDO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUE3Qzs7QUFDQSxRQUFNLE9BQU8sR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLE9BQUQsQ0FBUixDQUEvQjtBQUNBOzs7Ozs7Ozs7OztBQVNBLFdBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQjtBQUN0QixVQUFNLElBQUksR0FBRyxPQUFPLEdBQXBCOztBQUNBLFFBQUksSUFBSSxLQUFLLFFBQWIsRUFBdUI7QUFDbkIsVUFBSSxHQUFHLENBQUMsTUFBSixDQUFXLENBQVgsRUFBYyxDQUFkLE1BQXFCLElBQXpCLEVBQStCO0FBQzNCLGVBQU8sSUFBSSxPQUFPLENBQUMsT0FBWixDQUFvQixHQUFHLENBQUMsTUFBSixDQUFXLENBQVgsQ0FBcEIsRUFBbUMsRUFBbkMsQ0FBUDtBQUNILE9BRkQsTUFHSztBQUNELGVBQU8sSUFBSSxPQUFPLENBQUMsT0FBWixDQUFvQixHQUFwQixFQUF5QixFQUF6QixDQUFQO0FBQ0g7QUFDSixLQVBELE1BUUssSUFBSSxJQUFJLEtBQUssUUFBYixFQUF1QjtBQUN4QixhQUFPLElBQUksT0FBTyxDQUFDLE9BQVosQ0FBb0IsR0FBcEIsQ0FBUDtBQUNILEtBRkksTUFHQSxJQUFJLEdBQUcsQ0FBQyxPQUFSLEVBQWlCO0FBQ2xCO0FBQ0EsYUFBTyxHQUFQO0FBQ0gsS0FISSxNQUlBO0FBQ0QsWUFBTSxJQUFJLEtBQUosQ0FBVSwwQkFBVixDQUFOO0FBQ0g7QUFDSjs7QUFDRCxXQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsTUFBN0IsRUFBcUM7QUFDakM7QUFDQSxRQUFJLElBQUksR0FBRyxHQUFYLENBRmlDLENBR2pDOztBQUNBLFFBQUksSUFBSSxDQUFDLE1BQUwsR0FBYyxNQUFsQixFQUEwQjtBQUN0QixNQUFBLElBQUksR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLE1BQUwsQ0FBWSxNQUFaLENBQUQsRUFBc0IsRUFBdEIsQ0FBZjtBQUNILEtBTmdDLENBT2pDOzs7QUFDQSxRQUFJLElBQUksR0FBRyxDQUFQLElBQVksSUFBSSxHQUFHLENBQW5CLElBQXdCLElBQUksR0FBRyxHQUFuQyxFQUF3QztBQUNwQyxZQUFNLElBQUksS0FBSiw2QkFBK0IsSUFBL0IsRUFBTjtBQUNIOztBQUNELFdBQU8sSUFBUDtBQUNIO0FBQ0Q7Ozs7Ozs7Ozs7OztBQVVBLFdBQVMsWUFBVCxDQUFzQixHQUF0QixFQUEyQixJQUEzQixFQUFrRDtBQUFBLFFBQWpCLE9BQWlCLHVFQUFQLEtBQU87O0FBQzlDLFFBQUksSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsTUFBaEIsQ0FBSixFQUE2QjtBQUN6QixZQUFNLElBQUksR0FBRyxhQUFhLENBQUMsSUFBRCxFQUFPLENBQVAsQ0FBMUIsQ0FEeUIsQ0FDWTs7QUFDckMsWUFBTSxNQUFNLEdBQUcsSUFBSSxHQUFHLENBQXRCLENBRnlCLENBRUE7O0FBQ3pCLFlBQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxHQUFELENBQTFCLENBSHlCLENBSXpCOztBQUNBLFVBQUksTUFBTSxDQUFDLEtBQVAsRUFBSixFQUFvQjtBQUNoQixjQUFNLElBQUksS0FBSixDQUFVLDJCQUFWLENBQU47QUFDSCxPQVB3QixDQVF6Qjs7O0FBQ0EsVUFBSSxPQUFKLEVBQWE7QUFDVCxlQUFPLE9BQU8sTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsRUFBaEIsQ0FBZDtBQUNIOztBQUNELGFBQU8sT0FBTyxNQUFNLENBQUMsUUFBUCxDQUFnQixFQUFoQixFQUFvQixNQUFwQixDQUFkO0FBQ0gsS0FiRCxNQWNLLElBQUksSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsS0FBaEIsQ0FBSixFQUE0QjtBQUM3QjtBQUNBLFlBQU0sSUFBSSxHQUFHLGFBQWEsQ0FBQyxJQUFELEVBQU8sQ0FBUCxDQUExQjtBQUNBLFlBQU0sTUFBTSxHQUFHLElBQUksR0FBRyxDQUF0QixDQUg2QixDQUdKOztBQUN6QixZQUFNLE1BQU0sR0FBRyxXQUFXLENBQUMsR0FBRCxDQUExQixDQUo2QixDQUs3Qjs7QUFDQSxhQUFPLE9BQU8sTUFBTSxDQUFDLE1BQVAsQ0FBYyxJQUFkLEVBQW9CLFFBQXBCLENBQTZCLEVBQTdCLEVBQWlDLE1BQWpDLENBQWQ7QUFDSCxLQVBJLE1BUUE7QUFDRCxZQUFNLElBQUksS0FBSixDQUFVLHFCQUFWLENBQU47QUFDSDtBQUNKOztBQUNELEVBQUEsT0FBTyxDQUFDLFlBQVIsR0FBdUIsWUFBdkI7QUFDSCxDQTdGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7QUNqUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiLyoqXG4gKiBSZXByZXNlbnRzIGEgQml0c2tpIGFjY2VzcyB0b2tlblxuICovXG5leHBvcnQgY2xhc3MgQWNjZXNzVG9rZW4ge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuIHRoZSBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcGFyYW0gZXhwaXJlc0F0IHRoZSB0b2tlbiBleHBpcmF0aW9uIGRhdGUgKGluIHNlY29uZHMpIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0gc2NvcGUgdGhlIHNjb3BlcyB0aGlzIHRva2VuIHJlcHJlc2VudHMgKG9wdGlvbmFsKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHRva2VuLCBleHBpcmVzQXQsIHNjb3BlKSB7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLmV4cGlyZXNBdCA9IGV4cGlyZXNBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRva2VuIGZyb20gYSBUb2tlblJlc3BvbnNlIG9iamVjdFxuICAgICAqIEBwYXJhbSB0b2tlblJlc3BvbnNlIFRoZSB0b2tlbiByZXNwb25zZSBvYmplY3QgdG8gYnVpbGQgYSB0b2tlbiBmcm9tXG4gICAgICovXG4gICAgc3RhdGljIGZyb21Ub2tlblJlc3BvbnNlKHRva2VuUmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IGV4cGlyZXNBdDtcbiAgICAgICAgaWYgKHRva2VuUmVzcG9uc2UuZXhwaXJlc0luKSB7XG4gICAgICAgICAgICBleHBpcmVzQXQgPSBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKSArIHRva2VuUmVzcG9uc2UuZXhwaXJlc0luO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgQWNjZXNzVG9rZW4odG9rZW5SZXNwb25zZS5hY2Nlc3NUb2tlbiwgZXhwaXJlc0F0LCB0b2tlblJlc3BvbnNlLnNjb3BlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRva2VuIGZyb20gYSBzdG9yYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSBzIEpTT04gc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdG9rZW5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzKSB7XG4gICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyc2VkLnRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBY2Nlc3NUb2tlbihwYXJzZWQudG9rZW4sIHBhcnNlZC5leHBpcmVzQXQsIHBhcnNlZC5zY29wZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgaWYgdGhlIHRva2VuIGlzIHN0aWxsIGFjdGl2ZVxuICAgICAqL1xuICAgIGdldCBleHBpcmVkKCkge1xuICAgICAgICBpZiAodGhpcy5leHBpcmVzQXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gdGhpcy5leHBpcmVzQXQgLSBub3c7XG4gICAgICAgICAgICByZXR1cm4gZXhwaXJlc0luIDw9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTiBzdHJpbmcgc3VpdGFibGUgZm9yIHdyaXRpbmcgaW4gbG9jYWwgc3RvcmFnZVxuICAgICAqL1xuICAgIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV4cGlyZXNBdDogdGhpcy5leHBpcmVzQXQsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZSxcbiAgICAgICAgICAgIHRva2VuOiB0aGlzLnRva2VuLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBBdXRob3JpemF0aW9uTm90aWZpZXIsIEF1dGhvcml6YXRpb25SZXF1ZXN0LCBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sIEJhc2VUb2tlblJlcXVlc3RIYW5kbGVyLCBGZXRjaFJlcXVlc3RvciwgR1JBTlRfVFlQRV9BVVRIT1JJWkFUSU9OX0NPREUsIEdSQU5UX1RZUEVfUkVGUkVTSF9UT0tFTiwgUmVkaXJlY3RSZXF1ZXN0SGFuZGxlciwgVG9rZW5SZXF1ZXN0LCB9IGZyb20gJ0BvcGVuaWQvYXBwYXV0aCc7XG5pbXBvcnQgeyBCSVRTS0lfVVNFUl9BUElfSE9TVCwgREVGQVVMVF9PQVVUSF9DT05GSUdVUkFUSU9OLCBERUZBVUxUX09QVElPTkFMX1NDT1BFUywgREVGQVVMVF9TQ09QRVMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb25FcnJvciB9IGZyb20gJy4uL2Vycm9ycy9hdXRoZW50aWNhdGlvbi1lcnJvcic7XG5pbXBvcnQgeyBOb0hhc2hRdWVyeVN0cmluZ1V0aWxzIH0gZnJvbSAnLi4vdXRpbHMvbm8taGFzaC1xdWVyeS1zdHJpbmctdXRpbHMnO1xuaW1wb3J0IHsgcGFyc2VSZXNwb25zZSB9IGZyb20gJy4uL3V0aWxzL3JlcXVlc3QtdXRpbHMnO1xuaW1wb3J0IHsgUG9wdXBCbG9ja2VkRXJyb3IsIFBvcHVwQ2xvc2VkRXJyb3IsIFBvcHVwUmVxdWVzdEhhbmRsZXIgfSBmcm9tICcuL3BvcHVwLWhhbmRsZXInO1xuLy8gVXNlIHRoaXMgY29uc3RhbnQgaW4gbG9naW5faGludCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBzaWduIHVwIFVJIHNob3VsZCBiZSBkaXNwbGF5ZWRcbmV4cG9ydCBjb25zdCBMT0dJTl9ISU5UX1NJR05VUCA9ICdzaWdudXAnO1xuLyoqXG4gKiBSZXNwb25zaWJsZSBmb3Igc3VibWl0dGluZyByZXF1ZXN0cyB0byBvdXIgT0F1dGggc2VydmVyLlxuICovXG5leHBvcnQgY2xhc3MgT0F1dGhNYW5hZ2VyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgT0F1dGggTWFuYWdlclxuICAgICAqIEBwYXJhbSBvcHRpb25zIFNldHRpbmdzIG9iamVjdFxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNsaWVudElkIHN0cmluZzogVGhlIGNsaWVudCBpZCB0byB1c2UgZm9yIHZhcmlvdXMgcmVxdWVzdHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5yZWRpcmVjdFVyaSBzdHJpbmc6IFRoZSByZWRpcmVjdCBVUkkgdG8gdXNlIGZvciByZXNwb25kaW5nIHRvIGF1dGggcmVxdWVzdHNcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWd1cmF0aW9uIEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbiAob3B0aW9uYWwpOiBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIE9BdXRoIHNlcnZlclxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFkZGl0aW9uYWxTY29wZXMgc3RyaW5nW10gKG9wdGlvbmFsKTogQWRkaXRpb25hbCBzY29wZXMgdG8gcmVxdWVzdCBvdXRzaWRlIG9mIG9wZW5pZC5cbiAgICAgKiBEZWZhdWx0IGlzIG9mZmxpbmUuIFBhc3MgYW4gZW1wdHkgYXJyYXkgdG8gb25seSByZXF1ZXN0IG9wZW5pZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuICAgICAgICB0aGlzLnJlZGlyZWN0VXJpID0gb3B0aW9ucy5yZWRpcmVjdFVyaTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uID0gb3B0aW9ucy5jb25maWd1cmF0aW9uIHx8IG5ldyBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24oREVGQVVMVF9PQVVUSF9DT05GSUdVUkFUSU9OKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFNjb3BlcyA9IG9wdGlvbnMuYWRkaXRpb25hbFNjb3BlcyB8fCBERUZBVUxUX09QVElPTkFMX1NDT1BFUztcbiAgICAgICAgdGhpcy5zY29wZXMgPSBERUZBVUxUX1NDT1BFUy5jb25jYXQoYWRkaXRpb25hbFNjb3Blcyk7XG4gICAgICAgIHRoaXMudG9rZW5IYW5kbGVyID0gbmV3IEJhc2VUb2tlblJlcXVlc3RIYW5kbGVyKG5ldyBGZXRjaFJlcXVlc3RvcigpKTtcbiAgICAgICAgdGhpcy5ub3RpZmllciA9IG5ldyBBdXRob3JpemF0aW9uTm90aWZpZXIoKTtcbiAgICAgICAgdGhpcy5ub3RpZmllci5zZXRBdXRob3JpemF0aW9uTGlzdGVuZXIodGhpcy5kaWRDb21wbGV0ZUF1dGhvcml6YXRpb25GbG93LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VyIGEgcG9wdXAgc2lnbiBpbiBmbG93ICh0aGUgZGVmYXVsdClcbiAgICAgKi9cbiAgICBzaWduSW5Qb3B1cChvcHRzKSB7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIgPSB7IGZ1bGZpbGwsIHJlamVjdCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlciA9IG5ldyBQb3B1cFJlcXVlc3RIYW5kbGVyKCk7XG4gICAgICAgIHRoaXMuYXV0aEhhbmRsZXIuc2V0QXV0aG9yaXphdGlvbk5vdGlmaWVyKHRoaXMubm90aWZpZXIpO1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVBdXRoUmVxdWVzdChvcHRzKTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlci5wZXJmb3JtQXV0aG9yaXphdGlvblJlcXVlc3QodGhpcy5jb25maWd1cmF0aW9uLCByZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3RBY2Nlc3NUb2tlbihyZXNwb25zZS5jb2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgYSByZWRpcmVjdCBzaWduIGluIGZsb3cuIFByb21pc2Ugc2hvdWxkIG5ldmVyIGZ1bGZpbGwsIGFzIHlvdSB3aWxsIGJlIHJlZGlyZWN0ZWQuXG4gICAgICovXG4gICAgc2lnbkluUmVkaXJlY3Qob3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc29sdmVyID0geyBmdWxmaWxsLCByZWplY3QgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0aEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RSZXF1ZXN0SGFuZGxlcih1bmRlZmluZWQsIG5ldyBOb0hhc2hRdWVyeVN0cmluZ1V0aWxzKCkpO1xuICAgICAgICB0aGlzLmF1dGhIYW5kbGVyLnNldEF1dGhvcml6YXRpb25Ob3RpZmllcih0aGlzLm5vdGlmaWVyKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlQXV0aFJlcXVlc3Qob3B0cyk7XG4gICAgICAgIHRoaXMuYXV0aEhhbmRsZXIucGVyZm9ybUF1dGhvcml6YXRpb25SZXF1ZXN0KHRoaXMuY29uZmlndXJhdGlvbiwgcmVxdWVzdCk7XG4gICAgICAgIC8vIFNpbmNlIHRoaXMgbWV0aG9kIHJlZGlyZWN0cyB0aGUgd2hvbGUgd2luZG93LCB0aGUgcHJvbWlzZSB3aWxsXG4gICAgICAgIC8vIGxpa2VseSBuZXZlciBjb21wbGV0ZSB1bmxlc3Mgd2UgZW5jb3VudGVyIGFuIGVycm9yLlxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBmaW5hbGl6ZSBhdXRoIHJlcXVlc3QgZnJvbSBhIHJlZGlyZWN0IGZsb3cuIENhbGxlZCBmcm9tIHlvdXIgcmVkaXJlY3QgdXJsIG9uY2UgeW91J3ZlIGJlZW5cbiAgICAgKiByZWRpcmVjdGVkIGJhY2suXG4gICAgICovXG4gICAgcmVkaXJlY3RDYWxsYmFjaygpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc29sdmVyID0geyBmdWxmaWxsLCByZWplY3QgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYXV0aEhhbmRsZXIgPSBuZXcgUmVkaXJlY3RSZXF1ZXN0SGFuZGxlcih1bmRlZmluZWQsIG5ldyBOb0hhc2hRdWVyeVN0cmluZ1V0aWxzKCkpO1xuICAgICAgICB0aGlzLmF1dGhIYW5kbGVyLnNldEF1dGhvcml6YXRpb25Ob3RpZmllcih0aGlzLm5vdGlmaWVyKTtcbiAgICAgICAgdGhpcy5hdXRoSGFuZGxlci5jb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0SWZQb3NzaWJsZSgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdEFjY2Vzc1Rva2VuKHJlc3BvbnNlLmNvZGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjaGFuZ2UgYW4gYXV0aG9yaXphdGlvbiBjb2RlIGZvciBhbiBhY2Nlc3MgdG9rZW5cbiAgICAgKiBAcGFyYW0gY29kZSBUaGUgYXV0aG9yaXphdGlvbiBjb2RlIHRvIGV4Y2hhbmdlXG4gICAgICovXG4gICAgcmVxdWVzdEFjY2Vzc1Rva2VuKGNvZGUpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHRoaXMuY3JlYXRlVG9rZW5SZXF1ZXN0KGNvZGUpO1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbkhhbmRsZXIucGVyZm9ybVRva2VuUmVxdWVzdCh0aGlzLmNvbmZpZ3VyYXRpb24sIHJlcXVlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGEgbmV3IGFjY2VzcyB0b2tlbiBmcm9tIGEgcHJldmlvdXMgcmVmcmVzaCB0b2tlblxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gVGhlIHJlZnJlc2ggdG9rZW4gdG8gdXNlIGZvciBhdXRob3JpemF0aW9uXG4gICAgICovXG4gICAgcmVmcmVzaEFjY2Vzc1Rva2VuKHJlZnJlc2hUb2tlbikge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZWZyZXNoVG9rZW5SZXF1ZXN0KHJlZnJlc2hUb2tlbik7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuSGFuZGxlci5wZXJmb3JtVG9rZW5SZXF1ZXN0KHRoaXMuY29uZmlndXJhdGlvbiwgcmVxdWVzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1Ym1pdCBhIHNpZ24gb3V0IHJlcXVlc3Qgb24gdGhlIG9hdXRoIGVuZHBvaW50XG4gICAgICogQHBhcmFtIGFjY2Vzc1Rva2VuIFRoZSBhY2Nlc3MgdG9rZW4gdG8gc2lnbiBvdXQgd2l0aFxuICAgICAqL1xuICAgIHJlcXVlc3RTaWduT3V0KGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIHJldHVybiBmZXRjaChgJHtCSVRTS0lfVVNFUl9BUElfSE9TVH0vbG9nb3V0YCwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB9KS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBhIHVzZXIncyBwcm9maWxlIGZyb20gdGhlIG9hdXRoIHNlcnZlclxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBUaGUgYWNjZXNzIHRva2VuIGZvciB0aGUgdXNlclxuICAgICAqL1xuICAgIHJlcXVlc3RVc2VySW5mbyhhY2Nlc3NUb2tlbikge1xuICAgICAgICBjb25zdCB1c2VySW5mb0VuZHBvaW50ID0gdGhpcy5jb25maWd1cmF0aW9uLnVzZXJJbmZvRW5kcG9pbnQ7XG4gICAgICAgIGlmICghdXNlckluZm9FbmRwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEF1dGhlbnRpY2F0aW9uRXJyb3IuSW52YWxpZENvbmZpZ3VyYXRpb24oJ0NvdWxkIG5vdCBmaW5kIHVzZXIgaW5mbyBlbmRwb2ludCcpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmV0Y2godXNlckluZm9FbmRwb2ludCwge1xuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGNhbGxiYWNrIGZyb20gb3VyIEF1dGggUmVxdWVzdCBoYW5kbGVyLiBQYXNzZXMgdGhlIHJlc3BvbnNlIHRocm91Z2ggdG8gYSBjYWNoZWQgcHJvbWlzZSBpZiBpdCBleGlzdHMuXG4gICAgICogQHBhcmFtIHJlcXVlc3QgVGhlIG9yaWdpbmFsIGF1dGggcmVxdWVzdFxuICAgICAqIEBwYXJhbSByZXNwb25zZSBUaGUgYXV0aCByZXNwb25zZSBpZiBpdCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAqIEBwYXJhbSBlcnJvclJlc3BvbnNlIFRoZSBlcnJvciByZXNwb25zZSBpZiBpdCBmYWlsZWRcbiAgICAgKi9cbiAgICBkaWRDb21wbGV0ZUF1dGhvcml6YXRpb25GbG93KHJlcXVlc3QsIHJlc3BvbnNlLCBlcnJvclJlc3BvbnNlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdSZXNvbHZlcikge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIuZnVsZmlsbChyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnJvclJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yUmVzcG9uc2UgaW5zdGFuY2VvZiBQb3B1cENsb3NlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc29sdmVyLnJlamVjdChBdXRoZW50aWNhdGlvbkVycm9yLlVzZXJDYW5jZWxsZWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVycm9yUmVzcG9uc2UgaW5zdGFuY2VvZiBQb3B1cEJsb2NrZWRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBkb21haW4gb2YgdGhlIGF1dGhvcml0eSwgdG8gbG9nIGJldHRlciBjb250ZXh0IGZvciBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsTWF0Y2ggPSAvXihodHRwP3M6XFwvXFwvW1xcdy5dKilcXC9bXFx3XFwvXSokLztcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG1hdGNoZXMgYWdhaW5zdCB0aGUgYXV0aG9yaXR5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLmNvbmZpZ3VyYXRpb24uYXV0aG9yaXphdGlvbkVuZHBvaW50Lm1hdGNoKHVybE1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFzZVVybCA9IG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAxID8gbWF0Y2hlc1sxXSA6ICcnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNvbHZlci5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5Qb3B1cEJsb2NrZWQoYmFzZVVybCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVzb2x2ZXIucmVqZWN0KEF1dGhlbnRpY2F0aW9uRXJyb3IuU2VydmVyRXJyb3IoZXJyb3JSZXNwb25zZS5lcnJvciwgZXJyb3JSZXNwb25zZS5lcnJvckRlc2NyaXB0aW9uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc29sdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhbiBhdXRoIHJlcXVlc3RcbiAgICAgKi9cbiAgICBjcmVhdGVBdXRoUmVxdWVzdChvcHRzKSB7XG4gICAgICAgIC8vIENyZWF0ZSBiYXNlIHJlcXVlc3RcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBBdXRob3JpemF0aW9uUmVxdWVzdCh7XG4gICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IHRoaXMucmVkaXJlY3RVcmksXG4gICAgICAgICAgICByZXNwb25zZV90eXBlOiBBdXRob3JpemF0aW9uUmVxdWVzdC5SRVNQT05TRV9UWVBFX0NPREUsXG4gICAgICAgICAgICBzY29wZTogdGhpcy5zY29wZXMuam9pbignICcpLFxuICAgICAgICB9LCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgICAgLy8gUGFzcyBvcHRpb25zIHRocm91Z2hcbiAgICAgICAgaWYgKG9wdHMubG9naW5faGludCkge1xuICAgICAgICAgICAgLy8gT25seSBhc3NpZ24gZXh0cmFzIGlmIGxvZ2luX2hpbnQgaXMgaW5jbHVkZWQgaW4gdGhlIG9wdGlvbnNcbiAgICAgICAgICAgIHJlcXVlc3QuZXh0cmFzID0geyBsb2dpbl9oaW50OiBvcHRzLmxvZ2luX2hpbnQgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgdG9rZW4gcmVxdWVzdCB3aXRoIGEgcmVmcmVzaCB0b2tlblxuICAgICAqIEBwYXJhbSByZWZyZXNoVG9rZW4gUmVmcmVzaCB0b2tlbiB0byB1c2VcbiAgICAgKi9cbiAgICBjcmVhdGVSZWZyZXNoVG9rZW5SZXF1ZXN0KHJlZnJlc2hUb2tlbikge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuUmVxdWVzdCh7XG4gICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBncmFudF90eXBlOiBHUkFOVF9UWVBFX1JFRlJFU0hfVE9LRU4sXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IHRoaXMucmVkaXJlY3RVcmksXG4gICAgICAgICAgICByZWZyZXNoX3Rva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSB0b2tlbiByZXF1ZXN0IHdpdGggYW4gYXV0aCBjb2RlXG4gICAgICogQHBhcmFtIGNvZGUgVGhlIGF1dGggY29kZSB0byB1c2VcbiAgICAgKi9cbiAgICBjcmVhdGVUb2tlblJlcXVlc3QoY29kZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRva2VuUmVxdWVzdCh7XG4gICAgICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgZ3JhbnRfdHlwZTogR1JBTlRfVFlQRV9BVVRIT1JJWkFUSU9OX0NPREUsXG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IHRoaXMucmVkaXJlY3RVcmksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEF1dGhlbnRpY2F0aW9uU3RhdHVzLCBPQXV0aFNpZ25Jbk1ldGhvZCB9IGZyb20gJy4uL2JpdHNraSc7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvbkVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL2F1dGhlbnRpY2F0aW9uLWVycm9yJztcbmltcG9ydCB7IE9BdXRoTWFuYWdlciB9IGZyb20gJy4vb2F1dGgtbWFuYWdlcic7XG5pbXBvcnQgeyBUb2tlblN0b3JlIH0gZnJvbSAnLi90b2tlbi1zdG9yZSc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi91c2VyJztcbmltcG9ydCB7IFVzZXJTdG9yZSB9IGZyb20gJy4vdXNlci1zdG9yZSc7XG5leHBvcnQgY2xhc3MgT3BlbmlkQXV0aFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgcmVkaXJlY3RVcmksIGFkZGl0aW9uYWxTY29wZXMsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgYWRkaXRpb25hbFNjb3BlcyxcbiAgICAgICAgICAgIGNsaWVudElkLFxuICAgICAgICAgICAgcmVkaXJlY3RVcmksXG4gICAgICAgIH07XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc2V0dGluZ3MsIG9wdHMpO1xuICAgICAgICB0aGlzLm9hdXRoTWFuYWdlciA9IG5ldyBPQXV0aE1hbmFnZXIoc2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnRva2VuU3RvcmUgPSBuZXcgVG9rZW5TdG9yZShjbGllbnRJZCwgb3B0cy5zdG9yZSk7XG4gICAgICAgIHRoaXMudXNlclN0b3JlID0gbmV3IFVzZXJTdG9yZShjbGllbnRJZCwgb3B0cy5zdG9yZSk7XG4gICAgfVxuICAgIGdldCBhdXRoU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy50b2tlblN0b3JlLmN1cnJlbnRUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIEF1dGhlbnRpY2F0aW9uU3RhdHVzLkNvbm5lY3RlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnRva2VuU3RvcmUucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gQXV0aGVudGljYXRpb25TdGF0dXMuRXhwaXJlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBBdXRoZW50aWNhdGlvblN0YXR1cy5Ob3RDb25uZWN0ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuU3RvcmUuY3VycmVudFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudG9rZW5TdG9yZS5jdXJyZW50VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRva2VuU3RvcmUucmVmcmVzaFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5Ob3RTaWduZWRJbigpKTtcbiAgICB9XG4gICAgZ2V0UmVmcmVzaFRva2VuKCkge1xuICAgICAgICBpZiAodGhpcy50b2tlblN0b3JlLnJlZnJlc2hUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLnRva2VuU3RvcmUucmVmcmVzaFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFcnJvcjogdGhlIHVzZXIgZGlkIG5vdCBhcHByb3ZlIHRoaXMgYXBwIGZvciBvZmZsaW5lIGFjY2Vzc1xuICAgICAgICBpZiAodGhpcy50b2tlblN0b3JlLmN1cnJlbnRUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEF1dGhlbnRpY2F0aW9uRXJyb3IuTm9SZWZyZXNoVG9rZW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRXJyb3I6IHRoZSB1c2VyIGlzIG5vdCBzaWduZWQgaW4uXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChBdXRoZW50aWNhdGlvbkVycm9yLk5vdFNpZ25lZEluKCkpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlVG9rZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLnRva2VuU3RvcmUuY3VycmVudFRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLnRva2VuU3RvcmUuaW52YWxpZGF0ZUN1cnJlbnRUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNpZ25PdXRDYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5zaWduT3V0Q2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIHJlZnJlc2hBY2Nlc3NUb2tlbigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5TdG9yZS5yZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9hdXRoTWFuYWdlci5yZWZyZXNoQWNjZXNzVG9rZW4odGhpcy50b2tlblN0b3JlLnJlZnJlc2hUb2tlbikudGhlbigodG9rZW5SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5TdG9yZS5wZXJzaXN0VG9rZW5SZXNwb25zZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5SZXNwb25zZS5hY2Nlc3NUb2tlbjtcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IHJlbmV3LCB3ZSBsaWtlbHkgaGF2ZSBiYWQgZGF0YVxuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5TdG9yZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHRoaXMudXNlclN0b3JlLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoQXV0aGVudGljYXRpb25FcnJvci5Ob1JlZnJlc2hUb2tlbigpKTtcbiAgICB9XG4gICAgc2lnbkluKG1ldGhvZCwgb3B0cykge1xuICAgICAgICBsZXQgcHJvbWlzZTtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgT0F1dGhTaWduSW5NZXRob2QuUmVkaXJlY3Q6XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMub2F1dGhNYW5hZ2VyLnNpZ25JblJlZGlyZWN0KG9wdHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBPQXV0aFNpZ25Jbk1ldGhvZC5TaWxlbnQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KEF1dGhlbnRpY2F0aW9uRXJyb3IuVW5zdXBwb3J0ZWRBdXRoZW50aWNhdGlvbk1ldGhvZCgpKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcHJvbWlzZSA9IHRoaXMub2F1dGhNYW5hZ2VyLnNpZ25JblBvcHVwKG9wdHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oKHRva2VuUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5TdG9yZS5wZXJzaXN0VG9rZW5SZXNwb25zZSh0b2tlblJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZyZXNoQWNjZXNzVG9rZW4oKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRVc2VyKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRVc2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRPckZldGNoVXNlcigpO1xuICAgIH1cbiAgICBzaWduSW5PckNvbm5lY3Qoc2lnbkluTWV0aG9kID0gT0F1dGhTaWduSW5NZXRob2QuUG9wdXAsIG9wdHMpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmF1dGhTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgQXV0aGVudGljYXRpb25TdGF0dXMuQ29ubmVjdGVkOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvYWRVc2VyKCk7XG4gICAgICAgICAgICBjYXNlIEF1dGhlbnRpY2F0aW9uU3RhdHVzLkV4cGlyZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgY2FzZSBBdXRoZW50aWNhdGlvblN0YXR1cy5Ob3RDb25uZWN0ZWQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2lnbkluKHNpZ25Jbk1ldGhvZCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVkaXJlY3RDYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2F1dGhNYW5hZ2VyLnJlZGlyZWN0Q2FsbGJhY2soKS50aGVuKCh0b2tlblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRva2VuU3RvcmUucGVyc2lzdFRva2VuUmVzcG9uc2UodG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2FkVXNlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk91dCgpIHtcbiAgICAgICAgdGhpcy50b2tlblN0b3JlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXNlclN0b3JlLmNsZWFyKCk7XG4gICAgICAgIC8vIENhbGwgdGhlIHNpZ24gb3V0IGNhbGxiYWNrIGlmIG9uZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICBpZiAodGhpcy5zaWduT3V0Q2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbk91dENhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IGhhdmUgdGhlIGFiaWxpdHkgdG8gaW52YWxpZGF0ZSBhY2Nlc3MgdG9rZW5zLCBzbyBmb3Igbm93IHNpbXBseSByZXNvbHZlLlxuICAgICAgICAvLyBEb3duIHRoZSByb2FkIHRoaXMgbWF5IHBlcmZvcm0gYSBuZXR3b3JrIHJlcXVlc3QgdG8gaW52YWxpZGF0ZS5cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBnZXRPckZldGNoVXNlcigpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFVzZXIgPSB0aGlzLnVzZXJTdG9yZS5jdXJyZW50VXNlcjtcbiAgICAgICAgaWYgKGN1cnJlbnRVc2VyKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGN1cnJlbnRVc2VyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkVXNlcigpO1xuICAgIH1cbiAgICBsb2FkVXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWNjZXNzVG9rZW4oKS50aGVuKChhY2Nlc3NUb2tlbikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub2F1dGhNYW5hZ2VyLnJlcXVlc3RVc2VySW5mbyhhY2Nlc3NUb2tlbik7XG4gICAgICAgIH0pLnRoZW4oKGpzb24pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBVc2VyLmZyb21Kc29uKGpzb24pO1xuICAgICAgICB9KS50aGVuKCh1c2VyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVzZXJTdG9yZS5zZXQodXNlcik7XG4gICAgICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLy8gdHNsaW50OmRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGVcbmltcG9ydCB7IEF1dGhvcml6YXRpb25FcnJvciwgQXV0aG9yaXphdGlvblJlcXVlc3RIYW5kbGVyLCBBdXRob3JpemF0aW9uUmVzcG9uc2UsIEJhc2ljUXVlcnlTdHJpbmdVdGlscywgRGVmYXVsdENyeXB0bywgfSBmcm9tICdAb3BlbmlkL2FwcGF1dGgnO1xuaW1wb3J0IHsgQ0hFQ0tfRk9SX1BPUFVQX0NMT1NFX0lOVEVSVkFMLCBERUZBVUxUX1BPUFVQX0ZFQVRVUkVTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IHBhcnNlVXJsUGFyYW1zIH0gZnJvbSAnLi4vdXRpbHMvY2FsbGJhY2snO1xuaW1wb3J0IHsgUG9wdXBWYWxpZGF0b3IgfSBmcm9tICcuLi91dGlscy9wb3B1cC12YWxpZGF0b3InO1xuLy8gSW50ZXJtZWRpYXRlIGVycm9ycywgc2luY2UgQXV0aG9yaXphdGlvblJlcXVlc3RIYW5kbGVyIG11c3QgcmV0dXJuIGFuIEF1dGhvcml6YXRpb25FcnJvciBpbnN0YW5jZS5cbi8vIFRoZXNlIHNob3VsZCBub3QgYmUgdXNlciB2aXNpYmxlLlxuZXhwb3J0IGNsYXNzIFBvcHVwQ2xvc2VkRXJyb3IgZXh0ZW5kcyBBdXRob3JpemF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7IGVycm9yOiAnVGhlIHBvcHVwIHdhcyBkaXNtaXNzZWQuJyB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUG9wdXBCbG9ja2VkRXJyb3IgZXh0ZW5kcyBBdXRob3JpemF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7IGVycm9yOiAnVGhlIHBvcHVwIHdhcyBibG9ja2VkLicgfSk7XG4gICAgfVxufVxuLy8gQ3JlYXRlIGEgcG9wdXAgZmVhdHVyZSBzdHJpbmcgZnJvbSBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXNcbmZ1bmN0aW9uIGNyZWF0ZVBvcHVwRmVhdHVyZVN0cmluZyhmZWF0dXJlcykge1xuICAgIC8vIENvbnZlcnQgdG8gYXJyYXkgb2Ygc3RyaW5nc1xuICAgIGNvbnN0IGZlYXR1cmVzQXJyYXkgPSBPYmplY3Qua2V5cyhmZWF0dXJlcykucmVkdWNlKChhcnIsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGZlYXR1cmVzW2tleV07XG4gICAgICAgIC8vIGNvbnZlcnQgdG8gZmVhdHVyZSBzdHJpbmcgZm9ybWF0OiB0b3A9MTAwXG4gICAgICAgIGFyci5wdXNoKGAke2tleX09JHt2YWx1ZX1gKTtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9LCBBcnJheSgpKTtcbiAgICAvLyBKb2luIHN0cmluZ3Mgd2l0aCAnLCcgYW5kIGZpbmlzaCB3aXRoICc7J1xuICAgIHJldHVybiBmZWF0dXJlc0FycmF5LmpvaW4oJywnKSArICc7Jztcbn1cbi8vIFJldHVybnMgYSBzZXQgb2YgYXR0cmlidXRlcyBmb3IgYSBjZW50ZXJlZCBwb3B1cCBiYXNlZCBvblxuLy8gdGhlIGRlZmF1bHQgdmFsdWVzIGZyb20gY29uc3RhbnRzLnRzXG5mdW5jdGlvbiBjcmVhdGVDZW50ZXJlZFBvcHVwRmVhdHVyZXMoKSB7XG4gICAgY29uc3Qgd2luZG93RmVhdHVyZXMgPSBERUZBVUxUX1BPUFVQX0ZFQVRVUkVTO1xuICAgIGNvbnN0IHcgPSB3aW5kb3dGZWF0dXJlcy53aWR0aDtcbiAgICBjb25zdCBoID0gd2luZG93RmVhdHVyZXMuaGVpZ2h0O1xuICAgIC8vIEZpeGVzIGR1YWwtc2NyZWVuIHBvc2l0aW9uXG4gICAgY29uc3QgZHVhbFNjcmVlbkxlZnQgPSB3aW5kb3cuc2NyZWVuTGVmdCB8fCB3aW5kb3cuc2NyZWVuWDtcbiAgICBjb25zdCBkdWFsU2NyZWVuVG9wID0gd2luZG93LnNjcmVlblRvcCB8fCB3aW5kb3cuc2NyZWVuWTtcbiAgICBjb25zdCB3aW5kb3dXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCB8fCBzY3JlZW4ud2lkdGg7XG4gICAgY29uc3Qgd2luZG93SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgc2NyZWVuLmhlaWdodDtcbiAgICBjb25zdCBsZWZ0ID0gKHdpbmRvd1dpZHRoIC8gMikgLSAodyAvIDIpO1xuICAgIGNvbnN0IHRvcCA9ICh3aW5kb3dIZWlnaHQgLyAyKSAtIChoIC8gMik7XG4gICAgd2luZG93RmVhdHVyZXMubGVmdCA9IGxlZnQgKyBkdWFsU2NyZWVuTGVmdDtcbiAgICB3aW5kb3dGZWF0dXJlcy50b3AgPSB0b3AgKyBkdWFsU2NyZWVuVG9wO1xuICAgIHJldHVybiB3aW5kb3dGZWF0dXJlcztcbn1cbmV4cG9ydCBjbGFzcyBQb3B1cFJlcXVlc3RIYW5kbGVyIGV4dGVuZHMgQXV0aG9yaXphdGlvblJlcXVlc3RIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih1dGlscyA9IG5ldyBCYXNpY1F1ZXJ5U3RyaW5nVXRpbHMoKSwgY3J5cHRvID0gbmV3IERlZmF1bHRDcnlwdG8oKSkge1xuICAgICAgICBzdXBlcih1dGlscywgY3J5cHRvKTtcbiAgICAgICAgdGhpcy5wb3B1cFdpbmRvdyA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0Jsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gV2F0Y2ggZm9yIHRoZSBwb3B1cCBiZWluZyBibG9ja2VkXG4gICAgICAgIHRoaXMudmFsaWRhdG9yID0gbmV3IFBvcHVwVmFsaWRhdG9yKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFJldHVybiBhIHNwZWNpZmljIGVycm9yIGlmIGJsb2NrZWQsIHNvIHRoYXQgd2UgY2FuIGhhbmRsZSBpdCBhcHByb3ByaWF0ZWx5LlxuICAgICAgICAgICAgdGhpcy5pc0Jsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0SWZQb3NzaWJsZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybUF1dGhvcml6YXRpb25SZXF1ZXN0KGNvbmZpZ3VyYXRpb24sIHJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFJlcXVlc3RVcmwoY29uZmlndXJhdGlvbiwgcmVxdWVzdCk7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmlkID0gcmVxdWVzdC5zdGF0ZTtcbiAgICAgICAgLy8gU2V0IGEgdW5pcXVlIGhhbmRsZXIgb24gdGhlIG1haW4gd2luZG93XG4gICAgICAgIHdpbmRvd1tgcG9wdXBDYWxsYmFja18ke3JlcXVlc3Quc3RhdGV9YF0gPSB0aGlzLmNhbGxiYWNrLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIFN0YXJ0IG1vbml0b3JpbmcgdG8gc2VlIGlmIHRoZSBwb3B1cCBoYXMgYmVlbiBjbG9zZWRcbiAgICAgICAgdGhpcy5jbG9zZWRUaW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrUG9wdXAuYmluZCh0aGlzKSwgQ0hFQ0tfRk9SX1BPUFVQX0NMT1NFX0lOVEVSVkFMKTtcbiAgICAgICAgLy8gQ3JlYXRlIGZlYXR1cmVzIGZvciBwb3B1cFxuICAgICAgICBjb25zdCB3aW5kb3dGZWF0dXJlcyA9IGNyZWF0ZUNlbnRlcmVkUG9wdXBGZWF0dXJlcygpO1xuICAgICAgICAvLyBDcmVhdGUgcG9wdXAgd2luZG93XG4gICAgICAgIHRoaXMucG9wdXBXaW5kb3cgPSB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnLCBjcmVhdGVQb3B1cEZlYXR1cmVTdHJpbmcod2luZG93RmVhdHVyZXMpKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHBvcHVwIHdlIGp1c3QgY3JlYXRlZCB3YXMgYmxvY2tlZC5cbiAgICAgICAgdGhpcy52YWxpZGF0b3IuY2hlY2sodGhpcy5wb3B1cFdpbmRvdyk7XG4gICAgICAgIC8vIEZvY3VzIHRoZSBwb3B1cCB0byBicmluZyBpdCB0byB0aGUgZnJvbnRcbiAgICAgICAgaWYgKHRoaXMucG9wdXBXaW5kb3cpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBXaW5kb3cuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWxsYmFjayh1cmwpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZVVybCA9IHVybDtcbiAgICAgICAgdGhpcy5jb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0SWZQb3NzaWJsZSgpO1xuICAgIH1cbiAgICAvLyBDdXN0b20gaW1wbGVtZW50YXRpb24gdG8gcmVtb3ZlIGV4Y2VzcyBsb2cgc3BhbVxuICAgIGNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3RJZlBvc3NpYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0KCkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICYmIHRoaXMubm90aWZpZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmaWVyLm9uQXV0aG9yaXphdGlvbkNvbXBsZXRlKHJlc3VsdC5yZXF1ZXN0LCByZXN1bHQucmVzcG9uc2UsIHJlc3VsdC5lcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0KCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdDtcbiAgICAgICAgLy8gQXNzZXJ0IHRoZXJlIGlzIGEgcGVuZGluZyByZXF1ZXN0XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBc3NlcnQgdGhlIHJlcXVlc3Qgd2Fzbid0IGNhbmNlbGxlZFxuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uZFdpdGhDYW5jZWxsZWQocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNCbG9ja2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25kV2l0aEJsb2NrZWQocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZXJ0IHRoZXJlIGlzIG5vIGVycm9yXG4gICAgICAgIGlmICh0aGlzLmVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNwb25kV2l0aEVycm9yKHJlcXVlc3QsIHRoaXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXNzZXJ0IHRoZXJlIGlzIGEgcmVzcG9uc2UgdXJsIHRvIHBhcnNlXG4gICAgICAgIGlmICghdGhpcy5yZXNwb25zZVVybCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSB0aGUgdXJsIGludG8gZGF0YVxuICAgICAgICBjb25zdCBkYXRhID0gcGFyc2VVcmxQYXJhbXModGhpcy5yZXNwb25zZVVybCk7XG4gICAgICAgIC8vIEV4dHJhIHRoZSBzdGF0ZVxuICAgICAgICBjb25zdCBzdGF0ZSA9IGRhdGEuc3RhdGU7XG4gICAgICAgIC8vIFZhbGlkYXRlIHN0YXRlIGlzIHNhbWUgYXMgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFuIGVycm9yIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGVycm9yID0gZGF0YS5lcnJvcjtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBnZXQgYWRkaXRpb25hbCBvcHRpb25hbCBpbmZvLlxuICAgICAgICAgICAgY29uc3QgZXJyb3JVcmkgPSBkYXRhLmVycm9yX3VyaTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yRGVzY3JpcHRpb24gPSBkYXRhLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uZFdpdGhFcnJvcihyZXF1ZXN0LCBlcnJvciwgZXJyb3JEZXNjcmlwdGlvbiwgZXJyb3JVcmkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3BvbmQgd2l0aCBhIGNvZGVcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEuY29kZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uZFdpdGhDb2RlKHJlcXVlc3QsIGNvZGUpO1xuICAgIH1cbiAgICByZXNwb25kV2l0aEJsb2NrZWQocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBQb3B1cEJsb2NrZWRFcnJvcigpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHsgcmVxdWVzdCwgZXJyb3IsIHJlc3BvbnNlOiBudWxsIH07XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmVzcG9uZFdpdGhDYW5jZWxsZWQocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBQb3B1cENsb3NlZEVycm9yKCk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0geyByZXF1ZXN0LCBlcnJvciwgcmVzcG9uc2U6IG51bGwgfTtcbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXNwb25kV2l0aEVycm9yKHJlcXVlc3QsIGVycm9yTWVzc2FnZSwgZXJyb3JEZXNjcmlwdGlvbiwgZXJyb3JVcmkpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgQXV0aG9yaXphdGlvbkVycm9yKHsgZXJyb3I6IGVycm9yTWVzc2FnZSwgZXJyb3JfZGVzY3JpcHRpb246IGVycm9yRGVzY3JpcHRpb24sIGVycm9yX3VyaTogZXJyb3JVcmksIHN0YXRlOiByZXF1ZXN0LnN0YXRlIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHsgcmVxdWVzdCwgZXJyb3IsIHJlc3BvbnNlOiBudWxsIH07XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmVzcG9uZFdpdGhDb2RlKHJlcXVlc3QsIGNvZGUpIHtcbiAgICAgICAgbGV0IGF1dGhvcml6YXRpb25SZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBhdXRob3JpemF0aW9uUmVzcG9uc2UgPSBuZXcgQXV0aG9yaXphdGlvblJlc3BvbnNlKHsgY29kZSwgc3RhdGU6IHJlcXVlc3Quc3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7IHJlcXVlc3QsIHJlc3BvbnNlOiBhdXRob3JpemF0aW9uUmVzcG9uc2UsIGVycm9yOiBudWxsIH07XG4gICAgICAgIHRoaXMuY2xlYW51cCgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5jbG9zZWRUaW1lcik7XG4gICAgICAgIGRlbGV0ZSB3aW5kb3dbYHBvcHVwQ2FsbGJhY2tfJHt0aGlzLmlkfWBdO1xuICAgICAgICBpZiAodGhpcy5wb3B1cFdpbmRvdykge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFdpbmRvdy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wdXBXaW5kb3cgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmlkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlc3BvbnNlVXJsID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjaGVja1BvcHVwKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFdpbmRvdyAmJiB0aGlzLnBvcHVwV2luZG93LmNsb3NlZCkge1xuICAgICAgICAgICAgLy8gU3RvcCBjaGVja2luZ1xuICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy5jbG9zZWRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBdXRob3JpemF0aW9uUmVxdWVzdElmUG9zc2libGUoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IEFDQ0VTU19UT0tFTl9LRVksIFJFRlJFU0hfVE9LRU5fS0VZIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZVN0b3JlIH0gZnJvbSAnLi4vdXRpbHMvbG9jYWxzdG9yYWdlLXN0b3JlJztcbmltcG9ydCB7IEFjY2Vzc1Rva2VuIH0gZnJvbSAnLi9hY2Nlc3MtdG9rZW4nO1xuZXhwb3J0IGNsYXNzIFRva2VuU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudElkLCBzdG9yZSkge1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZSB8fCBuZXcgTG9jYWxTdG9yYWdlU3RvcmUoKTtcbiAgICAgICAgY29uc3QgYWNjZXNzVG9rZW5TdHJpbmcgPSB0aGlzLnN0b3JlLmdldEl0ZW0odGhpcy5hY2Nlc3NUb2tlbktleSk7XG4gICAgICAgIGlmIChhY2Nlc3NUb2tlblN0cmluZykge1xuICAgICAgICAgICAgbGV0IHBhcnNlZFRva2VuO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRUb2tlbiA9IEFjY2Vzc1Rva2VuLmZyb21TdHJpbmcoYWNjZXNzVG9rZW5TdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHBhcnNlZFRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJyZW50VG9rZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLmFjY2Vzc1Rva2VuICYmICF0aGlzLmFjY2Vzc1Rva2VuLmV4cGlyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuLnRva2VuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCByZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy5zdG9yZS5nZXRJdGVtKHRoaXMucmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGFjY2Vzc1Rva2VuS2V5KCkge1xuICAgICAgICByZXR1cm4gYCR7QUNDRVNTX1RPS0VOX0tFWX0uJHt0aGlzLmNsaWVudElkfWA7XG4gICAgfVxuICAgIGdldCByZWZyZXNoVG9rZW5LZXkoKSB7XG4gICAgICAgIHJldHVybiBgJHtSRUZSRVNIX1RPS0VOX0tFWX0uJHt0aGlzLmNsaWVudElkfWA7XG4gICAgfVxuICAgIHBlcnNpc3RUb2tlblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5yZWZyZXNoVG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmUuc2V0SXRlbSh0aGlzLnJlZnJlc2hUb2tlbktleSwgcmVzcG9uc2UucmVmcmVzaFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUb2tlbiA9IEFjY2Vzc1Rva2VuLmZyb21Ub2tlblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgdGhpcy5zdG9yZS5zZXRJdGVtKHRoaXMuYWNjZXNzVG9rZW5LZXksIHBhcnNlZFRva2VuLnRvU3RvcmFnZVN0cmluZygpKTtcbiAgICAgICAgdGhpcy5hY2Nlc3NUb2tlbiA9IHBhcnNlZFRva2VuO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlQ3VycmVudFRva2VuKCkge1xuICAgICAgICB0aGlzLmFjY2Vzc1Rva2VuID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnN0b3JlLmNsZWFySXRlbSh0aGlzLmFjY2Vzc1Rva2VuS2V5KTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuYWNjZXNzVG9rZW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RvcmUuY2xlYXJJdGVtKHRoaXMucmVmcmVzaFRva2VuS2V5KTtcbiAgICAgICAgdGhpcy5zdG9yZS5jbGVhckl0ZW0odGhpcy5hY2Nlc3NUb2tlbktleSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgVVNFUl9LRVkgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgTG9jYWxTdG9yYWdlU3RvcmUgfSBmcm9tICcuLi91dGlscy9sb2NhbHN0b3JhZ2Utc3RvcmUnO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdXNlcic7XG5leHBvcnQgY2xhc3MgVXNlclN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgc3RvcmUpIHtcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLnN0b3JlID0gc3RvcmUgfHwgbmV3IExvY2FsU3RvcmFnZVN0b3JlKCk7XG4gICAgICAgIHRoaXMudXNlciA9IHRoaXMuZmV0Y2hVc2VyKCk7XG4gICAgfVxuICAgIGdldCBjdXJyZW50VXNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlciB8fCB0aGlzLmZldGNoVXNlcigpO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZUtleSgpIHtcbiAgICAgICAgcmV0dXJuIGAke1VTRVJfS0VZfS4ke3RoaXMuY2xpZW50SWR9YDtcbiAgICB9XG4gICAgc2V0KHVzZXIpIHtcbiAgICAgICAgdGhpcy51c2VyID0gdXNlcjtcbiAgICAgICAgdGhpcy5jYWNoZVVzZXIodXNlcik7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVzZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FjaGVVc2VyKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZldGNoVXNlcigpIHtcbiAgICAgICAgY29uc3QgdXNlckRhdGEgPSB0aGlzLnN0b3JlLmdldEl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgaWYgKHVzZXJEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gVXNlci5mcm9tU3RyaW5nKHVzZXJEYXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYWNoZVVzZXIodXNlcikge1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgdGhpcy5zdG9yZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgdXNlci50b1N0b3JhZ2VTdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JlLmNsZWFySXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0IGNsYXNzIFVzZXIge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBhY2NvdW50cywgZW1haWwsIGVtYWlsVmVyaWZpZWQsIHBob25lLCBwaG9uZU51bWJlclZlcmlmaWVkKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5hY2NvdW50cyA9IGFjY291bnRzO1xuICAgICAgICB0aGlzLmVtYWlsID0gZW1haWw7XG4gICAgICAgIHRoaXMuZW1haWxWZXJpZmllZCA9IGVtYWlsVmVyaWZpZWQ7XG4gICAgICAgIHRoaXMucGhvbmVOdW1iZXIgPSBwaG9uZTtcbiAgICAgICAgdGhpcy5waG9uZU51bWJlclZlcmlmaWVkID0gcGhvbmVOdW1iZXJWZXJpZmllZDtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Kc29uKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVc2VyKGpzb24uc3ViLCBqc29uLmFjY291bnRzLCBqc29uLmVtYWlsLCBqc29uLmVtYWlsX3ZlcmlmaWVkLCBqc29uLnBob25lX251bWJlciwganNvbi5waG9uZV9udW1iZXJfdmVyaWZpZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzKSB7XG4gICAgICAgIGxldCBwYXJzZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBKU09OLnBhcnNlKHMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZC5pZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVc2VyKHBhcnNlZC5pZCwgcGFyc2VkLmFjY291bnRzLCBwYXJzZWQuZW1haWwsIHBhcnNlZC5lbWFpbFZlcmlmaWVkLCBwYXJzZWQucGhvbmVOdW1iZXIsIHBhcnNlZC5waG9uZU51bWJlclZlcmlmaWVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRvU3RvcmFnZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgICAgICAgZW1haWw6IHRoaXMuZW1haWwsXG4gICAgICAgICAgICBlbWFpbFZlcmlmaWVkOiB0aGlzLmVtYWlsVmVyaWZpZWQsXG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHBob25lTnVtYmVyOiB0aGlzLnBob25lTnVtYmVyLFxuICAgICAgICAgICAgcGhvbmVOdW1iZXJWZXJpZmllZDogdGhpcy5waG9uZU51bWJlclZlcmlmaWVkLFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBLb3ZhbiwgTWFpbm5ldCwgUmlua2VieSB9IGZyb20gJ2JpdHNraS1wcm92aWRlcic7XG5pbXBvcnQgeyBMT0dJTl9ISU5UX1NJR05VUCB9IGZyb20gJy4vYXV0aC9vYXV0aC1tYW5hZ2VyJztcbmltcG9ydCB7IE9wZW5pZEF1dGhQcm92aWRlciB9IGZyb20gJy4vYXV0aC9vcGVuaWQtYXV0aC1wcm92aWRlcic7XG5pbXBvcnQgeyBDb25uZWN0QnV0dG9uLCBDb25uZWN0QnV0dG9uU2l6ZSB9IGZyb20gJy4vY29tcG9uZW50cy9jb25uZWN0LWJ1dHRvbic7XG5pbXBvcnQgeyBTREtfVkVSU0lPTiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IEJpdHNraUJyb3dzZXJFbmdpbmUgfSBmcm9tICcuL3Byb3ZpZGVycy9iaXRza2ktYnJvd3Nlci1lbmdpbmUnO1xuaW1wb3J0IGNzcyBmcm9tICcuL3N0eWxlcy9pbmRleCc7XG5pbXBvcnQgeyBwcm9jZXNzQ2FsbGJhY2sgfSBmcm9tICcuL3V0aWxzL2NhbGxiYWNrJztcbmltcG9ydCB7IExvY2FsU3RvcmFnZVN0b3JlIH0gZnJvbSAnLi91dGlscy9sb2NhbHN0b3JhZ2Utc3RvcmUnO1xuZXhwb3J0IHZhciBPQXV0aFNpZ25Jbk1ldGhvZDtcbihmdW5jdGlvbiAoT0F1dGhTaWduSW5NZXRob2QpIHtcbiAgICBPQXV0aFNpZ25Jbk1ldGhvZFtcIlJlZGlyZWN0XCJdID0gXCJSRURJUkVDVFwiO1xuICAgIE9BdXRoU2lnbkluTWV0aG9kW1wiUG9wdXBcIl0gPSBcIlBPUFVQXCI7XG4gICAgT0F1dGhTaWduSW5NZXRob2RbXCJTaWxlbnRcIl0gPSBcIlNJTEVOVFwiO1xufSkoT0F1dGhTaWduSW5NZXRob2QgfHwgKE9BdXRoU2lnbkluTWV0aG9kID0ge30pKTtcbmV4cG9ydCB2YXIgQXV0aGVudGljYXRpb25TdGF0dXM7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0aW9uU3RhdHVzKSB7XG4gICAgQXV0aGVudGljYXRpb25TdGF0dXNbXCJDb25uZWN0ZWRcIl0gPSBcIkNPTk5FQ1RFRFwiO1xuICAgIEF1dGhlbnRpY2F0aW9uU3RhdHVzW1wiRXhwaXJlZFwiXSA9IFwiRVhQSVJFRFwiO1xuICAgIEF1dGhlbnRpY2F0aW9uU3RhdHVzW1wiTm90Q29ubmVjdGVkXCJdID0gXCJOT1RfQ09OTkVDVEVEXCI7XG59KShBdXRoZW50aWNhdGlvblN0YXR1cyB8fCAoQXV0aGVudGljYXRpb25TdGF0dXMgPSB7fSkpO1xuLy8gQ3VzdG9taXplIHRva2VuIGFuZCB1c2VyIGNhY2hpbmdcbmV4cG9ydCB7IExvY2FsU3RvcmFnZVN0b3JlIH07XG4vLyBTaWduLWluIE9wdGlvbnNcbmV4cG9ydCB7IExPR0lOX0hJTlRfU0lHTlVQIH07XG4vLyBOZXR3b3Jrc1xuZXhwb3J0IHsgTWFpbm5ldCwgUmlua2VieSwgS292YW4gfTtcbi8vIENvbm5lY3QgQnV0dG9uXG5leHBvcnQgeyBDb25uZWN0QnV0dG9uU2l6ZSB9O1xuLy8gRXJyb3JzXG5leHBvcnQgeyBBdXRoZW50aWNhdGlvbkVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yQ29kZSB9IGZyb20gJy4vZXJyb3JzL2F1dGhlbnRpY2F0aW9uLWVycm9yJztcbmV4cG9ydCB7IFBhcnNlRXJyb3IsIFBhcnNlRXJyb3JDb2RlIH0gZnJvbSAnLi9lcnJvcnMvcGFyc2UtZXJyb3InO1xuZXhwb3J0IHsgU2lnbmVyRXJyb3IsIFNpZ25lckVycm9yQ29kZSB9IGZyb20gJy4vZXJyb3JzL3NpZ25lci1lcnJvcic7XG4vKipcbiAqIEJpdHNraSBTREtcbiAqL1xuZXhwb3J0IGNsYXNzIEJpdHNraSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNsaWVudElkIE9BdXRoIENsaWVudCBJRFxuICAgICAqIEBwYXJhbSByZWRpcmVjdFVyaSBSZWRpcmVjdCB1cmksIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IHVybC4gVGhpcyBzaG91bGQgYmUgdGhlIGxvY2F0aW9uIG9mIHlvdXIgY2FsbGJhY2sgaHRtbCBmaWxlLlxuICAgICAqIEBwYXJhbSBhZGRpdGlvbmFsU2NvcGVzIFRvIHVzZSBjdXN0b20gc2NvcGVzLCBhZGQgdGhlbSBoZXJlLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyBbJ29mZmxpbmUnXS5cbiAgICAgKiBOb3RlOiBNYWtlIHN1cmUgeW91ciBhcHAgaXMgYXBwcm92ZWQgZm9yIHRoZSBzY29wZXMgeW91IGFyZSByZXF1ZXN0aW5nIGZpcnN0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE90aGVyIE9BdXRoIHNldHRpbmdzLiBEb24ndCBjaGFuZ2UgdGhlc2UgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgcmVkaXJlY3RVcmksIGFkZGl0aW9uYWxTY29wZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lbmdpbmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNpZ25vdXRIYW5kbGVycyA9IFtdO1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIHRoaXMuc2RrVmVyc2lvbiA9IFNES19WRVJTSU9OO1xuICAgICAgICB0aGlzLmF1dGhQcm92aWRlciA9IG5ldyBPcGVuaWRBdXRoUHJvdmlkZXIoY2xpZW50SWQsIHJlZGlyZWN0VXJpIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBhZGRpdGlvbmFsU2NvcGVzLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGRvY3VtZW50ICYmIGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5qZWN0U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmluamVjdFN0eWxlcygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIuc2lnbk91dENhbGxiYWNrID0gdGhpcy5vblNpZ25PdXQuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx0ZXJuYXRpdmUgdG8gdXNpbmcgb3VyIHN0YXRpYyBjYWxsYmFjay5odG1sIGZpbGUuIENhbGwgdGhpcyBmcm9tIHlvdXIgb3duIHJlZGlyZWN0IHBhZ2UuXG4gICAgICovXG4gICAgc3RhdGljIGNhbGxiYWNrKCkge1xuICAgICAgICBwcm9jZXNzQ2FsbGJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyB3ZWIzIHByb3ZpZGVyIGZvciBhIGdpdmVuIG5ldHdvcmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgb3B0aW9ucyBmb3IgdGhlIHByb3ZpZGVyLCBvciBhIG5ldHdvcmsgbmFtZVxuICAgICAqL1xuICAgIGdldFByb3ZpZGVyKG9wdGlvbnMpIHtcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZm9yIGV4aXN0aW5nIHByb3ZpZGVyXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nUHJvdmlkZXIgPSB0aGlzLmVuZ2luZXMuZ2V0KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nUHJvdmlkZXIuc3RhcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBwcm92aWRlciBpZiBvbmUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgbGV0IG5vcm1hbGl6ZWRPcHRpb25zID0ge307XG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgbm9ybWFsaXplZE9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ldHdvcmsgPSB0aGlzLm5ldHdvcmtGcm9tUHJvdmlkZXJPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAobmV0d29yayA9PT0gS292YW4gJiYgbm9ybWFsaXplZE9wdGlvbnMubWluR2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9ybWFsaXplZE9wdGlvbnMubWluR2FzUHJpY2UgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1Byb3ZpZGVyID0gdGhpcy5jcmVhdGVQcm92aWRlcihuZXR3b3JrLCBub3JtYWxpemVkT3B0aW9ucyk7XG4gICAgICAgIG5ld1Byb3ZpZGVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMuZW5naW5lcy5zZXQoSlNPTi5zdHJpbmdpZnkob3B0aW9ucyksIG5ld1Byb3ZpZGVyKTtcbiAgICAgICAgcmV0dXJuIG5ld1Byb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2lnbiBpbiB3aXRoIGJpdHNraSBidXR0b24gdG8gYWRkIHRvIHlvdXIgYXBwLiBJZiBhbiBIVE1MIGVsZW1lbnQgaXMgcGFzc2VkIGluIGFzIHRoZVxuICAgICAqIGZpcnN0IHBhcmFtZXRlciwgaXQgd2lsbCBhdXRvbWF0aWNhbGx5IGFkZCBpdCB0byB0aGUgRE9NIGluc2lkZSB0aGF0IGVsZW1lbnQuIE1ha2Ugc3VyZSB0byBhZGRcbiAgICAgKiBhIGNhbGxiYWNrIHRvIGdldCBub3RpZmllZCBvZiBsb2dpbiBldmVudHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMge0Nvbm5lY3RCdXR0b25PcHRpb25zfSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFBvc3QtbG9naW4gY2FsbGJhY2suIENhbGxlZCB3aGVuIHNpZ24gaW4gaXMgY29tcGxldGUuIE5vdCBhcHBsaWNhYmxlIGZvciByZWRpcmVjdCBsb2dpbiBtZXRob2QuXG4gICAgICovXG4gICAgZ2V0Q29ubmVjdEJ1dHRvbihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gbmV3IENvbm5lY3RCdXR0b24odGhpcy5hdXRoUHJvdmlkZXIsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgaW4gb3IgY29ubmVjdHMgdG8gYml0c2tpIGRlcGVuZGluZyBvbiB0aGUgdXNlcidzIGF1dGggc3RhdGUuXG4gICAgICogU2luY2UgaXQgbWF5IG9wZW4gYSBwb3B1cCwgdGhpcyBtZXRob2QgbXVzdCBiZSBjYWxsZWQgZnJvbSB1c2VyIGludGVyYWN0aW9uIGhhbmRsZXIsXG4gICAgICogc3VjaCBhcyBhIGNsaWNrIG9yIHRhcCBoYW5kbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFByb3ZpZGUgU2lnbkluT3B0aW9ucyBmb3IgdGhlIHNpZ24gaW4gcmVxdWVzdC4gU2VlIHNpZ25JbigpIGZvciBtb3JlIGluZm8uXG4gICAgICovXG4gICAgc3RhcnQob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIuc2lnbkluT3JDb25uZWN0KHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBsb2dnZWQgaW4gc3RhdGUgb2YgdGhlIHVzZXJcbiAgICAgKi9cbiAgICBnZXQgYXV0aFN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLmF1dGhTdGF0dXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyB0aGUgc2lnbiBpbiBmbG93LiBXaWxsIHRyaWdnZXIgYSBwb3B1cCB3aW5kb3cgb3ZlciB5b3VyIGFwcCwgc28gaXQgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGEgdXNlciBpbnRlcmFjdGlvbiBoYW5kbGVyIHN1Y2ggYXMgYSBjbGljay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbGx5IHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgc2lnbiBpbiByZXF1ZXN0LlxuICAgICAqXG4gICAgICogWW91IGNhbiB1c2UgdGhlIG9wdGlvbnMgcGFyYW1ldGVyIHRvIHJlcXVlc3QgdGhhdCB3ZSBzaG93IHRoZSBzaWduIHVwIGZvcm0gaW5zdGVhZCBvZiB0aGUgc2lnbiBpbiBmb3JtOlxuICAgICAqIGBgYGphdmFzY3JpcHRcbiAgICAgKiBpbXBvcnQgeyBMT0dJTl9ISU5UX1NJR05VUCB9IGZyb20gJ2JpdHNraSc7XG4gICAgICpcbiAgICAgKiBhd2FpdCBiaXRza2kuc2lnbkluKHsgbG9naW5faGludDogTE9HSU5fSElOVF9TSUdOVVAgfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgc2lnbkluKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLnNpZ25JbihPQXV0aFNpZ25Jbk1ldGhvZC5Qb3B1cCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgc2lnbmVkIGluIHVzZXIuIFdpbGwgcmVqZWN0IGlmIHdlIGFyZSBub3Qgc2lnbmVkIGluLlxuICAgICAqL1xuICAgIGdldFVzZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhQcm92aWRlci5nZXRVc2VyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIHRvIGJpdHNraSB0byBnZXQgYSB2YWxpZCBhY2Nlc3MgdG9rZW4gaWYgcG9zc2libGUuXG4gICAgICovXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLmNvbm5lY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIHJlZGlyZWN0IHNpZ24gaW4gZmxvdy4gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSBmbG93IHRvIHRoZSBwb3B1cCB0aGF0IGFsbCB0YWtlcyBwbGFjZSBpbiB0aGUgc2FtZSBicm93c2VyIHdpbmRvdy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbGx5IHByb3ZpZGUgYWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgc2lnbiBpbiByZXF1ZXN0LiBTZWUgc2lnbkluKCkgZm9yIG1vcmUgaW5mby5cbiAgICAgKi9cbiAgICBzaWduSW5SZWRpcmVjdChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyLnNpZ25JbihPQXV0aFNpZ25Jbk1ldGhvZC5SZWRpcmVjdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgZnJvbSB5b3VyIG9hdXRoIHJlZGlyZWN0IHBhZ2UuXG4gICAgICovXG4gICAgcmVkaXJlY3RDYWxsYmFjaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLnJlZGlyZWN0Q2FsbGJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50IGFjY2VzcyB0b2tlbiBmb3IgdGhlIHVzZXIsIGlmIGxvZ2dlZCBpbi5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50QWNjZXNzVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1dGhQcm92aWRlci5nZXRBY2Nlc3NUb2tlbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgdGhlIGN1cnJlbnQgcmVmcmVzaCB0b2tlbiBmb3IgdGhlIHVzZXIsIGlmIGxvZ2dlZCBpbi5cbiAgICAgKiBSZXF1aXJlcyB0aGF0IHRoZSB1c2VyIGhhcyBhcHByb3ZlZCB5b3VyIGFwcGxpY2F0aW9uIGZvciBvZmZsaW5lIGFjY2Vzcy5cbiAgICAgKi9cbiAgICBnZXRDdXJyZW50UmVmcmVzaFRva2VuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIuZ2V0UmVmcmVzaFRva2VuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIHNpZ24gb3V0LiBUaGlzIGlzIGEgZ29vZCBwcmFjdGljZSxcbiAgICAgKiBzaW5jZSB0aGVyZSBtYXkgYmUgc2l0dWF0aW9ucyB3aGVyZSB5b3UgYXJlIHNpZ25lZCBvdXQgdW5leHBlY3RlZGx5LlxuICAgICAqIEBwYXJhbSBmbiBZb3VyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgYWRkU2lnbk91dEhhbmRsZXIoZm4pIHtcbiAgICAgICAgdGhpcy5zaWdub3V0SGFuZGxlcnMucHVzaChmbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHJlZ2lzdGVyZWQgc2lnbm91dCBjYWxsYmFja1xuICAgICAqIEBwYXJhbSBmbiBZb3VyIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgcmVtb3ZlU2lnbk91dEhhbmRsZXIoZm4pIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnNpZ25vdXRIYW5kbGVycy5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0gPT09IGZuKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2lnbm91dEhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbiB0aGUgY3VycmVudCB1c2VyIG91dCBvZiB5b3VyIGFwcGxpY2F0aW9uLlxuICAgICAqL1xuICAgIHNpZ25PdXQoKSB7XG4gICAgICAgIHRoaXMuZW5naW5lcy5mb3JFYWNoKChlbmdpbmUpID0+IGVuZ2luZS5zdG9wKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5hdXRoUHJvdmlkZXIuc2lnbk91dCgpO1xuICAgIH1cbiAgICBjcmVhdGVQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaXRza2lCcm93c2VyRW5naW5lKHRoaXMuY2xpZW50SWQsIHRoaXMuYXV0aFByb3ZpZGVyLCB0aGlzLnNka1ZlcnNpb24sIG5ldHdvcmssIG9wdGlvbnMpO1xuICAgIH1cbiAgICBuZXR3b3JrRnJvbU5hbWUobmV0d29ya05hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgICAgIGNhc2UgJ21haW5uZXQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBNYWlubmV0O1xuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJpbmtlYnk7XG4gICAgICAgICAgICBjYXNlICdrb3Zhbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEtvdmFuO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG5ldHdvcmsgbmFtZSAke25ldHdvcmtOYW1lfS4gVHJ5IHBhc3NpbmcgYSBcXGBuZXR3b3JrXFxgIGluIHRoZSBvcHRpb25zIGluc3RlYWQuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmV0d29ya0Zyb21Qcm92aWRlck9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBNYWlubmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5ldHdvcmtGcm9tTmFtZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5uZXR3b3JrKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5uZXR3b3JrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLm5ldHdvcmtOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXR3b3JrRnJvbU5hbWUob3B0aW9ucy5uZXR3b3JrTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1haW5uZXQ7XG4gICAgfVxuICAgIG9uU2lnbk91dCgpIHtcbiAgICAgICAgdGhpcy5zaWdub3V0SGFuZGxlcnMuZm9yRWFjaCgoY2IpID0+IHtcbiAgICAgICAgICAgIGNiKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWJlZHMgQml0c2tpJ3MgVUkgc3R5bGVzXG4gICAgICovXG4gICAgaW5qZWN0U3R5bGVzKCkge1xuICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ0JpdHNraUVtYmVkZGVkU3R5bGVzJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ0JpdHNraUVtYmVkZGVkU3R5bGVzJyk7XG4gICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgICAgICBjb25zdCBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBPQXV0aFNpZ25Jbk1ldGhvZCB9IGZyb20gJy4uL2JpdHNraSc7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvbkVycm9yLCBBdXRoZW50aWNhdGlvbkVycm9yQ29kZSB9IGZyb20gJy4uL2Vycm9ycy9hdXRoZW50aWNhdGlvbi1lcnJvcic7XG4vKipcbiAqIFNpemluZyBvcHRpb25zIGZvciB0aGUgQml0c2tpIGNvbm5lY3QgYnV0dG9uLlxuICovXG5leHBvcnQgdmFyIENvbm5lY3RCdXR0b25TaXplO1xuKGZ1bmN0aW9uIChDb25uZWN0QnV0dG9uU2l6ZSkge1xuICAgIENvbm5lY3RCdXR0b25TaXplW1wiU21hbGxcIl0gPSBcIlNNQUxMXCI7XG4gICAgQ29ubmVjdEJ1dHRvblNpemVbXCJNZWRpdW1cIl0gPSBcIk1FRElVTVwiO1xuICAgIENvbm5lY3RCdXR0b25TaXplW1wiTGFyZ2VcIl0gPSBcIkxBUkdFXCI7XG59KShDb25uZWN0QnV0dG9uU2l6ZSB8fCAoQ29ubmVjdEJ1dHRvblNpemUgPSB7fSkpO1xuLyoqXG4gKiBBIGJ1dHRvbiB1c2VkIHRvIGNvbm5lY3QgdG8gQml0c2tpLlxuICovXG5leHBvcnQgY2xhc3MgQ29ubmVjdEJ1dHRvbiB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGF1dGhQcm92aWRlciBBbiBpbnN0YW5jZSBvZiBhbiBBdXRoUHJvdmlkZXIgdG8gcHJvY2VzcyBzaWduIGluIHJlcXVlc3RzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIENvbm5lY3RCdXR0b25PcHRpb25zIHRvIGNvbmZpZ3VyZSB5b3VyIGJ1dHRvbi5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgT3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGFmdGVyIHN1Y2Nlc3NmdWwgb3IgZmFpbGVkIGxvZyBpbiBhdHRlbXB0LlxuICAgICAqIFlvdSBjYW4gYWxzbyBzZXQgdGhpcyBkaXJlY3RseSBsYXRlciB3aXRoIHRoZSBgY2FsbGJhY2tgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGF1dGhQcm92aWRlciwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gU2V0IG9wdGlvbnMgdG8gb2JqZWN0IGlmIHVuZGVmaW5lZFxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gQ29uZmlndXJlIGluc3RhbmNlXG4gICAgICAgIHRoaXMuYXV0aFByb3ZpZGVyID0gYXV0aFByb3ZpZGVyO1xuICAgICAgICB0aGlzLnNpemUgPSBvcHRpb25zLnNpemUgfHwgQ29ubmVjdEJ1dHRvblNpemUuTWVkaXVtO1xuICAgICAgICB0aGlzLmF1dGhJbnRlZ3JhdGlvblR5cGUgPSBvcHRpb25zLmF1dGhNZXRob2QgfHwgT0F1dGhTaWduSW5NZXRob2QuUG9wdXA7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5zaWduSW5PcHRpb25zID0gb3B0aW9ucy5zaWduSW5PcHRpb25zIHx8IHt9O1xuICAgICAgICAvLyBDcmVhdGUgdGhlIGVsZW1lbnRcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlRWxlbWVudCgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLnNpZ25pbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gRW1iZWQgaWYgbmVlZGVkXG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRhaW5lcikge1xuICAgICAgICAgICAgb3B0aW9ucy5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBidXR0b24gZnJvbSB0aGUgcGFnZVxuICAgICAqL1xuICAgIHJlbW92ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNpZ25pbigpIHtcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIuc2lnbkluT3JDb25uZWN0KHRoaXMuYXV0aEludGVncmF0aW9uVHlwZSwgdGhpcy5zaWduSW5PcHRpb25zKS50aGVuKCh1c2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodW5kZWZpbmVkLCB1c2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY2FuY2VsbGF0aW9uXG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBBdXRoZW50aWNhdGlvbkVycm9yICYmIGVycm9yLmNvZGUgPT09IEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlLlVzZXJDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgYSByZWFsIGVycm9yLCB0aGUgdXNlciBqdXN0IGNhbmNlbGxlZC4gVHJpZ2dlciBjYW5jZWxsYXRpb24gY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25DYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFsIGVycm9yLiBGb3J3YXJkIHRvIG1haW4gY2FsbGJhY2suXG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZUVsZW1lbnQoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC50aXRsZSA9ICdDb250aW51ZSB3aXRoIEJpdHNraSc7XG4gICAgICAgIHRoaXMuZWxlbWVudC5pbm5lclRleHQgPSAnQ29udGludWUgd2l0aCBCaXRza2knO1xuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lID0gJ2JpdHNraS1jb25uZWN0LWJ1dHRvbic7XG4gICAgICAgIGxldCBzaXplQ2xhc3MgPSAnJztcbiAgICAgICAgc3dpdGNoICh0aGlzLnNpemUpIHtcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdEJ1dHRvblNpemUuU21hbGw6XG4gICAgICAgICAgICAgICAgc2l6ZUNsYXNzID0gJ3NpemUtc21hbGwnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb25uZWN0QnV0dG9uU2l6ZS5NZWRpdW06XG4gICAgICAgICAgICAgICAgc2l6ZUNsYXNzID0gJ3NpemUtbWVkaXVtJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ29ubmVjdEJ1dHRvblNpemUuTGFyZ2U6XG4gICAgICAgICAgICAgICAgc2l6ZUNsYXNzID0gJ3NpemUtbGFyZ2UnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHNpemVDbGFzcyk7XG4gICAgfVxufVxuIiwiY29uc3QgVEVNUExBVEUgPSBgXG4gIDxkaXYgY2xhc3M9J2JpdHNraS1kaWFsb2cnPlxuICAgICAgPGJ1dHRvbiBjbGFzcz0nYml0c2tpLWNsb3NlLWJ1dHRvbic+Q2xvc2U8L2J1dHRvbj5cbiAgICAgIDxkaXYgY2xhc3M9J2JpdHNraS1kaWFsb2ctYm9keSc+PC9kaXY+XG4gIDwvZGl2PlxuYDtcbi8qKlxuICogQmFzaWMgbW9kYWwgZGlhbG9nXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWFsb2cge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIGRpc3BsYXlzIGEgbmV3IGRpYWxvZ1xuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBjb250ZW50IChIVE1MRWxlbWVudCwgc2VsZWN0b3IsIG9yIHRleHQpIHRvIGVtYmVkIGluIHRoZSBkaWFsb2dcbiAgICAgKiBAcGFyYW0gZHluYW1pY0NvbnRlbnQgU2V0IHRvIHRydWUgdG8gc2hvdyBsb2FkaW5nIHN0YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udGVudCwgZHluYW1pY0NvbnRlbnQgPSBmYWxzZSkge1xuICAgICAgICAvLyBjaGVjayBmb3IgYW4gZWxlbWVudCBwYXNzZWQgYXMgY29udGVudCBvciBhIHNlbGVjdG9yIGNvcnJlc3BvbmRpbmcgdG8gYW4gZWxlbWVudFxuICAgICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLnBhcnNlQ29udGVudChjb250ZW50KTtcbiAgICAgICAgLy8gRmluZCBvciBjcmVhdGUgZGlhbG9nIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICAgIC8vIEluamVjdCBkaWFsb2cgY29udGVudFxuICAgICAgICB0aGlzLmluamVjdFRlbXBsYXRlKHRoaXMuY29udGFpbmVyLCB0aGlzLmNvbnRlbnQpO1xuICAgICAgICAvLyBTaG93IGEgc3Bpbm5lciBpZiBjb250ZW50IGlzIGR5bmFtaWNcbiAgICAgICAgaWYgKGR5bmFtaWNDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNsb3NlIGhhbmRsZXJzXG4gICAgICAgIHRoaXMuYWRkQ2xvc2VIYW5kbGVycygpO1xuICAgICAgICAvLyBBIHNob3J0IGRlbGF5IGlzIHJlcXVpcmVkIGJlZm9yZSB0cmlnZ2VyaW5nIGFuaW1hdGlvbnNcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuc2hvdygpOyB9LCAxMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3cgdGhlIGRpYWxvZ1xuICAgICAqL1xuICAgIHNob3coKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2JpdHNraS12aXNpYmxlJywgJ2JpdHNraS1sb2FkZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGRpYWxvZywgYnV0IGRvZXMgbm90IHJlbW92ZVxuICAgICAqL1xuICAgIGhpZGUoKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2JpdHNraS12aXNpYmxlJywgJ2JpdHNraS1sb2FkZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzbWlzc2VzIHRoZSBkaWFsb2cgd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBjbG9zZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIGRpc21pc3MoKSB7XG4gICAgICAgIC8vIEFsbG93IDUwMG1zIGZvciB0aGUgYW5pbWF0aW9ucyB0byBmaW5pc2ggYmVmb3JlIHJlbW92aW5nIGVsZW1lbnRzIGZyb20gRE9NXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNvbnRhaW5lci5yZW1vdmUoKTsgfSwgNTAwKTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgdGhlIGRpYWxvZyBieSBkaXNtaXNzaW5nIGFuZCB0cmlnZ2VyaW5nIHRoZSBjbG9zZSBoYW5kbGVyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmRpc21pc3MoKTtcbiAgICAgICAgaWYgKHRoaXMub25DbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvdyBvciBoaWRlIHRoZSBsb2FkaW5nIGluZGljYXRvclxuICAgICAqIEBwYXJhbSBsb2FkaW5nIFdoZXRoZXIgb3Igbm90IHRvIGRpc3BsYXkgdGhlIHNwaW5uZXJcbiAgICAgKi9cbiAgICBzZXRMb2FkaW5nKGxvYWRpbmcpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5iaXRza2ktZGlhbG9nLWJvZHknKTtcbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIGlmIChsb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgYm9keS5jbGFzc0xpc3QuYWRkKCdiaXRza2ktbG9hZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdiaXRza2ktbG9hZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hhdCBjb250ZW50IHRvIGVtYmVkXG4gICAgICogQHBhcmFtIGNvbnRlbnQgQ29udGVudCB0byBwYXJzZVxuICAgICAqL1xuICAgIHBhcnNlQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbiBlbGVtZW50IHBhc3NlZCBhcyBjb250ZW50XG4gICAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIGRldGVybWluZSBpZiBjb250ZW50IGlzIGEgc2VsZWN0b3JcbiAgICAgICAgaWYgKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSBjb250ZW50IGlzIHRleHQgdG8gYmUgYXBwZW5kZWQgdG8gdGhlIGRpYWxvZyBib2R5XG4gICAgICAgIGNvbnN0IGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBkaXYuaW5uZXJUZXh0ID0gY29udGVudDtcbiAgICAgICAgcmV0dXJuIGRpdjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgaW5qZWN0cyB0aGUgY29udGFpbmVyIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgYm9keSxcbiAgICAgKiByZXNwb25zaWJsZSBmb3IgaG91c2luZyBhbGwgdGhlIGRpYWxvZy1yZWxhdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgICBjb25zdCBleGlzdGluZ0NvbnRhaW5lciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNiaXRza2ktZGlhbG9nLWNvbnRhaW5lcicpO1xuICAgICAgICBpZiAoZXhpc3RpbmdDb250YWluZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0NvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmlkID0gJ2JpdHNraS1kaWFsb2ctY29udGFpbmVyJztcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb250YWluZXIpO1xuICAgICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmplY3RzIHRoZSBwcm92aWRlZCBjb250ZW50IGludG8gdGhlIHRlbXBsYXRlIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIGNvbnRhaW5lciBUaGUgY29udGFpbmVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgY29udGVudCB0byBpbmplY3QgaW4gdGhlIHRlbXBsYXRlXG4gICAgICovXG4gICAgaW5qZWN0VGVtcGxhdGUoY29udGFpbmVyLCBjb250ZW50KSB7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSBURU1QTEFURTtcbiAgICAgICAgY29uc3QgYm9keSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuYml0c2tpLWRpYWxvZy1ib2R5Jyk7XG4gICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICBib2R5LmFwcGVuZENoaWxkKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciBldmVudHMgdGhhdCBzaG91bGQgdHJpZ2dlciBjbG9zaW5nIHRoZSBkaWFsb2dcbiAgICAgKi9cbiAgICBhZGRDbG9zZUhhbmRsZXJzKCkge1xuICAgICAgICAvLyBDbG9zZSBvbiBjbGljayBvdXRzaWRlIG9mIHRoZSBkaWFsb2dcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ2xvc2Ugb24gZXNjYXBlIHByZXNzXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDbG9zZSBvbiBjbG9zZSBidXR0b24gY2xpY2tcbiAgICAgICAgY29uc3QgY2xvc2VCdXR0b24gPSB0aGlzLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuYml0c2tpLWNsb3NlLWJ1dHRvbicpO1xuICAgICAgICBpZiAoY2xvc2VCdXR0b24pIHtcbiAgICAgICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIFNES1xuZXhwb3J0IGNvbnN0IFNES19WRVJTSU9OID0gJzAuMTAuNyc7XG4vLyBVUkxzXG5leHBvcnQgY29uc3QgQklUU0tJX1VTRVJfQVBJX0hPU1QgPSAnaHR0cHM6Ly93d3cuYml0c2tpLmNvbS92MSc7XG5leHBvcnQgY29uc3QgQklUU0tJX1RSQU5TQUNUSU9OX0FQSV9CQVNFX1VSTCA9ICdodHRwczovL2FwaS5iaXRza2kuY29tL3YxJztcbmV4cG9ydCBjb25zdCBCSVRTS0lfUlBDX0JBU0VfVVJMID0gJ2h0dHBzOi8vYXBpLmJpdHNraS5jb20vdjEvd2ViMyc7XG5leHBvcnQgY29uc3QgQklUU0tJX1dFQl9CQVNFX1VSTCA9ICdodHRwczovL3NpZ24uYml0c2tpLmNvbSc7XG5leHBvcnQgY29uc3QgSUZSQU1FX01FU1NBR0VfT1JJR0lOX0lOQ0xVREVTID0gJy5iaXRza2kuY29tJztcbi8vIE9BdXRoXG5leHBvcnQgY29uc3QgREVGQVVMVF9PQVVUSF9DT05GSUdVUkFUSU9OID0ge1xuICAgIGF1dGhvcml6YXRpb25fZW5kcG9pbnQ6ICdodHRwczovL2FjY291bnQuYml0c2tpLmNvbS9vYXV0aDIvYXV0aCcsXG4gICAgcmV2b2NhdGlvbl9lbmRwb2ludDogJycsXG4gICAgdG9rZW5fZW5kcG9pbnQ6ICdodHRwczovL2FjY291bnQuYml0c2tpLmNvbS9vYXV0aDIvdG9rZW4nLFxuICAgIHVzZXJpbmZvX2VuZHBvaW50OiAnaHR0cHM6Ly9hY2NvdW50LmJpdHNraS5jb20vdXNlcmluZm8nLFxufTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1NDT1BFUyA9IFsnb3BlbmlkJ107IC8vIHNjb3BlcyB0aGF0IGFyZSBhbHdheXMgaW5jbHVkZWRcbmV4cG9ydCBjb25zdCBERUZBVUxUX09QVElPTkFMX1NDT1BFUyA9IFsnb2ZmbGluZSddOyAvLyBzY29wZXMgdGhhdCBhcmUgaW5jbHVkZWQgYnkgZGVmYXVsdCwgYnV0IGNhbiBiZSBvdmVycmlkZGVuXG4vLyBQb3B1cCBXaW5kb3dcbmV4cG9ydCBjb25zdCBDSEVDS19GT1JfUE9QVVBfQ0xPU0VfSU5URVJWQUwgPSA1MDA7XG5leHBvcnQgY29uc3QgREVGQVVMVF9QT1BVUF9GRUFUVVJFUyA9IHtcbiAgICBsb2NhdGlvbjogJ25vJyxcbiAgICB0b29sYmFyOiAnbm8nLFxuICAgIHdpZHRoOiA1MDAsXG4gICAgaGVpZ2h0OiA1MDAsXG4gICAgbGVmdDogMTAwLFxuICAgIHRvcDogMTAwLFxufTtcbi8vIFN0b3JhZ2VcbmV4cG9ydCBjb25zdCBSRUZSRVNIX1RPS0VOX0tFWSA9ICdiaXRza2kucmVmcmVzaF90b2tlbic7XG5leHBvcnQgY29uc3QgQUNDRVNTX1RPS0VOX0tFWSA9ICdiaXRza2kuYWNjZXNzX3Rva2VuJztcbmV4cG9ydCBjb25zdCBVU0VSX0tFWSA9ICdiaXRza2kudXNlcic7XG4vLyBNZXRob2RzXG5leHBvcnQgY29uc3QgQ0FDSEVEX01FVEhPRFMgPSBbJ2V0aF9hY2NvdW50cyddO1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQVVUSE9SSVpFRF9NRVRIT0RTID0gW1xuICAgICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAnZXRoX3NpZ25UcmFuc2FjdGlvbicsXG4gICAgJ2V0aF9zaWduJyxcbiAgICAncGVyc29uYWxfc2lnbicsXG4gICAgJ2V0aF9zaWduVHlwZWREYXRhJyxcbiAgICAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuXTtcbiIsImV4cG9ydCB2YXIgQXV0aGVudGljYXRpb25FcnJvckNvZGU7XG4oZnVuY3Rpb24gKEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlKSB7XG4gICAgLy8gVGhlIHVzZXIgaXMgbm90IGN1cnJlbnRseSBzaWduZWQgaW5cbiAgICBBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtcIk5vdFNpZ25lZEluXCJdID0gMTAwMF0gPSBcIk5vdFNpZ25lZEluXCI7XG4gICAgLy8gVGhlIHVzZXIgY2FuY2VsbGVkIHRoZSBhdXRoIHJlcXVlc3RcbiAgICBBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtcIlVzZXJDYW5jZWxsZWRcIl0gPSAxMDAxXSA9IFwiVXNlckNhbmNlbGxlZFwiO1xuICAgIC8vIEVpdGhlciB5b3UgZGlkIG5vdCByZXF1ZXN0IG9mZmxpbmUgYWNjZXNzLCBvciB0aGUgdXNlciBkaWQgbm90IGFwcHJvdmUgeW91ciBhcHAgZm9yIG9mZmxpbmUgYWNjZXNzXG4gICAgQXV0aGVudGljYXRpb25FcnJvckNvZGVbQXV0aGVudGljYXRpb25FcnJvckNvZGVbXCJOb1JlZnJlc2hUb2tlblwiXSA9IDEwMDJdID0gXCJOb1JlZnJlc2hUb2tlblwiO1xuICAgIC8vIFlvdSByZXF1ZXN0ZWQgc2lsZW50IHNpZ24gaW4sIHdoaWNoIGlzIGRlcHJlY2F0ZWRcbiAgICBBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtcIlVuc3VwcG9ydGVkQXV0aGVudGljYXRpb25NZXRob2RcIl0gPSAxMDAzXSA9IFwiVW5zdXBwb3J0ZWRBdXRoZW50aWNhdGlvbk1ldGhvZFwiO1xuICAgIC8vIFdlIHJlY2VpdmVkIGFuIGVycm9yIGZyb20gdGhlIG9hdXRoIHNlcnZlclxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW0F1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW1wiU2VydmVyRXJyb3JcIl0gPSAxMDA0XSA9IFwiU2VydmVyRXJyb3JcIjtcbiAgICAvLyBUaGUgU0RLIGlzIGNvbmZpZ3VyZWQgaW5jb3JyZWN0bHlcbiAgICBBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtBdXRoZW50aWNhdGlvbkVycm9yQ29kZVtcIkludmFsaWRDb25maWd1cmF0aW9uXCJdID0gMTAwNV0gPSBcIkludmFsaWRDb25maWd1cmF0aW9uXCI7XG4gICAgLy8gUG9wdXAgYmxvY2tlZFxuICAgIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW0F1dGhlbnRpY2F0aW9uRXJyb3JDb2RlW1wiUG9wdXBCbG9ja2VkXCJdID0gMTAwNl0gPSBcIlBvcHVwQmxvY2tlZFwiO1xufSkoQXV0aGVudGljYXRpb25FcnJvckNvZGUgfHwgKEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IGlzIHRocm93biBkdXJpbmcgdGhlIGF1dGhlbnRpY2F0aW9uIHByb2Nlc3NcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0F1dGhlbnRpY2F0aW9uRXJyb3InO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgQXV0aGVudGljYXRpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG4gICAgLy8gdGhyb3cgQXV0aGVudGljYXRpb25FcnJvci5Ob3RTaWduZWRJbigpXG4gICAgc3RhdGljIE5vdFNpZ25lZEluKCkge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoJ05vdCBzaWduZWQgaW4uJywgQXV0aGVudGljYXRpb25FcnJvckNvZGUuTm90U2lnbmVkSW4pO1xuICAgIH1cbiAgICAvLyB0aHJvdyBBdXRoZW50aWNhdGlvbkVycm9yLlVzZXJDYW5jZWxsZWQoKVxuICAgIHN0YXRpYyBVc2VyQ2FuY2VsbGVkKCkge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoJ1NpZ24gaW4gcmVxdWVzdCB3YXMgY2FuY2VsbGVkLicsIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlLlVzZXJDYW5jZWxsZWQpO1xuICAgIH1cbiAgICAvLyB0aHJvdyBBdXRoZW50aWNhdGlvbkVycm9yLk5vUmVmcmVzaFRva2VuKClcbiAgICBzdGF0aWMgTm9SZWZyZXNoVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcignUmVmcmVzaCB0b2tlbiBpcyBub3QgYXZhaWxhYmxlLicsIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlLk5vUmVmcmVzaFRva2VuKTtcbiAgICB9XG4gICAgLy8gdGhyb3cgQXV0aGVudGljYXRpb25FcnJvci5VbnN1cHBvcnRlZEF1dGhlbnRpY2F0aW9uTWV0aG9kKClcbiAgICBzdGF0aWMgVW5zdXBwb3J0ZWRBdXRoZW50aWNhdGlvbk1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKCdTaWduIGluIG1ldGhvZCBub3Qgc3VwcG9ydGVkLicsIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlLlVuc3VwcG9ydGVkQXV0aGVudGljYXRpb25NZXRob2QpO1xuICAgIH1cbiAgICAvLyB0aHJvdyBBdXRoZW50aWNhdGlvbkVycm9yLlBvcHVwQmxvY2tlZCgpXG4gICAgc3RhdGljIFBvcHVwQmxvY2tlZChiYXNlVXJsKSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUaGUgcG9wdXAgd2FzIGJsb2NrZWQuIFBsZWFzZSBtYWtlIHN1cmUgJHtiYXNlVXJsfSBpcyBhbGxvd2VkIHRvIG9wZW4gcG9wdXBzLmA7XG4gICAgICAgIHJldHVybiBuZXcgQXV0aGVudGljYXRpb25FcnJvcihtc2csIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlLlBvcHVwQmxvY2tlZCk7XG4gICAgfVxuICAgIC8vIHRocm93IEF1dGhlbnRpY2F0aW9uIEVycm9yLlNlcnZlckVycm9yKG1lc3NhZ2UsIGRlc2NyaXB0aW9uKVxuICAgIHN0YXRpYyBTZXJ2ZXJFcnJvcihtZXNzYWdlLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgRXJyb3IgZnJvbSB0aGUgc2VydmVyOiAke21lc3NhZ2V9YCwgQXV0aGVudGljYXRpb25FcnJvckNvZGUuU2VydmVyRXJyb3IpO1xuICAgICAgICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgLy8gdGhyb3cgQXV0aGVudGljYXRpb25FcnJvci5JbnZhbGlkQ29uZmlndXJhdGlvbigpXG4gICAgc3RhdGljIEludmFsaWRDb25maWd1cmF0aW9uKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoYFRoZSBPQXV0aCBDb25maWd1cmF0aW9uIGlzIGludmFsaWQ6ICR7cmVhc29ufWAsIEF1dGhlbnRpY2F0aW9uRXJyb3JDb2RlLkludmFsaWRDb25maWd1cmF0aW9uKTtcbiAgICB9XG59XG4iLCJleHBvcnQgdmFyIFBhcnNlRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChQYXJzZUVycm9yQ29kZSkge1xuICAgIC8vIENvdWxkIG5vdCBwYXJzZSByZXNwb25zZSBhcyBKU09OXG4gICAgUGFyc2VFcnJvckNvZGVbUGFyc2VFcnJvckNvZGVbXCJJbnZhbGlkSlNPTlwiXSA9IDIwMDBdID0gXCJJbnZhbGlkSlNPTlwiO1xuICAgIC8vIFJlY2VpdmVkIGFuIGVycm9yIHJlc3BvbnNlIHN0YXR1cyxcbiAgICAvLyBidXQgbm90IGVycm9yIGJvZHkgd2FzIHByb3ZpZGVkLlxuICAgIFBhcnNlRXJyb3JDb2RlW1BhcnNlRXJyb3JDb2RlW1wiTm9FcnJvckJvZHlcIl0gPSAyMDAxXSA9IFwiTm9FcnJvckJvZHlcIjtcbn0pKFBhcnNlRXJyb3JDb2RlIHx8IChQYXJzZUVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgYW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gZHVyaW5nIGRlY29kaW5nXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdQYXJzZUVycm9yJztcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFBhcnNlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHN0YXRpYyBJbnZhbGlkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHJlc3BvbnNlIGFzIEpTT04nLCBQYXJzZUVycm9yQ29kZS5JbnZhbGlkSlNPTik7XG4gICAgfVxuICAgIHN0YXRpYyBVbmtub3duRXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFyc2VFcnJvcignQW4gdW5rbm93biBlcnJvciBvY2N1cnJlZC4nLCBQYXJzZUVycm9yQ29kZS5Ob0Vycm9yQm9keSk7XG4gICAgfVxufVxuIiwiZXhwb3J0IHZhciBTaWduZXJFcnJvckNvZGU7XG4oZnVuY3Rpb24gKFNpZ25lckVycm9yQ29kZSkge1xuICAgIC8vIFRoZSBzaWduZXIgbW9kdWxlIHJlY2VpdmVkIGEgcmVxdWVzdCB0byBzaWduIHZpYSBhbiB1bnN1cHBvcnRlZCBSUEMgbWV0aG9kXG4gICAgU2lnbmVyRXJyb3JDb2RlW1NpZ25lckVycm9yQ29kZVtcIlVuc3VwcG9ydGVkTWV0aG9kXCJdID0gMzAwMF0gPSBcIlVuc3VwcG9ydGVkTWV0aG9kXCI7XG4gICAgLy8gVGhlIHVzZXIgY2FuY2VsbGVkIG9yIHJlamVjdGVkIHRoZSB0cmFuc2FjdGlvblxuICAgIFNpZ25lckVycm9yQ29kZVtTaWduZXJFcnJvckNvZGVbXCJVc2VyQ2FuY2VsbGVkXCJdID0gMzAwMV0gPSBcIlVzZXJDYW5jZWxsZWRcIjtcbiAgICAvLyBUaGUgcmVxdWVzdCBpcyBtaXNzaW5nIHBhcmFtcyBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgIC8vIENoZWNrIHRoYXQgcGFyYW1zIGlzIGFuIGFycmF5LCBhbmQgdGhlIHRyYW5zYWN0aW9uIGlzIHRoZSBmaXJzdCBvYmplY3QuXG4gICAgU2lnbmVyRXJyb3JDb2RlW1NpZ25lckVycm9yQ29kZVtcIk1pc3NpbmdUcmFuc2FjdGlvblwiXSA9IDMwMDJdID0gXCJNaXNzaW5nVHJhbnNhY3Rpb25cIjtcbiAgICAvLyBUaGUgbWVzc2FnZSBzaWduYXR1cmUgcmVxdWVzdCBpcyBtaXNzaW5nIGV4cGVjdGVkIHBhcmFtcy5cbiAgICAvLyBDaGVjayB0aGF0IHBhcmFtcyBpcyBhbiBhcnJheSwgYW5kIHRoYXQgdGhleSBpbmNsdWRlIGJvdGggYSBmcm9tIGFkZHJlc3MsIGFuZCBhIG1lc3NhZ2UgdG8gc2lnbi5cbiAgICBTaWduZXJFcnJvckNvZGVbU2lnbmVyRXJyb3JDb2RlW1wiTWlzc2luZ01lc3NhZ2VcIl0gPSAzMDAzXSA9IFwiTWlzc2luZ01lc3NhZ2VcIjtcbiAgICAvLyBNaXNzaW5nIGZyb20gYWRkcmVzcyBpbiB0eXBlZCBkYXRhIHJlcXVlc3RcbiAgICBTaWduZXJFcnJvckNvZGVbU2lnbmVyRXJyb3JDb2RlW1wiTWlzc2luZ0Zyb21cIl0gPSAzMDA0XSA9IFwiTWlzc2luZ0Zyb21cIjtcbiAgICAvLyBNaXNzaW5nIHR5cGVkIGRhdGEgcGFyYW1zLiBNYWtlIHN1cmUgcGFyYW1zIGlzIGFuIGFycmF5IGFuZCBpbmNsdWRlc1xuICAgIC8vIGJvdGggYSBmcm9tIGFkZHJlc3MsIGFuZCBhIHR5cGVkIGRhdGEgcGF5bG9hZC5cbiAgICBTaWduZXJFcnJvckNvZGVbU2lnbmVyRXJyb3JDb2RlW1wiTWlzc2luZ1R5cGVkRGF0YVwiXSA9IDMwMDVdID0gXCJNaXNzaW5nVHlwZWREYXRhXCI7XG59KShTaWduZXJFcnJvckNvZGUgfHwgKFNpZ25lckVycm9yQ29kZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgU2lnbmVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1RyYW5zYWN0aW9uRXJyb3InO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU2lnbmVyRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxuICAgIHN0YXRpYyBVbnN1cHBvcnRlZE1ldGhvZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduZXJFcnJvcignVGhlIG1ldGhvZCByZXF1ZXN0ZWQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuJywgU2lnbmVyRXJyb3JDb2RlLlVuc3VwcG9ydGVkTWV0aG9kKTtcbiAgICB9XG4gICAgc3RhdGljIFVzZXJDYW5jZWxsZWQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2lnbmVyRXJyb3IoJ1RoZSB1c2VyIGNhbmNlbGxlZCB0aGlzIHRyYW5zYWN0aW9uJywgU2lnbmVyRXJyb3JDb2RlLlVzZXJDYW5jZWxsZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgTWlzc2luZ1RyYW5zYWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lckVycm9yKCdDb3VsZCBub3QgZmluZCB0cmFuc2FjdGlvbiBpbiByZXF1ZXN0JywgU2lnbmVyRXJyb3JDb2RlLk1pc3NpbmdUcmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHN0YXRpYyBNaXNzaW5nTWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduZXJFcnJvcignQ291bGQgbm90IGZpbmQgbWVzc2FnZSBwYXJhbXMgaW4gcmVxdWVzdCcsIFNpZ25lckVycm9yQ29kZS5NaXNzaW5nTWVzc2FnZSk7XG4gICAgfVxuICAgIHN0YXRpYyBNaXNzaW5nRnJvbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaWduZXJFcnJvcignQ291bGQgbm90IGZpbmQgZnJvbSBhZGRyZXNzIGluIHJlcXVlc3QgcGFyYW1zLicsIFNpZ25lckVycm9yQ29kZS5NaXNzaW5nRnJvbSk7XG4gICAgfVxuICAgIHN0YXRpYyBNaXNzaW5nVHlwZWREYXRhKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNpZ25lckVycm9yKCdDb3VsZCBub3QgZmluZCBkYXRhIHRvIHNpZ24gaW4gcmVxdWVzdCBwYXJhbXMuJywgU2lnbmVyRXJyb3JDb2RlLk1pc3NpbmdUeXBlZERhdGEpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEF1dGhlbnRpY2F0ZWRGZXRjaFN1YnByb3ZpZGVyLCBCaXRza2lFbmdpbmUgfSBmcm9tICdiaXRza2ktcHJvdmlkZXInO1xuaW1wb3J0IHsgQklUU0tJX1JQQ19CQVNFX1VSTCwgQklUU0tJX1RSQU5TQUNUSU9OX0FQSV9CQVNFX1VSTCwgQklUU0tJX1dFQl9CQVNFX1VSTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBCaXRza2lUcmFuc2FjdGlvblNpZ25lciB9IGZyb20gJy4uL3NpZ25pbmcvdHJhbnNhY3Rpb24tc2lnbmVyJztcbmltcG9ydCB7IEF1dGhlbnRpY2F0ZWRDYWNoZVN1YnByb3ZpZGVyIH0gZnJvbSAnLi4vc3VicHJvdmlkZXJzL2F1dGhlbnRpY2F0ZWQtY2FjaGUnO1xuaW1wb3J0IHsgUmVtb3RlQWNjb3VudFN1YnByb3ZpZGVyIH0gZnJvbSAnLi4vc3VicHJvdmlkZXJzL3JlbW90ZS1hY2NvdW50cyc7XG5pbXBvcnQgeyBTaWduYXR1cmVTdWJwcm92aWRlciB9IGZyb20gJy4uL3N1YnByb3ZpZGVycy9zaWduYXR1cmUnO1xuLy8gUHJlZGljYXRlIHRvIGRldGVybWluZSBpZiB0aGUgdG9rZW4gcHJvdmlkZXIgaXMgYW4gQXV0aFByb3ZpZGVyXG5mdW5jdGlvbiBpc0F1dGhQcm92aWRlcihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0LmdldFVzZXIgIT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBjbGFzcyBCaXRza2lCcm93c2VyRW5naW5lIGV4dGVuZHMgQml0c2tpRW5naW5lIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnRJZCwgdG9rZW5Qcm92aWRlciwgc2RrVmVyc2lvbiwgbmV0d29yaywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdGhpcy5uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgdGhpcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICB0aGlzLnNka1ZlcnNpb24gPSBzZGtWZXJzaW9uO1xuICAgICAgICB0aGlzLmFwaUJhc2VVcmwgPSBvcHRpb25zLmFwaUJhc2VVcmwgfHwgQklUU0tJX1RSQU5TQUNUSU9OX0FQSV9CQVNFX1VSTDtcbiAgICAgICAgdGhpcy53ZWJCYXNlVXJsID0gb3B0aW9ucy53ZWJCYXNlVXJsIHx8IEJJVFNLSV9XRUJfQkFTRV9VUkw7XG4gICAgICAgIHRoaXMudG9rZW5Qcm92aWRlciA9IHRva2VuUHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRCaXRza2lIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ1gtQVBJLUtFWSc6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAnWC1DTElFTlQtSUQnOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgJ1gtQ0xJRU5ULVZFUlNJT04nOiB0aGlzLnNka1ZlcnNpb24sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGRlZmF1bHRCaXRza2lIZWFkZXJzO1xuICAgICAgICB0aGlzLnJwY0hlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hZGRpdGlvbmFsSGVhZGVycykge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5hZGRpdGlvbmFsSGVhZGVycywgdGhpcy5oZWFkZXJzKTtcbiAgICAgICAgICAgIHRoaXMucnBjSGVhZGVycyA9IG9wdGlvbnMuYWRkaXRpb25hbEhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV0d29yayAmJiB0aGlzLm5ldHdvcmsucnBjVXJsLmluY2x1ZGVzKCdiaXRza2kuY29tJykpIHtcbiAgICAgICAgICAgIHRoaXMucnBjSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucnBjSGVhZGVycywgZGVmYXVsdEJpdHNraUhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lnbmVyID0gbmV3IEJpdHNraVRyYW5zYWN0aW9uU2lnbmVyKHRoaXMud2ViQmFzZVVybCwgdGhpcy5hcGlCYXNlVXJsLCB0aGlzLmhlYWRlcnMsIG9wdGlvbnMuY2FsbGJhY2tVUkwpO1xuICAgICAgICB0aGlzLmFkZFN1YnByb3ZpZGVycygpO1xuICAgIH1cbiAgICBhZGRTdWJwcm92aWRlcnMoKSB7XG4gICAgICAgIC8vIFVzZWQgZm9yIGV0aF9hY2NvdW50cyBjYWxsc1xuICAgICAgICBjb25zdCBhY2NvdW50c1Byb3ZpZGVyID0gbmV3IFJlbW90ZUFjY291bnRTdWJwcm92aWRlcihgJHtCSVRTS0lfUlBDX0JBU0VfVVJMfS9tYWlubmV0YCwgZmFsc2UsIHRoaXMudG9rZW5Qcm92aWRlciwgdGhpcy5oZWFkZXJzKTtcbiAgICAgICAgLy8gVXNlZCBmb3IgYWxsIG90aGVyIGNhbGxzXG4gICAgICAgIGNvbnN0IGZldGNoU3VicHJvdmlkZXIgPSBuZXcgQXV0aGVudGljYXRlZEZldGNoU3VicHJvdmlkZXIodGhpcy5uZXR3b3JrLnJwY1VybCwgZmFsc2UsIHRoaXMudG9rZW5Qcm92aWRlciwgdGhpcy5ycGNIZWFkZXJzKTtcbiAgICAgICAgLy8gUmVzcG9uZCB0byBzb21lIHJlcXVlc3RzIHZpYSB1c2VyaW5mbyBvYmplY3QgaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChpc0F1dGhQcm92aWRlcih0aGlzLnRva2VuUHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWNoZVN1YnByb3ZpZGVyID0gbmV3IEF1dGhlbnRpY2F0ZWRDYWNoZVN1YnByb3ZpZGVyKHRoaXMudG9rZW5Qcm92aWRlcik7XG4gICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKGNhY2hlU3VicHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHdoZW5ldmVyIGFjY291bnRzIGFyZSByZXF1ZXN0ZWQsIHRoZXkgZ28gdGhyb3VnaCBCaXRza2lcbiAgICAgICAgdGhpcy5hZGRQcm92aWRlcihhY2NvdW50c1Byb3ZpZGVyKTtcbiAgICAgICAgLy8gUmVzcG9uZCB0byByZXF1ZXN0cyB0aGF0IG5lZWQgc2lnbmVkIHdpdGggYW4gaWZyYW1lXG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZVN1YnByb3ZpZGVyID0gbmV3IFNpZ25hdHVyZVN1YnByb3ZpZGVyKHRoaXMubmV0d29yaywgdGhpcy5zaWduZXIsIHRoaXMudG9rZW5Qcm92aWRlcik7XG4gICAgICAgIHRoaXMuYWRkUHJvdmlkZXIoc2lnbmF0dXJlU3VicHJvdmlkZXIpO1xuICAgICAgICAvLyBGaW5hbGx5LCBhZGQgb3VyIGJhc2ljIEhUVFAgcHJvdmlkZXJcbiAgICAgICAgdGhpcy5hZGRQcm92aWRlcihmZXRjaFN1YnByb3ZpZGVyKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBEaWFsb2cgfSBmcm9tICcuLi9jb21wb25lbnRzL2RpYWxvZyc7XG5pbXBvcnQgeyBJRlJBTUVfTUVTU0FHRV9PUklHSU5fSU5DTFVERVMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgU2lnbmVyRXJyb3IgfSBmcm9tICcuLi9lcnJvcnMvc2lnbmVyLWVycm9yJztcbmltcG9ydCB7IHBhcnNlUmVzcG9uc2UgfSBmcm9tICcuLi91dGlscy9yZXF1ZXN0LXV0aWxzJztcbi8qKlxuICogVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuIEl0IG9ubHkga25vd3MgYWJvdXQgQml0c2tpJ3MgcHJvcHJpZXRhcnkgdHJhbnNhY3Rpb24gb2JqZWN0cy5cbiAqIEl0IGlzIGFsc28gdGhlIG9ubHkgY2xhc3MgdGhhdCBrbm93cyBhYm91dCB0aGUgaWZyYW1lIHNpZ25pbmcgaW1wbGVtZW50YXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBCaXRza2lUcmFuc2FjdGlvblNpZ25lciB7XG4gICAgY29uc3RydWN0b3Iod2ViQmFzZVVybCwgYXBpQmFzZVVybCwgZGVmYXVsdEhlYWRlcnMsIGNhbGxiYWNrVVJMKSB7XG4gICAgICAgIHRoaXMud2ViQmFzZVVybCA9IHdlYkJhc2VVcmw7XG4gICAgICAgIHRoaXMuYXBpQmFzZVVybCA9IGFwaUJhc2VVcmw7XG4gICAgICAgIHRoaXMuZGVmYXVsdEhlYWRlcnMgPSBkZWZhdWx0SGVhZGVycztcbiAgICAgICAgdGhpcy5jYWxsYmFja1VSTCA9IGNhbGxiYWNrVVJMO1xuICAgICAgICAvLyBXYXRjaCBmb3IgbmV3IG1lc3NhZ2VzIG9uIHRoZSB3aW5kb3cuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5yZWNlaXZlTWVzc2FnZS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgfVxuICAgIGFzeW5jIHNpZ24odHJhbnNhY3Rpb24sIGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIC8vIFN1Ym1pdCB0cmFuc2FjdGlvbiB0byBBUElcbiAgICAgICAgY29uc3QgcGVyc2lzdGVkID0gYXdhaXQgdGhpcy5zdWJtaXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgY2FsbGJhY2sgVVJMLCB1c2UgdGhlIHJlZGlyZWN0IGZsb3dcbiAgICAgICAgaWYgKHRoaXMuY2FsbGJhY2tVUkwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZGlyZWN0VG9DYWxsYmFja1VSTChwZXJzaXN0ZWQudHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNob3cgdGhlIG1vZGFsIChhd2FpdCByZXNwb25zZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvd0F1dGhvcml6YXRpb25Nb2RhbChwZXJzaXN0ZWQudHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmVudCBsaXN0ZW5lciBmb3IgY2FsbGJhY2tzIGZyb20gdGhlIGlmcmFtZVxuICAgICAqIEBwYXJhbSBldmVudCBNZXNzYWdlRXZlbnQgcmVjZWl2ZWQgZnJvbSB0aGUgYnJvd3NlclxuICAgICAqL1xuICAgIHJlY2VpdmVNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIC8vIElnbm9yZSBtZXNzYWdlcyBmcm9tIHRoZSBjdXJyZW50IHdpbmRvdywgYW5kIGZyb20gZnJhbWVzIHRoYXQgYXJlbid0IG9uIEJpdHNraS5jb21cbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gd2luZG93IHx8ICFldmVudC5vcmlnaW4uaW5jbHVkZXMoSUZSQU1FX01FU1NBR0VfT1JJR0lOX0lOQ0xVREVTKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAvLyBJZ25vcmUgbWVzc2FnZSBldmVudHMgdGhhdCBkb24ndCBhY3R1YWxseSBoYXZlIGRhdGFcbiAgICAgICAgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIG1lc3NhZ2VzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIGN1cnJlbnQgcmVxdWVzdCBpbiBmbGlnaHRcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtmdWxmaWxsLCByZWplY3RdID0gdGhpcy5jdXJyZW50UmVxdWVzdDtcbiAgICAgICAgLy8gRGlzbWlzcyBjdXJyZW50IGRpYWxvZ1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50UmVxdWVzdERpYWxvZykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdERpYWxvZy5kaXNtaXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgdG8gY29tcGxldGUgdGhlIHJlcXVlc3RcbiAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChkYXRhLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bGZpbGwoZGF0YS5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIHN0YXRlXG4gICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY3VycmVudFJlcXVlc3REaWFsb2cgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciBzdWJtaXR0aW5nIHRoZSBUcmFuc2FjdGlvbiBvYmplY3QgdG8gdGhlIEFQSVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiBUaGUgVHJhbnNhY3Rpb24gb2JqZWN0IHRvIHN1Ym1pdFxuICAgICAqIEBwYXJhbSBhY2Nlc3NUb2tlbiBUaGUgY3VycmVudCB1c2VyJ3MgYWNjZXNzIHRva2VuXG4gICAgICovXG4gICAgYXN5bmMgc3VibWl0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGFjY2Vzc1Rva2VuKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0geyB0cmFuc2FjdGlvbiB9O1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0SGVhZGVycywge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzVG9rZW59YCxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYXBpQmFzZVVybH0vdHJhbnNhY3Rpb25zYCwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShyZXF1ZXN0Qm9keSksXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aGUgYXV0aG9yaXphdGlvbiBmb3JtIGluIGEgbW9kYWwgd2luZG93XG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIFRoZSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBiZWVuIHN1Ym1pdHRlZFxuICAgICAqL1xuICAgIHNob3dBdXRob3JpemF0aW9uTW9kYWwodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMud2ViQmFzZVVybH0vdHJhbnNhY3Rpb25zLyR7dHJhbnNhY3Rpb24uaWR9YDtcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS50b3AgPSAnMCc7XG4gICAgICAgICAgICBpZnJhbWUuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgICAgICBpZnJhbWUuZnJhbWVCb3JkZXIgPSAnMCc7XG4gICAgICAgICAgICBpZnJhbWUuc3JjID0gdXJsO1xuICAgICAgICAgICAgLy8gRGlzbWlzcyBhbnkgZXhpc3RpbmcgZGlhbG9ncyB0byBwcmV2ZW50IFVJIGdsaXRjaGVzLlxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFJlcXVlc3REaWFsb2cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0RGlhbG9nLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0ID0gW2Z1bGZpbGwsIHJlamVjdF07XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSZXF1ZXN0RGlhbG9nID0gbmV3IERpYWxvZyhpZnJhbWUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50UmVxdWVzdERpYWxvZy5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENhcHR1cmUgcmVqZWN0IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgcmVqZWN0KFNpZ25lckVycm9yLlVzZXJDYW5jZWxsZWQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVkaXJlY3RUb0NhbGxiYWNrVVJMKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMud2ViQmFzZVVybH0vdHJhbnNhY3Rpb25zLyR7dHJhbnNhY3Rpb24uaWR9P3JlZGlyZWN0VVJJPSR7dGhpcy5jYWxsYmFja1VSTH1gO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnJyk7XG4gICAgfVxufVxuIiwiLyogdHNsaW50OmRpc2FibGUgKi9cbmNvbnN0IGNzcyA9IGBcbi5iaXRza2ktY29ubmVjdC1idXR0b24ge1xuICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnU2Vnb2UgVUknLCBSb2JvdG8sIE94eWdlbiwgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZjtcbiAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgYmFja2dyb3VuZC1jb2xvcjogIzFDMTFEOTtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1wb3NpdGlvbjogMHB4IDBweDtcbiAgYm9yZGVyOiBub25lO1xuICBjb2xvcjogI2ZmZjtcbiAgbWFyZ2luOiAwO1xuICBwYWRkaW5nOiAwO1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIHRleHQtc2hhZG93OiAxcHggMCAxcHggcmdiYSgwLCAwLCAwLCAwLjAzKTtcbiAgYm94LXNoYWRvdzogMCAxcHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCk7XG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMjAwbXMgbGluZWFyLCB0cmFuc2Zvcm0gMjAwbXMgZWFzZS1vdXQ7XG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XG59XG4uYml0c2tpLWNvbm5lY3QtYnV0dG9uOmZvY3VzLFxuLmJpdHNraS1jb25uZWN0LWJ1dHRvbjphY3RpdmUge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMjExN0M3O1xuICB0cmFuc2Zvcm06IHNjYWxlKDAuOTksIDAuOTkpO1xuICBjb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpO1xufVxuLmJpdHNraS1jb25uZWN0LWJ1dHRvbi5zaXplLXNtYWxsIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdXJsKCdodHRwczovL2Nkbi5iaXRza2lzdGF0aWMuY29tL3Nkay9idG4tdjItYmctc20uc3ZnJyk7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgZm9udC1zaXplOiAxMHB4O1xuICBoZWlnaHQ6IDIycHg7XG4gIGxpbmUtaGVpZ2h0OiAxOXB4O1xuICBwYWRkaW5nLWxlZnQ6IDMwcHg7XG4gIHBhZGRpbmctcmlnaHQ6IDhweDtcbn1cbi5iaXRza2ktY29ubmVjdC1idXR0b24uc2l6ZS1tZWRpdW0ge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJ2h0dHBzOi8vY2RuLmJpdHNraXN0YXRpYy5jb20vc2RrL2J0bi12Mi1iZy1tZC5zdmcnKTtcbiAgYm9yZGVyLXJhZGl1czogNHB4O1xuICBmb250LXNpemU6IDExcHg7XG4gIGhlaWdodDogMzBweDtcbiAgbGluZS1oZWlnaHQ6IDI5cHg7XG4gIHBhZGRpbmctbGVmdDogNDBweDtcbiAgcGFkZGluZy1yaWdodDogMTJweDtcbn1cbi5iaXRza2ktY29ubmVjdC1idXR0b24uc2l6ZS1sYXJnZSB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHVybCgnaHR0cHM6Ly9jZG4uYml0c2tpc3RhdGljLmNvbS9zZGsvYnRuLXYyLWJnLWxnLnN2ZycpO1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIGZvbnQtc2l6ZTogMTRweDtcbiAgaGVpZ2h0OiA0NHB4O1xuICBsaW5lLWhlaWdodDogNDRweDtcbiAgcGFkZGluZy1sZWZ0OiA1N3B4O1xuICBwYWRkaW5nLXJpZ2h0OiAxNXB4O1xufVxuYDtcbmV4cG9ydCBkZWZhdWx0IGNzcztcbiIsIi8qIHRzbGludDpkaXNhYmxlICovXG5jb25zdCBjc3MgPSBgXG4jYml0c2tpLWRpYWxvZy1jb250YWluZXIge1xuICBwb3NpdGlvbjogZml4ZWQ7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xuICB0b3A6IDA7XG4gIGJvdHRvbTogMDtcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwKTtcbiAgei1pbmRleDogMTAwMDtcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCBsaW5lYXIgMC4ycztcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG59XG4jYml0c2tpLWRpYWxvZy1jb250YWluZXIuYml0c2tpLXZpc2libGUge1xuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuNSk7XG4gIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xufVxuLmJpdHNraS1kaWFsb2cge1xuICBvcGFjaXR5OiAwO1xuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoMTAwdmgpO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDMwMG1zIGxpbmVhciwgdHJhbnNmb3JtIDQwMG1zIGN1YmljLWJlemllcigwLjE5LCAxLCAwLjIyLCAxKTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdG9wOiAwO1xuICBsZWZ0OiAwO1xuICB3aWR0aDogMTAwJTtcbiAgaGVpZ2h0OiAxMDAlO1xufVxuI2JpdHNraS1kaWFsb2ctY29udGFpbmVyLmJpdHNraS12aXNpYmxlIC5iaXRza2ktZGlhbG9nIHtcbiAgb3BhY2l0eTogMTtcbiAgdHJhbnNmb3JtOiBub25lO1xuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDMwMG1zIGxpbmVhciwgdHJhbnNmb3JtIDYwMG1zIGN1YmljLWJlemllcigwLjE5LCAxLCAwLjIyLCAxKTtcbiAgcG9pbnRlci1ldmVudHM6IGF1dG87XG59XG4uYml0c2tpLWRpYWxvZyAuYml0c2tpLWNsb3NlLWJ1dHRvbiB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50IHVybCgnaHR0cHM6Ly9jZG4uYml0c2tpc3RhdGljLmNvbS9zZGsvY2xvc2Uuc3ZnJykgbm8tcmVwZWF0IDUwJSA1MCU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDEycHg7XG4gIHRvcDogMTJweDtcbiAgYm9yZGVyOiBub25lO1xuICBvdXRsaW5lOiBub25lO1xuICBtYXJnaW46IDA7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgcGFkZGluZzogMDtcbiAgd2lkdGg6IDI4cHg7XG4gIGhlaWdodDogMjhweDtcbiAgei1pbmRleDogMTAwO1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB0ZXh0LWluZGVudDogLTEwMDBweDtcbn1cbi5iaXRza2ktZGlhbG9nLWJvZHkge1xuICBiYWNrZ3JvdW5kOiAjZmZmO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMDtcbiAgYm90dG9tOiAwO1xuICBsZWZ0OiAwO1xuICByaWdodDogMDtcbiAgei1pbmRleDogNTtcbiAgbWF4LXdpZHRoOiAxMDAlO1xufVxuLmJpdHNraS1kaWFsb2ctYm9keS5iaXRza2ktbG9hZGluZzo6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBiYWNrZ3JvdW5kOiB1cmwoJ2h0dHBzOi8vY2RuLmJpdHNraXN0YXRpYy5jb20vc2RrL2xvYWRpbmcuc3ZnJykgbm8tcmVwZWF0IDUwJSA1MCU7XG4gIGFuaW1hdGlvbjogcm90YXRlIDYwMG1zIGxpbmVhciBpbmZpbml0ZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDUwJTtcbiAgbGVmdDogNTAlO1xuICBvcGFjaXR5OiAwLjM7XG4gIHdpZHRoOiAzOHB4O1xuICBoZWlnaHQ6IDM4cHg7XG4gIG1hcmdpbi1sZWZ0OiAtMTlweDtcbiAgbWFyZ2luLXRvcDogLTE5cHg7XG4gIHotaW5kZXg6IC0xO1xufVxuQG1lZGlhIChtaW4td2lkdGg6IDYwMHB4KSB7XG4gICNiaXRza2ktZGlhbG9nLWNvbnRhaW5lciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICB9XG4gIC5iaXRza2ktZGlhbG9nIHtcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgd2lkdGg6IDQwMHB4O1xuICAgIGhlaWdodDogNDIwcHg7XG4gIH1cbiAgLmJpdHNraS1kaWFsb2ctYm9keSB7XG4gICAgYm9yZGVyLXJhZGl1czogMTZweDtcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgIGJveC1zaGFkb3c6IDBweCAwcHggMHB4IDFweCByZ2JhKDAsMCwwLDAuMSksIDBweCAxMHB4IDUwcHggcmdiYSgwLDAsMCwwLjQpO1xuICB9XG59XG5cbkBrZXlmcmFtZXMgcm90YXRlIHtcbiAgMCUge1xuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICB9XG4gIDUwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMTgwZGVnKTtcbiAgfVxuICAxMDAlIHtcbiAgICB0cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xuICB9XG59XG5gO1xuZXhwb3J0IGRlZmF1bHQgY3NzO1xuIiwiLyogdHNsaW50OmRpc2FibGUgKi9cbmltcG9ydCBjb25uZWN0QnRuU3R5bGVzIGZyb20gJy4vY29ubmVjdC1idXR0b24nO1xuaW1wb3J0IGRpYWxvZ1N0eWxlcyBmcm9tICcuL2RpYWxvZyc7XG5jb25zdCBjc3MgPSBgXG4gICR7ZGlhbG9nU3R5bGVzfVxuICAke2Nvbm5lY3RCdG5TdHlsZXN9XG5gO1xuZXhwb3J0IGRlZmF1bHQgY3NzO1xuIiwiaW1wb3J0IHsgU3VicHJvdmlkZXIgfSBmcm9tICdAYml0c2tpL3Byb3ZpZGVyLWVuZ2luZSc7XG5pbXBvcnQgeyBDQUNIRURfTUVUSE9EUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG4vKlxuICogU3VicHJvdmlkZXIgdGhhdCBjYWNoZXMgdmFsdWVzIHJlbGF0ZWQgdG8gdGhlIHVzZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRoZW50aWNhdGVkQ2FjaGVTdWJwcm92aWRlciBleHRlbmRzIFN1YnByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdXRoUHJvdmlkZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdXRoUHJvdmlkZXIgPSBhdXRoUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY2FjaGVkVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBoYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICAvLyBPbmx5IGV2YWx1YXRlIG1hdGNoaW5nIG1ldGhvZHNcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydHNDYWNoZShwYXlsb2FkLm1ldGhvZCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbG93IG92ZXJyaWRpbmcgdGhlIGNhY2hlXG4gICAgICAgIGlmIChwYXlsb2FkLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMb2FkIGZyb20gY2FjaGVcbiAgICAgICAgdGhpcy5jaGVja0NhY2hlZFZhbHVlcyhwYXlsb2FkLm1ldGhvZCkudGhlbigodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gVmFsdWUgZm9yIG1ldGhvZCBpcyBjYWNoZWQsIHJldHVybiB2YWx1ZVxuICAgICAgICAgICAgICAgIGVuZCh1bmRlZmluZWQsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFZhbHVlIGZvciBtZXRob2QgaXMgbm90IGNhY2hlZCwgZmFsbGJhY2sgdG8gZmV0Y2hcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIC8vIElmIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkLCBvciB3ZSBlbmNvdW50ZXIgYW4gZXJyb3IsIGZhbGxiYWNrIHRvIGZldGNoIHByb3ZpZGVyXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwcG9ydHNDYWNoZShtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBDQUNIRURfTUVUSE9EUy5pbmNsdWRlcyhtZXRob2ROYW1lKTtcbiAgICB9XG4gICAgY2hlY2tDYWNoZWRWYWx1ZXMobWV0aG9kTmFtZSkge1xuICAgICAgICAvLyBGaXJzdCwgY2hlY2sgaW4tbWVtb3J5IGNhY2hlXG4gICAgICAgIGlmICh0aGlzLmNhY2hlZFZhbHVlcy5oYXMobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jYWNoZWRWYWx1ZXMuZ2V0KG1ldGhvZE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayB0byBsb2NhbC1zdG9yYWdlIGNhY2hlXG4gICAgICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnZXRoX2FjY291bnRzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNZXRob2Qgbm90IHN1cHBvcnRlZCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRBY2NvdW50cygpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIHRvIGEgc3Vic2NyaXB0aW9uIG1vZGVsIGFuZCBsb2FkIGludG8gbWVtb3J5IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgcmV0dXJuIHRoaXMuYXV0aFByb3ZpZGVyLmdldFVzZXIoKS50aGVuKCh1c2VyKSA9PiB7XG4gICAgICAgICAgICBpZiAodXNlci5hY2NvdW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVkVmFsdWVzLnNldCgnZXRoX2FjY291bnRzJywgdXNlci5hY2NvdW50cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXIuYWNjb3VudHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FjY291bnRzIG5vdCBmb3VuZCBvbiB1c2VyJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEF1dGhlbnRpY2F0ZWRGZXRjaFN1YnByb3ZpZGVyIH0gZnJvbSAnYml0c2tpLXByb3ZpZGVyJztcbi8vIEEgc3VicHJvdmlkZXIgdGhhdCBsb2FkcyBhY2NvdW50cyBmcm9tIGEgY3VzdG9tIHJwYyBlbmRwb2ludC5cbi8vIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdG8gZ3VhcmFudGVlIHRoYXQgYWNjb3VudCByZWxhdGVkIGNhbGxzIGdvIHRocm91Z2ggQml0c2tpXG5leHBvcnQgY2xhc3MgUmVtb3RlQWNjb3VudFN1YnByb3ZpZGVyIGV4dGVuZHMgQXV0aGVudGljYXRlZEZldGNoU3VicHJvdmlkZXIge1xuICAgIGhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9hY2NvdW50cycpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aGVudGljYXRlZFJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IFN1YnByb3ZpZGVyIH0gZnJvbSAnQGJpdHNraS9wcm92aWRlci1lbmdpbmUnO1xuaW1wb3J0IHV1aWQgZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBERUZBVUxUX0FVVEhPUklaRURfTUVUSE9EUyBhcyBERUZBVUxUX1NJR05BVFVSRV9NRVRIT0RTIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IFNpZ25lckVycm9yIH0gZnJvbSAnLi4vZXJyb3JzL3NpZ25lci1lcnJvcic7XG5leHBvcnQgdmFyIFRyYW5zYWN0aW9uS2luZDtcbihmdW5jdGlvbiAoVHJhbnNhY3Rpb25LaW5kKSB7XG4gICAgVHJhbnNhY3Rpb25LaW5kW1wiU2VuZFRyYW5zYWN0aW9uXCJdID0gXCJFVEhfU0VORF9UUkFOU0FDVElPTlwiO1xuICAgIFRyYW5zYWN0aW9uS2luZFtcIlNpZ25UcmFuc2FjdGlvblwiXSA9IFwiRVRIX1NJR05fVFJBTlNBQ1RJT05cIjtcbiAgICBUcmFuc2FjdGlvbktpbmRbXCJTaWduXCJdID0gXCJFVEhfU0lHTlwiO1xuICAgIFRyYW5zYWN0aW9uS2luZFtcIlNpZ25UeXBlZERhdGFcIl0gPSBcIkVUSF9TSUdOX1RZUEVEX0RBVEFcIjtcbn0pKFRyYW5zYWN0aW9uS2luZCB8fCAoVHJhbnNhY3Rpb25LaW5kID0ge30pKTtcbi8qKlxuICogQSBTdWJwcm92aWRlciB0aGF0IG1hbmFnZXMgdGhlIGludGVyZmFjZSBiZXR3ZWVuIEpTT04tUlBDIGFuZCBCaXRza2kncyBwcm9wcmlldGFyeSB0cmFuc2FjdGlvbiBzaWduaW5nIGZsb3cuXG4gKiBUaGlzIGNsYXNzIGlzIHJlc3BvbnNpYmxlIGZvciB0cmFuc2Zvcm1pbmcgdGhlIEpTT04tUlBDIHJlcXVlc3QgaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdCB0aGF0IHRoZSBCaXRza2kgc2lnbmVyIHVuZGVyc3RhbmRzLlxuICogQWxzbyByZXNwb25zaWJsZSBmb3Igc3VibWl0dGluZyB0aGUgdHJhbnNhY3Rpb24gdG8gdGhlIG5ldHdvcmssIGFuZCBjb252ZXJ0aW5nIHRoZSByZXNwb25zZSBiYWNrIGludG8gYW4gUlBDIHJlc3BvbnNlLlxuICpcbiAqIEltcG9ydGFudDogdGhpcyBjbGFzcyBhc3N1bWVzIHRoZSB0cmFuc2FjdGlvbiBoYXMgYWxsIHRoZSBuZWNlc3NhcnkgZmllbGRzIHBvcHVsYXRlZC4gVGhlIFRyYW5zYWN0aW9uVmFsaWRhdG9yU3VicHJvdmlkZXJcbiAqIHNob3VsZCBiZSBwbGFjZWQgaW4gZnJvbnQgb2YgdGhpcyBzdWJwcm92aWRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFNpZ25hdHVyZVN1YnByb3ZpZGVyIGV4dGVuZHMgU3VicHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIHNpZ25lciwgdG9rZW5Qcm92aWRlciwgc2lnbmF0dXJlTWV0aG9kcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSBuZXR3b3JrO1xuICAgICAgICB0aGlzLnRva2VuUHJvdmlkZXIgPSB0b2tlblByb3ZpZGVyO1xuICAgICAgICB0aGlzLnNpZ25lciA9IHNpZ25lcjtcbiAgICAgICAgdGhpcy5zaWduYXR1cmVNZXRob2RzID0gc2lnbmF0dXJlTWV0aG9kcyB8fCBERUZBVUxUX1NJR05BVFVSRV9NRVRIT0RTO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgUlBDIHJlcXVlc3QgZnJvbSBlbmdpbmUgKGNhbGxlZCBieSlcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBSUEMgcmVxdWVzdCBwYXlsb2FkXG4gICAgICogQHBhcmFtIG5leHQgQ2FsbGJhY2sgdG8gc2tpcCBoYW5kbGluZyB0aGlzIHJlcXVlc3RcbiAgICAgKiBAcGFyYW0gZW5kIENvbXBsZXRpb24gaGFuZGxlclxuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcXVpcmVzU2lnbmF0dXJlKHBheWxvYWQubWV0aG9kKSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTaWduYXR1cmVSZXF1ZXN0KHBheWxvYWQsIGVuZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHBheWxvYWQgaXMgcmVjZWl2ZWQgdGhhdCBuZWVkcyBhIHNpZ25hdHVyZVxuICAgICAqIEBwYXJhbSBwYXlsb2FkIFRoZSBKU09OLVJQQyByZXF1ZXN0XG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0byBjYWxsIHdoZW4gdGhlIHJlcXVlc3QgaGFzIGJlZW4gaGFuZGxlZFxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZVNpZ25hdHVyZVJlcXVlc3QocGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBhY2Nlc3MgdG9rZW5cbiAgICAgICAgICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gYXdhaXQgdGhpcy50b2tlblByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKCk7XG4gICAgICAgICAgICAvLyBQcmVwYXJlIGEgdHJhbnNhY3Rpb24gb2JqZWN0XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuY3JlYXRlQml0c2tpVHJhbnNhY3Rpb24ocGF5bG9hZCk7XG4gICAgICAgICAgICAvLyBTaWduIHRoZSB0cmFuc2FjdGlvbiBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaWduZXIuc2lnbih0cmFuc2FjdGlvbiwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgdHJhbnNhY3Rpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNlbmRJZk5lZWRlZChwYXlsb2FkLCBzaWduZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENhbGwgd2l0aCB0aGUgZXJyb3IgaWYgYW55IG9mIHRoZSBzdGVwcyBmYWlsXG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogU2hvdWxkIHRoaXMgc3VicHJvdmlkZXIgaGFuZGxlIHRoZSByZXF1ZXN0P1xuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIFJQQyBtZXRob2Qgb2YgdGhlIHJlcXVlc3RcbiAgICAgKi9cbiAgICByZXF1aXJlc1NpZ25hdHVyZShtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2lnbmF0dXJlTWV0aG9kcy5pbmNsdWRlcyhtZXRob2QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIHdpbGwgZm9yd2FyZCB0cmFuc2FjdGlvbnMgdGhhdCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmssIG90aGVyd2lzZVxuICAgICAqIHJlc29sdmUgd2l0aCB0aGUgb3JpZ2luYWwgdmFsdWUuXG4gICAgICogQHBhcmFtIHBheWxvYWQgVGhlIG9yaWdpbmFsIHJlcXVlc3QgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBzaWduZWREYXRhIHNpZ25lZCBkYXRhIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICBzZW5kSWZOZWVkZWQocGF5bG9hZCwgc2lnbmVkRGF0YSkge1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2VuZFRyYW5zYWN0aW9uJykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2VuZCByYXcgdHJhbnNhY3Rpb24gcGF5bG9hZFxuICAgICAgICAgICAgY29uc3Qgc2VuZFBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbc2lnbmVkRGF0YV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVJlcXVlc3Qoc2VuZFBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lnbmVkRGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvYWQgdGhlIGJhbGFuY2Ugc28gdGhlIHdlYiBhcHByb3ZhbCBkaWFsb2cgY2FuIGdpdmUgdGhlIHVzZXIgYmV0dGVyIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gcGF5bG9hZCBQYXlsb2FkIGZvciB0aGUgcmVxdWVzdFxuICAgICAqL1xuICAgIGxvYWRCYWxhbmNlSWZOZWVkZWQocGF5bG9hZCkge1xuICAgICAgICAvLyBPbmx5IG5lY2Vzc2FyeSBpZiB0aGlzIGlzIGEgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgaXNUcmFuc2FjdGlvbiA9IHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NlbmRUcmFuc2FjdGlvbicgfHwgcGF5bG9hZC5tZXRob2QgPT09ICdldGhfc2lnblRyYW5zYWN0aW9uJztcbiAgICAgICAgY29uc3QgaXNDdXN0b21SUEMgPSAhdGhpcy5uZXR3b3JrLnJwY1VybC5pbmNsdWRlcygnYXBpLmJpdHNraS5jb20nKTtcbiAgICAgICAgaWYgKGlzVHJhbnNhY3Rpb24gJiYgaXNDdXN0b21SUEMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmFsYW5jZScsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbdHJhbnNhY3Rpb24uZnJvbSwgJ2xhdGVzdCddLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1SZXF1ZXN0KGJhbGFuY2VQYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGUgVHJhbnNhY3Rpb24gb2JqZWN0IGZyb20gYSBnaXZlbiBSUEMgcGF5bG9hZFxuICAgICAqIEBwYXJhbSBwYXlsb2FkIEpTT04tUlBDIHBheWxvYWQgdG8gZXh0cmFjdCB0aGUgdmFsdWVzIGZyb21cbiAgICAgKi9cbiAgICBhc3luYyBjcmVhdGVCaXRza2lUcmFuc2FjdGlvbihwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBhd2FpdCB0aGlzLmNyZWF0ZUNvbnRleHQocGF5bG9hZCk7XG4gICAgICAgIGNvbnN0IGtpbmQgPSB0aGlzLmtpbmRGb3JNZXRob2QocGF5bG9hZC5tZXRob2QpO1xuICAgICAgICBjb25zdCBleHRyYWN0ZWRQYXlsb2FkID0gdGhpcy5jcmVhdGVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgIGlkOiB1dWlkKCksXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgcGF5bG9hZDogZXh0cmFjdGVkUGF5bG9hZCxcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgY3JlYXRlQ29udGV4dChyZXF1ZXN0KSB7XG4gICAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IGF3YWl0IHRoaXMubG9hZEJhbGFuY2VJZk5lZWRlZChyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjaGFpbklkOiB0aGlzLm5ldHdvcmsuY2hhaW5JZCwgY3VycmVudEJhbGFuY2U6IGJhbGFuY2UgfTtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhJzpcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3YzJzpcbiAgICAgICAgICAgICAgICAvLyBUaGUgZnJvbSBhZGRyZXNzIHNob3VsZCBiZSB0aGUgZmlyc3QgcGFyYW1ldGVyIGFzIGEgMjAgYnl0ZSBoZXggc3RyaW5nXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucGFyYW1zICYmIHJlcXVlc3QucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogcmVxdWVzdC5wYXJhbXNbMF0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuTWlzc2luZ0Zyb20oKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gT3RoZXIgdHJhbnNhY3Rpb24gdHlwZXMgZG8gbm90IG5lZWQgY29udGV4dFxuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhlIHBheWxvYWQgZnJvbSBhIGdpdmVuIFJQQyByZXF1ZXN0XG4gICAgICogQHBhcmFtIHJlcXVlc3QgSlNPTi1SUEMgcmVxdWVzdCB0byBleHRyYWN0IHBhcmFtcyBmcm9tXG4gICAgICovXG4gICAgY3JlYXRlUGF5bG9hZChyZXF1ZXN0KSB7XG4gICAgICAgIHN3aXRjaCAocmVxdWVzdC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UcmFuc2FjdGlvbic6XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucGFyYW1zICYmIHJlcXVlc3QucGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3QucGFyYW1zWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuTWlzc2luZ1RyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ24nOlxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnBhcmFtcyAmJiByZXF1ZXN0LnBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZyb206IHJlcXVlc3QucGFyYW1zWzBdLCBtZXNzYWdlOiByZXF1ZXN0LnBhcmFtc1sxXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgU2lnbmVyRXJyb3IuTWlzc2luZ01lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdwZXJzb25hbF9zaWduJzpcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5wYXJhbXMgJiYgcmVxdWVzdC5wYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmcm9tOiByZXF1ZXN0LnBhcmFtc1sxXSwgbWVzc2FnZTogcmVxdWVzdC5wYXJhbXNbMF0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFNpZ25lckVycm9yLk1pc3NpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGEnOlxuICAgICAgICAgICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnBhcmFtcyAmJiByZXF1ZXN0LnBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0LnBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IFNpZ25lckVycm9yLk1pc3NpbmdUeXBlZERhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFNpZ25lckVycm9yLlVuc3VwcG9ydGVkTWV0aG9kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBhIEJpdHNraVRyYW5zYWN0aW9uLktpbmQgdmFsdWUgZnJvbSBhIGdpdmVuIFJQQyBtZXRob2QgbmFtZVxuICAgICAqIEBwYXJhbSBtZXRob2QgVGhlIEpTT04tUlBDIG1ldGhvZCBiZWluZyByZXF1ZXN0ZWRcbiAgICAgKi9cbiAgICBraW5kRm9yTWV0aG9kKG1ldGhvZCkge1xuICAgICAgICBzd2l0Y2ggKG1ldGhvZCkge1xuICAgICAgICAgICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgICAgICAgICBjYXNlICdldGhfc2lnblRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGJvdGggKnNpZ24qIGFuZCAqc2VuZCogbWV0aG9kcyBpbnRvIGEgc2lnbiB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAvLyAod2Ugd2lsbCBmb3J3YXJkIHRoZSB0cmFuc2FjdGlvbiBsb2NhbGx5IGlmIG5lZWRlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25LaW5kLlNpZ25UcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduJzpcbiAgICAgICAgICAgIGNhc2UgJ3BlcnNvbmFsX3NpZ24nOlxuICAgICAgICAgICAgICAgIHJldHVybiBUcmFuc2FjdGlvbktpbmQuU2lnbjtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhJzpcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3YzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb25LaW5kLlNpZ25UeXBlZERhdGE7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IFNpZ25lckVycm9yLlVuc3VwcG9ydGVkTWV0aG9kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gV3JhcHMgZW1pdFBheWxvYWQgaW4gYSBwcm9taXNlXG4gICAgcGVyZm9ybVJlcXVlc3QocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0UGF5bG9hZChwYXlsb2FkLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBBdXRvbWF0aWNhbGx5IGhhbmRsZXMgZmluYWxpemluZyB0aGUgb2F1dGggc2lnbiBpbiBwcm9jZXNzIHdpdGggdGhlIEJpdHNraSBTREtcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NDYWxsYmFjaygpIHtcbiAgICBpZiAod2luZG93Lm9wZW5lcikge1xuICAgICAgICBub3RpZnlPcGVuZXIod2luZG93LmxvY2F0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IHdpbmRvdyBjb3VsZCBub3QgYmUgZm91bmQnKTtcbiAgICB9XG59XG4vKipcbiAqIE5vdGlmaWVzIHRoZSBvcGVuZXIgd2hlbiBpbiBhIHBvcHVwXG4gKiBAcGFyYW0gdXJsIHRoZSB1cmwgdGhhdCBjb250YWlucyB0aGUgcXVlcnkgcGFyYW1zXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeU9wZW5lcih1cmwpIHtcbiAgICBpZiAod2luZG93Lm9wZW5lcikge1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAvLyBwYXJzZSB1cmwgdG8gZ2V0IHN0YXRlXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcGFyc2VVcmxQYXJhbXModXJsKTtcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGBwb3B1cENhbGxiYWNrXyR7ZGF0YS5zdGF0ZX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gd2luZG93Lm9wZW5lcltuYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY2FsbGJhY2sgZm91bmQgb24gb3BlbmVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzdGF0ZSBmb3VuZCBpbiByZXNwb25zZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHdpbmRvdy5vcGVuZXInKTtcbiAgICB9XG59XG4vKipcbiAqIEV4dHJhY3RzIHF1ZXJ5IHBhcmFtcyBmcm9tIHRoZSBoYXNoIG9mIHRoZSB1cmxcbiAqIEBwYXJhbSB1cmwgdGhlIHVybCB0byBwYXJzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVcmxQYXJhbXModXJsKSB7XG4gICAgbGV0IHBhcmFtcztcbiAgICBpZiAodXJsLmhyZWYuaW5jbHVkZXMoJyMnKSkge1xuICAgICAgICBwYXJhbXMgPSBleHRyYWN0UXVlcnkodXJsLmhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmwuaHJlZi5pbmNsdWRlcygnPycpKSB7XG4gICAgICAgIHBhcmFtcyA9IHVybC5zZWFyY2guc3BsaXQoJz8nKS5wb3AoKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJhbXMgZm91bmQgaW4gcmVzdWx0Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXMuc3BsaXQoJyYnKS5yZWR1Y2UoKHByZXYsIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgW2tleSwgdmFsdWVdID0gaXRlbS5zcGxpdCgnPScpO1xuICAgICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBwcmV2W2RlY29kZVVSSUNvbXBvbmVudChrZXkpXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5KHVybCkge1xuICAgIGlmICghdXJsLmluY2x1ZGVzKCcjJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBwYXJhbXMgZm91bmQgaW4gcmVzdWx0Jyk7XG4gICAgfVxuICAgIHJldHVybiB1cmwuc3BsaXQoJyMnKS5wb3AoKTtcbn1cbiIsIi8vIERlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgZ2VuZXJpYyBzdG9yZSBpbnRlcmZhY2UuXG4vLyBVc2VzIGxvY2FsU3RvcmFnZSBvciBzZXNzaW9uU3RvcmFnZSAocGFzcyB3aGljaCBvbmUgeW91IHdhbnQgaW4gY29uc3RydWN0b3IpLlxuZXhwb3J0IGNsYXNzIExvY2FsU3RvcmFnZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlID0gbG9jYWxTdG9yYWdlKSB7XG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2U7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcbiAgICB9XG4gICAgZ2V0SXRlbShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgfVxuICAgIHNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgY2xlYXJJdGVtKGtleSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IEJhc2ljUXVlcnlTdHJpbmdVdGlscywgfSBmcm9tICdAb3BlbmlkL2FwcGF1dGgnO1xuZXhwb3J0IGNsYXNzIE5vSGFzaFF1ZXJ5U3RyaW5nVXRpbHMgZXh0ZW5kcyBCYXNpY1F1ZXJ5U3RyaW5nVXRpbHMge1xuICAgIHBhcnNlKGlucHV0LCB1c2VIYXNoKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5wYXJzZShpbnB1dCwgZmFsc2UgLyogbmV2ZXIgdXNlIGhhc2ggKi8pO1xuICAgIH1cbn1cbiIsIi8qKlxuICogQSBzaW1wbGUgdXRpbGl0eSBjbGFzcyB0aGF0IHdpbGwgY2hlY2sgdG8gc2VlIGlmIGEgcG9wdXAgaXMgYmxvY2tlZC5cbiAqIERlcml2ZWQgZnJvbSBpbmZvIGFuZCBleGFtcGxlcyBvbiB0aGlzIHBhZ2U6XG4gKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yOTE0L2hvdy1jYW4taS1kZXRlY3QtaWYtYS1icm93c2VyLWlzLWJsb2NraW5nLWEtcG9wdXBcbiAqL1xuZXhwb3J0IGNsYXNzIFBvcHVwVmFsaWRhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG4gICAgfVxuICAgIC8vIENoZWNrIGEgcG9wdXAgd2luZG93IHRvIHNlZSBpZiBpdCBoYXMgYmVlbiBibG9ja2VkLlxuICAgIC8vIFRoZSBlcnJvciBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIGFzeW5jaHJvbm91c2x5IGlmXG4gICAgLy8gdGhlIHdpbmRvdyBoYXMgYmVlbiBkZXRlY3RlZCB0byBoYXZlIGJlZW4gYmxvY2tlZC5cbiAgICBjaGVjayhwb3B1cCkge1xuICAgICAgICBpZiAocG9wdXApIHtcbiAgICAgICAgICAgIGlmICgvY2hyb21lLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1BvcHVwQmxvY2tlZChwb3B1cCk7XG4gICAgICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcHVwLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1BvcHVwQmxvY2tlZChwb3B1cCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmxvY2tlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlzUG9wdXBCbG9ja2VkKHBvcHVwKSB7XG4gICAgICAgIGlmICgocG9wdXAuaW5uZXJIZWlnaHQgPiAwKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQmxvY2tlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUJsb2NrZWQoKSB7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgU2VydmVyRXJyb3IgfSBmcm9tICdiaXRza2ktcHJvdmlkZXInO1xuaW1wb3J0IHsgUGFyc2VFcnJvciB9IGZyb20gJy4uL2Vycm9ycy9wYXJzZS1lcnJvcic7XG4vKipcbiAqIFBhcnNlcyBhIEZldGNoIFJlc3BvbnNlIHRvIGV4dHJhY3QgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGVycm9yXG4gKiBAcGFyYW0gcmVzcG9uc2UgdGhlIGZldGNoIHJlc3BvbnNlIHRvIHBhcnNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgIHRocm93IFBhcnNlRXJyb3IuSW52YWxpZEpTT04oKTtcbiAgICB9KS50aGVuKChqc29uKSA9PiB7XG4gICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPj0gMjAwICYmIHJlc3BvbnNlLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoanNvbiAmJiBqc29uLmVycm9yICYmIGpzb24uZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcihqc29uLmVycm9yLm1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpzb24gJiYganNvbi5lcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTZXJ2ZXJFcnJvcihqc29uLmVycm9yLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBQYXJzZUVycm9yLlVua25vd25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG4iLCJmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgIFwiZGVmYXVsdFwiOiBvYmpcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xudmFyIHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL3Byb3ZpZGVyLWVuZ2luZS1lcnJvclwiKTtcbnZhciBjcmVhdGVfcGF5bG9hZF8xID0gcmVxdWlyZShcIi4vdXRpbC9jcmVhdGUtcGF5bG9hZFwiKTtcbi8vIFRoZSBiYXNlIGNsYXNzIHdoaWNoIFByb3ZpZGVyRW5naW5lIHdpbGwgZXh0ZW5kIGZyb20gdGhhdCBwcm92aWRlcyB0aGUgYmFzaWMgV2ViMyBQcm92aWRlciBpbnRlcmZhY2VcbnZhciBCYXNlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhc2VQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCYXNlUHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLy8gTW9kZXJuIHNlbmQgbWV0aG9kXG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gY3JlYXRlX3BheWxvYWRfMS5jcmVhdGVQYXlsb2FkKHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kUGF5bG9hZChwYXlsb2FkKS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBMZWdhY3kgc2VuZEFzeW5jIG1ldGhvZFxuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gKHBheWxvYWQsIGNiKSB7XG4gICAgICAgIHRoaXMuc2VuZFBheWxvYWQocGF5bG9hZCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIHJlc3BvbnNlKTtcbiAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBjYihlcnJvciwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gV2hldGhlciBvciBub3QgdGhpcyBwcm92aWRlciBzdXBwb3J0cyBzdWJzY3JpcHRpb25zXG4gICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zdXBwb3J0c1N1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoaXMgaW4geW91ciBzdWJjbGFzcyBpZiB5b3Ugc3VwcG9ydCBzdWJzY3JpcHRpb25zXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIC8vIE1ldGhvZCB0byBzdWJzY3JpYmUgdG8gYSBnaXZlbiBzdWJzY3JpcHRpb24gdHlwZVxuICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZU1ldGhvZCwgc3Vic2NyaXB0aW9uTWV0aG9kLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoaXMgd2l0aCBzdWJzY3JpcHRpb24gaW1wbGVtZW50YXRpb25cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMS5Qcm92aWRlckVuZ2luZUVycm9yKCdTdWJzY3JpcHRpb25zIGFyZSBub3Qgc3VwcG9ydGVkJywgcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUuVW5zdXBwb3J0ZWRGZWF0dXJlKSk7XG4gICAgfTtcbiAgICAvLyBNZXRob2QgdG8gdW5zdWJzY3JpYmVcbiAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmlwdGlvbklkLCB1bnN1YnNjcmliZU1ldGhvZCkge1xuICAgICAgICAvLyBPdmVycmlkZSB0aGlzIHdpdGggdW5zdWJzY3JpYmUgaW1wbGVtZW50YXRpb25cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMS5Qcm92aWRlckVuZ2luZUVycm9yKCdTdWJzY3JpcHRpb25zIGFyZSBub3Qgc3VwcG9ydGVkJywgcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUuVW5zdXBwb3J0ZWRGZWF0dXJlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmFzZVByb3ZpZGVyO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJhc2VQcm92aWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQmxvY2tUcmFja2VyRXJyb3JDb2RlO1xuKGZ1bmN0aW9uIChCbG9ja1RyYWNrZXJFcnJvckNvZGUpIHtcbiAgICAvLyBCbG9jayBkYXRhIHdhcyBub3QgZm91bmQgYWZ0ZXIgcmV0cmllc1xuICAgIEJsb2NrVHJhY2tlckVycm9yQ29kZVtCbG9ja1RyYWNrZXJFcnJvckNvZGVbXCJCbG9ja05vdEZvdW5kXCJdID0gMzAwMF0gPSBcIkJsb2NrTm90Rm91bmRcIjtcbn0pKEJsb2NrVHJhY2tlckVycm9yQ29kZSA9IGV4cG9ydHMuQmxvY2tUcmFja2VyRXJyb3JDb2RlIHx8IChleHBvcnRzLkJsb2NrVHJhY2tlckVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgZXJyb3JzIHRoYXQgb2NjdXIgaW4gdGhlIGJsb2NrIHRyYWNrZXJcbiAqL1xudmFyIEJsb2NrVHJhY2tlckVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhCbG9ja1RyYWNrZXJFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja1RyYWNrZXJFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgQmxvY2tUcmFja2VyRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJsb2NrVHJhY2tlckVycm9yLkJsb2NrTm90Rm91bmQgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCbG9ja1RyYWNrZXJFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGJsb2NrIFwiICsgYmxvY2tOdW1iZXIsIEJsb2NrVHJhY2tlckVycm9yQ29kZS5CbG9ja05vdEZvdW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1RyYWNrZXJFcnJvcjtcbn0oRXJyb3IpKTtcbmV4cG9ydHMuQmxvY2tUcmFja2VyRXJyb3IgPSBCbG9ja1RyYWNrZXJFcnJvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgR2FzUHJpY2VFcnJvckNvZGU7XG4oZnVuY3Rpb24gKEdhc1ByaWNlRXJyb3JDb2RlKSB7XG4gICAgR2FzUHJpY2VFcnJvckNvZGVbR2FzUHJpY2VFcnJvckNvZGVbXCJCbG9ja05vdEZvdW5kXCJdID0gNDAwMF0gPSBcIkJsb2NrTm90Rm91bmRcIjtcbn0pKEdhc1ByaWNlRXJyb3JDb2RlID0gZXhwb3J0cy5HYXNQcmljZUVycm9yQ29kZSB8fCAoZXhwb3J0cy5HYXNQcmljZUVycm9yQ29kZSA9IHt9KSk7XG4vKipcbiAqIFJlcHJlc2VudHMgZXJyb3JzIHRoYXQgb2NjdXIgaW4gdGhlIGdhcyBwcmljZSBzdWJwcm92aWRlclxuICovXG52YXIgR2FzUHJpY2VFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR2FzUHJpY2VFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBHYXNQcmljZUVycm9yKG1lc3NhZ2UsIGNvZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgLy8gTWFpbnRhaW5zIHByb3BlciBzdGFjayB0cmFjZSBmb3Igd2hlcmUgb3VyIGVycm9yIHdhcyB0aHJvd24gKG9ubHkgYXZhaWxhYmxlIG9uIFY4KVxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBHYXNQcmljZUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBHYXNQcmljZUVycm9yLkJsb2NrTm90Rm91bmQgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgdmFyIG1zZyA9IFwiQ291bGQgbm90IGNhbGN1bGF0ZSBnYXMuIEJsb2NrIFwiICsgYmxvY2tOdW1iZXIgKyBcIiB3YXMgbm90IGZvdW5kXCI7XG4gICAgICAgIHJldHVybiBuZXcgR2FzUHJpY2VFcnJvcihtc2csIEdhc1ByaWNlRXJyb3JDb2RlLkJsb2NrTm90Rm91bmQpO1xuICAgIH07XG4gICAgcmV0dXJuIEdhc1ByaWNlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkdhc1ByaWNlRXJyb3IgPSBHYXNQcmljZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBQcm92aWRlckVuZ2luZUVycm9yQ29kZTtcbihmdW5jdGlvbiAoUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUpIHtcbiAgICBQcm92aWRlckVuZ2luZUVycm9yQ29kZVtQcm92aWRlckVuZ2luZUVycm9yQ29kZVtcIlVuaGFuZGxlZFJlcXVlc3RcIl0gPSAxMDAwXSA9IFwiVW5oYW5kbGVkUmVxdWVzdFwiO1xuICAgIFByb3ZpZGVyRW5naW5lRXJyb3JDb2RlW1Byb3ZpZGVyRW5naW5lRXJyb3JDb2RlW1wiTWlzc2luZ0ltcGxlbWVudGF0aW9uXCJdID0gMTAwMV0gPSBcIk1pc3NpbmdJbXBsZW1lbnRhdGlvblwiO1xuICAgIFByb3ZpZGVyRW5naW5lRXJyb3JDb2RlW1Byb3ZpZGVyRW5naW5lRXJyb3JDb2RlW1wiVW5zdXBwb3J0ZWRGZWF0dXJlXCJdID0gMTAwMl0gPSBcIlVuc3VwcG9ydGVkRmVhdHVyZVwiO1xufSkoUHJvdmlkZXJFbmdpbmVFcnJvckNvZGUgPSBleHBvcnRzLlByb3ZpZGVyRW5naW5lRXJyb3JDb2RlIHx8IChleHBvcnRzLlByb3ZpZGVyRW5naW5lRXJyb3JDb2RlID0ge30pKTtcbi8qKlxuICogUmVwcmVzZW50cyBlcnJvcnMgc3BlY2lmaWMgdG8gUHJvdmlkZXJFbmdpbmVcbiAqL1xudmFyIFByb3ZpZGVyRW5naW5lRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFByb3ZpZGVyRW5naW5lRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJvdmlkZXJFbmdpbmVFcnJvcihtZXNzYWdlLCBjb2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIC8vIE1haW50YWlucyBwcm9wZXIgc3RhY2sgdHJhY2UgZm9yIHdoZXJlIG91ciBlcnJvciB3YXMgdGhyb3duIChvbmx5IGF2YWlsYWJsZSBvbiBWOClcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgUHJvdmlkZXJFbmdpbmVFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFByb3ZpZGVyRW5naW5lRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlByb3ZpZGVyRW5naW5lRXJyb3IgPSBQcm92aWRlckVuZ2luZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTdWJzY3JpcHRpb25FcnJvckNvZGU7XG4oZnVuY3Rpb24gKFN1YnNjcmlwdGlvbkVycm9yQ29kZSkge1xuICAgIFN1YnNjcmlwdGlvbkVycm9yQ29kZVtTdWJzY3JpcHRpb25FcnJvckNvZGVbXCJVbnN1cHBvcnRlZFR5cGVcIl0gPSAyMDAwXSA9IFwiVW5zdXBwb3J0ZWRUeXBlXCI7XG4gICAgU3Vic2NyaXB0aW9uRXJyb3JDb2RlW1N1YnNjcmlwdGlvbkVycm9yQ29kZVtcIk5vdEZvdW5kXCJdID0gMjAwMV0gPSBcIk5vdEZvdW5kXCI7XG59KShTdWJzY3JpcHRpb25FcnJvckNvZGUgPSBleHBvcnRzLlN1YnNjcmlwdGlvbkVycm9yQ29kZSB8fCAoZXhwb3J0cy5TdWJzY3JpcHRpb25FcnJvckNvZGUgPSB7fSkpO1xuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGVycm9yIHRoYXQgb2NjdXJzIGluIHRoZSBzdWJzY3JpcHRpb25zIHN1YnByb3ZpZGVyXG4gKi9cbnZhciBTdWJzY3JpcHRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uRXJyb3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIFN1YnNjcmlwdGlvbkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25FcnJvci5VbnN1cHBvcnRlZFR5cGUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkVycm9yKFwiVW5zdXBwb3J0ZWQgc3Vic2NyaXB0aW9uIHR5cGU6IFwiICsgdHlwZSwgU3Vic2NyaXB0aW9uRXJyb3JDb2RlLlVuc3VwcG9ydGVkVHlwZSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25FcnJvci5Ob3RGb3VuZCA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb25JZCkge1xuICAgICAgICByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbkVycm9yKFwiU3Vic2NyaXB0aW9uIHdpdGggaWQgXCIgKyBzdWJzY3JpcHRpb25JZCArIFwiIG5vdCBmb3VuZFwiLCBTdWJzY3JpcHRpb25FcnJvckNvZGUuTm90Rm91bmQpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvbkVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25FcnJvciA9IFN1YnNjcmlwdGlvbkVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByb3ZpZGVyX2VuZ2luZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Byb3ZpZGVyLWVuZ2luZVwiKSk7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9zdWJwcm92aWRlclwiKSk7XG5leHBvcnRzLlN1YnByb3ZpZGVyID0gc3VicHJvdmlkZXJfMS5kZWZhdWx0O1xuZXhwb3J0cy5kZWZhdWx0ID0gcHJvdmlkZXJfZW5naW5lXzEuZGVmYXVsdDtcbi8vIEVycm9yc1xudmFyIGJsb2NrX3RyYWNrZXJfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9ibG9jay10cmFja2VyLWVycm9yXCIpO1xuZXhwb3J0cy5CbG9ja1RyYWNrZXJFcnJvciA9IGJsb2NrX3RyYWNrZXJfZXJyb3JfMS5CbG9ja1RyYWNrZXJFcnJvcjtcbmV4cG9ydHMuQmxvY2tUcmFja2VyRXJyb3JDb2RlID0gYmxvY2tfdHJhY2tlcl9lcnJvcl8xLkJsb2NrVHJhY2tlckVycm9yQ29kZTtcbnZhciBnYXNfcHJpY2VfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9nYXMtcHJpY2UtZXJyb3JcIik7XG5leHBvcnRzLkdhc1ByaWNlRXJyb3IgPSBnYXNfcHJpY2VfZXJyb3JfMS5HYXNQcmljZUVycm9yO1xuZXhwb3J0cy5HYXNQcmljZUVycm9yQ29kZSA9IGdhc19wcmljZV9lcnJvcl8xLkdhc1ByaWNlRXJyb3JDb2RlO1xudmFyIHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL3Byb3ZpZGVyLWVuZ2luZS1lcnJvclwiKTtcbmV4cG9ydHMuUHJvdmlkZXJFbmdpbmVFcnJvciA9IHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xLlByb3ZpZGVyRW5naW5lRXJyb3I7XG5leHBvcnRzLlByb3ZpZGVyRW5naW5lRXJyb3JDb2RlID0gcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEuUHJvdmlkZXJFbmdpbmVFcnJvckNvZGU7XG52YXIgc3Vic2NyaXB0aW9uX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMvc3Vic2NyaXB0aW9uLWVycm9yXCIpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25FcnJvciA9IHN1YnNjcmlwdGlvbl9lcnJvcl8xLlN1YnNjcmlwdGlvbkVycm9yO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25FcnJvckNvZGUgPSBzdWJzY3JpcHRpb25fZXJyb3JfMS5TdWJzY3JpcHRpb25FcnJvckNvZGU7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdWJwcm92aWRlcnMvaW5kZXhcIikpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlYWNoU2VyaWVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL2VhY2hTZXJpZXNcIikpO1xudmFyIGJhc2VfcHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9iYXNlLXByb3ZpZGVyXCIpKTtcbnZhciBwcm92aWRlcl9lbmdpbmVfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9wcm92aWRlci1lbmdpbmUtZXJyb3JcIik7XG52YXIgYmxvY2tfdHJhY2tlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvYmxvY2stdHJhY2tlclwiKSk7XG52YXIgc3RvcGxpZ2h0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbC9zdG9wbGlnaHRcIikpO1xudmFyIFdlYjNQcm92aWRlckVuZ2luZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoV2ViM1Byb3ZpZGVyRW5naW5lLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFdlYjNQcm92aWRlckVuZ2luZShvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9wb2xsRm9yQmxvY2tzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuc2V0TWF4TGlzdGVuZXJzKDMwKTtcbiAgICAgICAgLy8gcGFyc2Ugb3B0aW9uc1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgLy8gYmxvY2sgcG9sbGluZ1xuICAgICAgICB2YXIgZGlyZWN0UHJvdmlkZXIgPSB7XG4gICAgICAgICAgICBzZW5kQXN5bmM6IGZ1bmN0aW9uIChyZXEsIGNiKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2VuZFBheWxvYWQocmVxKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0cy5kaXNhYmxlQmxvY2tUcmFja2luZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgX3RoaXMuX3BvbGxGb3JCbG9ja3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmxvY2tUcmFja2VyUHJvdmlkZXIgPSBvcHRzLmJsb2NrVHJhY2tlclByb3ZpZGVyIHx8IGRpcmVjdFByb3ZpZGVyO1xuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyID0gbmV3IGJsb2NrX3RyYWNrZXJfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBibG9ja1RyYWNrZXJQcm92aWRlcixcbiAgICAgICAgICAgIGJsb2NrVHJhY2tlcjogb3B0cy5ibG9ja1RyYWNrZXIsXG4gICAgICAgICAgICBwb2xsaW5nSW50ZXJ2YWw6IG9wdHMucG9sbGluZ0ludGVydmFsIHx8IDQwMDAsXG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyLm9uKCdibG9jaycsIF90aGlzLl9zZXRDdXJyZW50QmxvY2suYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyLm9uKCdzeW5jJywgX3RoaXMuZW1pdC5iaW5kKF90aGlzLCAnc3luYycpKTtcbiAgICAgICAgX3RoaXMuX2Jsb2NrVHJhY2tlci5vbigncmF3QmxvY2snLCBfdGhpcy5lbWl0LmJpbmQoX3RoaXMsICdyYXdCbG9jaycpKTtcbiAgICAgICAgX3RoaXMuX2Jsb2NrVHJhY2tlci5vbignbGF0ZXN0JywgX3RoaXMuZW1pdC5iaW5kKF90aGlzLCAnbGF0ZXN0JykpO1xuICAgICAgICAvLyBIYW5kbGUgZXJyb3JzIGluc3RlYWQgb2YgcmUtZW1pdHRpbmcsIHNpbmNlIHRoZXkgd2lsbCB0aHJvdyBvdGhlcndpc2VcbiAgICAgICAgX3RoaXMuX2Jsb2NrVHJhY2tlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlcnJvcnMgZnJvbSB0aGUgYmxvY2sgdHJhY2tlciB1bmxlc3MgZGVidWcgaXMgZW5hYmxlZFxuICAgICAgICAgICAgaWYgKG9wdHMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnREVCVUc6ICcgKyBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHNldCBpbml0aWFsaXphdGlvbiBibG9ja2VyXG4gICAgICAgIF90aGlzLl9yZWFkeSA9IG5ldyBzdG9wbGlnaHRfMS5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLl9wcm92aWRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XG4gICAgfTtcbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB0cmlnZ2VyIHN0YXJ0XG4gICAgICAgIHRoaXMuX3JlYWR5LmdvKCk7XG4gICAgICAgIGlmICh0aGlzLl9wb2xsRm9yQmxvY2tzKSB7XG4gICAgICAgICAgICAvLyBzdGFydCB0cmFja2luZyBibG9ja3NcbiAgICAgICAgICAgIHRoaXMuX2Jsb2NrVHJhY2tlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBzdGF0ZVxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgLy8gc2lnbmFsIHRoYXQgd2Ugc3RhcnRlZFxuICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0Jyk7XG4gICAgfTtcbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHN0b3AgYmxvY2sgdHJhY2tpbmdcbiAgICAgICAgdGhpcy5fYmxvY2tUcmFja2VyLnN0b3AoKTtcbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLy8gc2lnbmFsIHRoYXQgd2Ugc3RvcHBlZFxuICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnKTtcbiAgICB9O1xuICAgIFdlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuYWRkUHJvdmlkZXIgPSBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuX3Byb3ZpZGVycy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZS5zZXRFbmdpbmUodGhpcyk7XG4gICAgfTtcbiAgICBXZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV3JhcCBiYXNlIGNsYXNzIHdpdGggU3RvcGxpZ2h0XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XG4gICAgICAgICAgICBfdGhpcy5fcmVhZHkuYXdhaXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2VuZC5jYWxsKF90aGlzLCBtZXRob2QsIHBhcmFtcykudGhlbihmdWxmaWxsLCByZWplY3QpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gV3JhcCBiYXNlIGNsYXNzIHdpdGggU3RvcGxpZ2h0XG4gICAgICAgIHRoaXMuX3JlYWR5LmF3YWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc2VuZEFzeW5jLmNhbGwoX3RoaXMsIHBheWxvYWQsIGNiKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBBY3R1YWxseSBwZXJmb3JtIHRoZSByZXF1ZXN0XG4gICAgV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5zZW5kUGF5bG9hZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoZnVsZmlsbCwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFByb3ZpZGVyID0gLTE7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAgICAgICAgICAvLyBTdGFjayBvZiBzdWJwcm92aWRlciBuZXh0IGNhbGxiYWNrc1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gW107XG4gICAgICAgICAgICB2YXIgbmV4dCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQcm92aWRlciArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgaW4gZnJvbnQgc2luY2UgZWFjaFNlcmllcyB0cmF2ZXJzZXMgZnJvbSBmcm9udFxuICAgICAgICAgICAgICAgICAgICBzdGFjay51bnNoaWZ0KGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQnViYmxlZCBkb3duIGFzIGZhciBhcyB3ZSBjb3VsZCBnbywgYW5kIHRoZSByZXF1ZXN0IHdhc24ndFxuICAgICAgICAgICAgICAgIC8vIGhhbmRsZWQuIFJldHVybiBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFByb3ZpZGVyID49IF90aGlzLl9wcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSBcIlJlcXVlc3QgZm9yIG1ldGhvZCBcXFwiXCIgKyBwYXlsb2FkLm1ldGhvZCArIFwiXFxcIiBub3QgaGFuZGxlZCBieSBhbnkgc3VicHJvdmlkZXIuXCI7XG4gICAgICAgICAgICAgICAgICAgIGVuZChuZXcgcHJvdmlkZXJfZW5naW5lX2Vycm9yXzEuUHJvdmlkZXJFbmdpbmVFcnJvcihtc2csIHByb3ZpZGVyX2VuZ2luZV9lcnJvcl8xLlByb3ZpZGVyRW5naW5lRXJyb3JDb2RlLlVuaGFuZGxlZFJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgcmVxdWVzdCBpbiBuZXh0IHN1YnByb3ZpZGVyXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gX3RoaXMuX3Byb3ZpZGVyc1tjdXJyZW50UHJvdmlkZXJdO1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlci5oYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIG5vdGlmeVN1YnByb3ZpZGVyID0gZnVuY3Rpb24gKGZuLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICBmbihlcnJvciwgcmVzdWx0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZW5kID0gZnVuY3Rpb24gKGUsIHIpIHtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGU7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcjtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGFueSBjYWxsYmFja3MgZnJvbSBzdWJwcm92aWRlcnNcbiAgICAgICAgICAgICAgICBlYWNoU2VyaWVzXzEuZGVmYXVsdChzdGFjaywgbm90aWZ5U3VicHJvdmlkZXIpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZWNvbnN0cnVjdCBKU09OUlBDUmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdE9iaiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwYXlsb2FkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogcGF5bG9hZC5qc29ucnBjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbXBsZXRlIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHRPYmopO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gQ2FsbCBuZXh0KCkgdG8ga2ljayB0aGluZ3Mgb2ZmXG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5fc2V0Q3VycmVudEJsb2NrID0gZnVuY3Rpb24gKGJ1ZmZlckJsb2NrKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJsb2NrID0gYnVmZmVyQmxvY2s7XG4gICAgICAgIHRoaXMuZW1pdCgnYmxvY2snLCBidWZmZXJCbG9jayk7XG4gICAgfTtcbiAgICByZXR1cm4gV2ViM1Byb3ZpZGVyRW5naW5lO1xufShiYXNlX3Byb3ZpZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gV2ViM1Byb3ZpZGVyRW5naW5lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgY3JlYXRlX3BheWxvYWRfMSA9IHJlcXVpcmUoXCIuL3V0aWwvY3JlYXRlLXBheWxvYWRcIik7XG4vLyB0aGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhIHN1YnByb3ZpZGVyIC0tIG1vc3RseSBoZWxwZXJzXG52YXIgU3VicHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN1YnByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN1YnByb3ZpZGVyLnByb3RvdHlwZS5zZXRFbmdpbmUgPSBmdW5jdGlvbiAoZW5naW5lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICBlbmdpbmUub24oJ2Jsb2NrJywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50QmxvY2sgPSBibG9jaztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJwcm92aWRlci5wcm90b3R5cGUuZW1pdFBheWxvYWQgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2IpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuc2VuZEFzeW5jKGNyZWF0ZV9wYXlsb2FkXzEuY3JlYXRlUGF5bG9hZChwYXlsb2FkKSwgY2IpO1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnByb3ZpZGVyO1xufShldmVudHNfMS5FdmVudEVtaXR0ZXIpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFN1YnByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG52YXIgZXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL2V0aC11dGlsXCIpO1xudmFyIHJwY19jYWNoZV91dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvcnBjLWNhY2hlLXV0aWxzXCIpO1xudmFyIGNhY2hlX3N0cmF0ZWd5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY2FjaGUtc3RyYXRlZ3lcIikpO1xuLy9cbi8vIEJsb2NrQ2FjaGVTdHJhdGVneVxuLy9cbnZhciBCbG9ja0NhY2hlU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrQ2FjaGVTdHJhdGVneSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja0NhY2hlU3RyYXRlZ3koKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNhY2hlID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmxvY2tDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBibG9ja051bWJlckhleCkge1xuICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBwYXJzZUludChibG9ja051bWJlckhleCwgMTYpO1xuICAgICAgICB2YXIgYmxvY2tDYWNoZSA9IHRoaXMuY2FjaGVbYmxvY2tOdW1iZXJdO1xuICAgICAgICAvLyBjcmVhdGUgbmV3IGNhY2hlIGlmIG5lY2VzYXJ5XG4gICAgICAgIGlmICghYmxvY2tDYWNoZSkge1xuICAgICAgICAgICAgdmFyIG5ld0NhY2hlID0ge307XG4gICAgICAgICAgICB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXSA9IG5ld0NhY2hlO1xuICAgICAgICAgICAgYmxvY2tDYWNoZSA9IG5ld0NhY2hlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibG9ja0NhY2hlO1xuICAgIH07XG4gICAgQmxvY2tDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5oaXRDaGVjayA9IGZ1bmN0aW9uIChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgaGl0LCBtaXNzKSB7XG4gICAgICAgIHZhciBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGlmICghYmxvY2tDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1pc3MoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHJwY19jYWNoZV91dGlsc18xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIHZhciBjYWNoZWQgPSBibG9ja0NhY2hlW2lkZW50aWZpZXJdO1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkVmFsdWUgPSBjbG9uZV8xLmRlZmF1bHQoY2FjaGVkKTtcbiAgICAgICAgICAgIHJldHVybiBoaXQobnVsbCwgY2xvbmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1pc3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQmxvY2tDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCByZXN1bHQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgYmxvY2tDYWNoZSA9IHRoaXMuZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBycGNfY2FjaGVfdXRpbHNfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgdmFyIGNsb25lZFZhbHVlID0gY2xvbmVfMS5kZWZhdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICBibG9ja0NhY2hlW2lkZW50aWZpZXJdID0gY2xvbmVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIEJsb2NrQ2FjaGVTdHJhdGVneS5wcm90b3R5cGUuY2FuQ2FjaGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICBpZiAoIXJwY19jYWNoZV91dGlsc18xLmNhbkNhY2hlKHBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsb2NrVGFnID0gcnBjX2NhY2hlX3V0aWxzXzEuYmxvY2tUYWdGb3JQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gKGJsb2NrVGFnICE9PSAncGVuZGluZycpO1xuICAgIH07XG4gICAgLy8gbmFpdmVseSByZW1vdmVzIG9sZGVyIGJsb2NrIGNhY2hlc1xuICAgIEJsb2NrQ2FjaGVTdHJhdGVneS5wcm90b3R5cGUuY2FjaGVSb2xsT2ZmID0gZnVuY3Rpb24gKHByZXZpb3VzQmxvY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHByZXZpb3VzSGV4ID0gZXRoX3V0aWxfMS5idWZmZXJUb0hleChwcmV2aW91c0Jsb2NrLm51bWJlcik7XG4gICAgICAgIHZhciBvbGRCbG9ja051bWJlciA9IHBhcnNlSW50KHByZXZpb3VzSGV4LCAxNik7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jYWNoZSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAobnVtKSB7IHJldHVybiBudW0gPD0gb2xkQmxvY2tOdW1iZXI7IH0pXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobnVtKSB7IHJldHVybiBkZWxldGUgX3RoaXMuY2FjaGVbbnVtXTsgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tDYWNoZVN0cmF0ZWd5O1xufShjYWNoZV9zdHJhdGVneV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrQ2FjaGVTdHJhdGVneTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENhY2hlU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FjaGVTdHJhdGVneSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIENhY2hlU3RyYXRlZ3k7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2FjaGVTdHJhdGVneTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2FjaGVfc3RyYXRlZ3lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jYWNoZS1zdHJhdGVneVwiKSk7XG52YXIgcGVybWFfY2FjaGVfc3RyYXRlZ3lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wZXJtYS1jYWNoZS1zdHJhdGVneVwiKSk7XG4vL1xuLy8gQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3lcbi8vXG52YXIgQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3kgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmRpdGlvbmFsUGVybWFDYWNoZVN0cmF0ZWd5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmRpdGlvbmFsUGVybWFDYWNoZVN0cmF0ZWd5KGNvbmRpdGlvbmFscykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJhdGVneSA9IG5ldyBwZXJtYV9jYWNoZV9zdHJhdGVneV8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMuY29uZGl0aW9uYWxzID0gY29uZGl0aW9uYWxzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmRpdGlvbmFsUGVybWFDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5oaXRDaGVjayA9IGZ1bmN0aW9uIChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgaGl0LCBtaXNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmhpdENoZWNrKHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBoaXQsIG1pc3MpO1xuICAgIH07XG4gICAgQ29uZGl0aW9uYWxQZXJtYUNhY2hlU3RyYXRlZ3kucHJvdG90eXBlLmNhY2hlUmVzdWx0ID0gZnVuY3Rpb24gKHBheWxvYWQsIHJlc3VsdCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjb25kaXRpb25hbCA9IHRoaXMuY29uZGl0aW9uYWxzW3BheWxvYWQubWV0aG9kXTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbmFsKSB7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uYWwocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyYXRlZ3kuY2FjaGVSZXN1bHQocGF5bG9hZCwgcmVzdWx0LCByZXF1ZXN0ZWRCbG9ja051bWJlciwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhY2hlIGFsbCByZXF1ZXN0cyB0aGF0IGRvbid0IGhhdmUgYSBjb25kaXRpb25hbFxuICAgICAgICAgICAgdGhpcy5zdHJhdGVneS5jYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbmRpdGlvbmFsUGVybWFDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5jYW5DYWNoZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmF0ZWd5LmNhbkNhY2hlKHBheWxvYWQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmRpdGlvbmFsUGVybWFDYWNoZVN0cmF0ZWd5O1xufShjYWNoZV9zdHJhdGVneV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbmRpdGlvbmFsUGVybWFDYWNoZVN0cmF0ZWd5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG52YXIgcnBjX2NhY2hlX3V0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9ycGMtY2FjaGUtdXRpbHNcIik7XG52YXIgY2FjaGVfc3RyYXRlZ3lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jYWNoZS1zdHJhdGVneVwiKSk7XG52YXIgUGVybWFDYWNoZVN0cmF0ZWd5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQZXJtYUNhY2hlU3RyYXRlZ3ksIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGVybWFDYWNoZVN0cmF0ZWd5KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jYWNoZSA9IHt9O1xuICAgICAgICAvLyBjbGVhciBjYWNoZSBldmVyeSB0ZW4gbWludXRlc1xuICAgICAgICB2YXIgdGltZW91dCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNhY2hlID0ge307XG4gICAgICAgIH0sIDEwICogNjAgKiAxZTMpO1xuICAgICAgICAvLyBkbyBub3QgcmVxdWlyZSB0aGUgTm9kZS5qcyBldmVudCBsb29wIHRvIHJlbWFpbiBhY3RpdmVcbiAgICAgICAgaWYgKHRpbWVvdXQudW5yZWYpIHtcbiAgICAgICAgICAgIHRpbWVvdXQudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFBlcm1hQ2FjaGVTdHJhdGVneS5wcm90b3R5cGUuaGl0Q2hlY2sgPSBmdW5jdGlvbiAocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIGhpdCwgbWlzcykge1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHJwY19jYWNoZV91dGlsc18xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIHZhciBjYWNoZWQgPSB0aGlzLmNhY2hlW2lkZW50aWZpZXJdO1xuICAgICAgICBpZiAoIWNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG1pc3MoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgYmxvY2sgbnVtYmVyIHdlJ3JlIHJlcXVlc3RpbmcgYXQgaXMgZ3JlYXRlciB0aGFuIG9yXG4gICAgICAgIC8vIGVxdWFsIHRvIHRoZSBibG9jayB3aGVyZSB3ZSBjYWNoZWQgYSBwcmV2aW91cyByZXNwb25zZSxcbiAgICAgICAgLy8gdGhlIGNhY2hlIGlzIHZhbGlkLiBJZiBpdCdzIGZyb20gZWFybGllciB0aGFuIHRoZSBjYWNoZSxcbiAgICAgICAgLy8gc2VuZCBpdCBiYWNrIGRvd24gdG8gdGhlIGNsaWVudCAod2hlcmUgaXQgd2lsbCBiZSByZWNhY2hlZC4pXG4gICAgICAgIHZhciBjYWNoZUlzRWFybHlFbm91Z2ggPSBjb21wYXJlSGV4KHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBjYWNoZWQuYmxvY2tOdW1iZXIpID49IDA7XG4gICAgICAgIGlmIChjYWNoZUlzRWFybHlFbm91Z2gpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRWYWx1ZSA9IGNsb25lXzEuZGVmYXVsdChjYWNoZWQucmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBoaXQobnVsbCwgY2xvbmVkVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1pc3MoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGVybWFDYWNoZVN0cmF0ZWd5LnByb3RvdHlwZS5jYWNoZVJlc3VsdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCByZXN1bHQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHJwY19jYWNoZV91dGlsc18xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZWRWYWx1ZSA9IGNsb25lXzEuZGVmYXVsdChyZXN1bHQpO1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtpZGVudGlmaWVyXSA9IHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlcjogcmVxdWVzdGVkQmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjbG9uZWRWYWx1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIFBlcm1hQ2FjaGVTdHJhdGVneS5wcm90b3R5cGUuY2FuQ2FjaGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICByZXR1cm4gcnBjX2NhY2hlX3V0aWxzXzEuY2FuQ2FjaGUocGF5bG9hZCk7XG4gICAgfTtcbiAgICByZXR1cm4gUGVybWFDYWNoZVN0cmF0ZWd5O1xufShjYWNoZV9zdHJhdGVneV8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFBlcm1hQ2FjaGVTdHJhdGVneTtcbmZ1bmN0aW9uIGNvbXBhcmVIZXgoaGV4QSwgaGV4Qikge1xuICAgIHZhciBudW1BID0gcGFyc2VJbnQoaGV4QSwgMTYpO1xuICAgIHZhciBudW1CID0gcGFyc2VJbnQoaGV4QiwgMTYpO1xuICAgIHJldHVybiBudW1BID09PSBudW1CID8gMCA6IChudW1BID4gbnVtQiA/IDEgOiAtMSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zdWJwcm92aWRlclwiKSk7XG52YXIgZXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2V0aC11dGlsXCIpO1xudmFyIHJwY19jYWNoZV91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWwvcnBjLWNhY2hlLXV0aWxzXCIpO1xudmFyIGJsb2NrX3N0cmF0ZWd5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY2FjaGUtc3RyYXRlZ2llcy9ibG9jay1zdHJhdGVneVwiKSk7XG52YXIgY29uZGl0aW9uYWxfcGVybWFfc3RyYXRlZ3lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jYWNoZS1zdHJhdGVnaWVzL2NvbmRpdGlvbmFsLXBlcm1hLXN0cmF0ZWd5XCIpKTtcbnZhciBCbG9ja0NhY2hlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrQ2FjaGVQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja0NhY2hlUHJvdmlkZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5zdHJhdGVnaWVzID0ge1xuICAgICAgICAgICAgcGVybWE6IG5ldyBjb25kaXRpb25hbF9wZXJtYV9zdHJhdGVneV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaDogY29udGFpbnNCbG9ja2hhc2gsXG4gICAgICAgICAgICAgICAgZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdDogY29udGFpbnNCbG9ja2hhc2gsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGJsb2NrOiBuZXcgYmxvY2tfc3RyYXRlZ3lfMS5kZWZhdWx0KCksXG4gICAgICAgICAgICBmb3JrOiBuZXcgYmxvY2tfc3RyYXRlZ3lfMS5kZWZhdWx0KCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gc2V0dXAgYSBibG9jayBsaXN0ZW5lciBvbiAnc2V0RW5naW5lJ1xuICAgIEJsb2NrQ2FjaGVQcm92aWRlci5wcm90b3R5cGUuc2V0RW5naW5lID0gZnVuY3Rpb24gKGVuZ2luZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnNldEVuZ2luZS5jYWxsKHRoaXMsIGVuZ2luZSk7XG4gICAgICAgIC8vIHVuYmxvY2sgaW5pdGlhbGl6YXRpb24gYWZ0ZXIgZmlyc3QgYmxvY2tcbiAgICAgICAgZW5naW5lLm9uY2UoJ2Jsb2NrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIGZyb20gbm93IG9uLCBlbXB0eSBvbGQgY2FjaGUgZXZlcnkgYmxvY2tcbiAgICAgICAgICAgIGVuZ2luZS5vbignYmxvY2snLCBfdGhpcy5jbGVhck9sZENhY2hlLmJpbmQoX3RoaXMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCbG9ja0NhY2hlUHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIC8vIHNraXAgY2FjaGUgaWYgdG9sZCB0byBkbyBzb1xuICAgICAgICBpZiAocGF5bG9hZC5za2lwQ2FjaGUpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDQUNIRSBTS0lQIC0gc2tpcCBjYWNoZSBpZiB0b2xkIHRvIGRvIHNvJylcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIHJlcXVlc3RzIGZvciB0aGUgbGF0ZXN0IGJsb2NrXG4gICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyAmJiBwYXlsb2FkLnBhcmFtc1swXSA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDQUNIRSBTS0lQIC0gSWdub3JlIGJsb2NrIHBvbGxpbmcgcmVxdWVzdHMuJylcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmxvY2sgY2FjaGUgc2hvdWxkIG5vdCBzdGFydCBoYW5kbGluZyByZXF1ZXN0cyB1bnRpbCBibG9ja3MgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICAgICAgICBpZiAoIXRoaXMuaXNFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFjdHVhbGx5IGhhbmRsZSB0aGUgcmVxdWVzdFxuICAgICAgICB0aGlzLl9oYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCk7XG4gICAgfTtcbiAgICBCbG9ja0NhY2hlUHJvdmlkZXIucHJvdG90eXBlLl9oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICB2YXIgdHlwZSA9IHJwY19jYWNoZV91dGlsc18xLmNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgIHZhciBzdHJhdGVneSA9IHRoaXMuc3RyYXRlZ2llc1t0eXBlXTtcbiAgICAgICAgLy8gSWYgdGhlcmUncyBubyBzdHJhdGVneSBpbiBwbGFjZSwgcGFzcyBpdCBkb3duIHRoZSBjaGFpbi5cbiAgICAgICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgc3RyYXRlZ3kgY2FuJ3QgY2FjaGUgdGhpcyByZXF1ZXN0LCBpZ25vcmUgaXQuXG4gICAgICAgIGlmICghc3RyYXRlZ3kuY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJsb2NrVGFnID0gcnBjX2NhY2hlX3V0aWxzXzEuYmxvY2tUYWdGb3JQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICBpZiAoIWJsb2NrVGFnKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXF1ZXN0ZWRCbG9ja051bWJlcjtcbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSAnZWFybGllc3QnKSB7XG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9ICcweDAwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibG9ja1RhZyA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gZXRoX3V0aWxfMS5idWZmZXJUb0hleCh0aGlzLmN1cnJlbnRCbG9jay5udW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIGhleCBudW1iZXJcbiAgICAgICAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gYmxvY2tUYWc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFUVVFU1QgYXQgYmxvY2sgMHgnICsgcmVxdWVzdGVkQmxvY2tOdW1iZXIudG9TdHJpbmcoJ2hleCcpKVxuICAgICAgICAvLyBlbmQgb24gYSBoaXQsIGNvbnRpbnVlIG9uIGEgbWlzc1xuICAgICAgICBzdHJhdGVneS5oaXRDaGVjayhwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgZW5kLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBtaXNzIGZhbGx0aHJvdWdoIHRvIHByb3ZpZGVyIGNoYWluLCBjYWNoaW5nIHRoZSByZXN1bHQgb24gdGhlIHdheSBiYWNrIHVwLlxuICAgICAgICAgICAgbmV4dChmdW5jdGlvbiAoZXJyLCByZXN1bHQsIGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gZXJyIGlzIGFscmVhZHkgaGFuZGxlZCBieSBlbmdpbmVcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHJhdGVneS5jYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCbG9ja0NhY2hlUHJvdmlkZXIucHJvdG90eXBlLmNsZWFyT2xkQ2FjaGUgPSBmdW5jdGlvbiAobmV3QmxvY2spIHtcbiAgICAgICAgdmFyIHByZXZpb3VzQmxvY2sgPSB0aGlzLmN1cnJlbnRCbG9jaztcbiAgICAgICAgdGhpcy5jdXJyZW50QmxvY2sgPSBuZXdCbG9jaztcbiAgICAgICAgaWYgKCFwcmV2aW91c0Jsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzLmJsb2NrLmNhY2hlUm9sbE9mZihwcmV2aW91c0Jsb2NrKTtcbiAgICAgICAgdGhpcy5zdHJhdGVnaWVzLmZvcmsuY2FjaGVSb2xsT2ZmKHByZXZpb3VzQmxvY2spO1xuICAgIH07XG4gICAgcmV0dXJuIEJsb2NrQ2FjaGVQcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBCbG9ja0NhY2hlUHJvdmlkZXI7XG5mdW5jdGlvbiBoZXhUb0JOKGhleCkge1xuICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGV0aF91dGlsXzEudG9CdWZmZXIoaGV4KSk7XG59XG5mdW5jdGlvbiBjb250YWluc0Jsb2NraGFzaChyZXN1bHQpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghcmVzdWx0LmJsb2NrSGFzaCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBoYXNOb25aZXJvSGFzaCA9IGhleFRvQk4ocmVzdWx0LmJsb2NrSGFzaCkuZ3QobmV3IGJuX2pzXzEuZGVmYXVsdCgwKSk7XG4gICAgcmV0dXJuIGhhc05vblplcm9IYXNoO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4dGVuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ4dGVuZFwiKSk7XG52YXIgZml4dHVyZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpeHR1cmVcIikpO1xudmFyIERlZmF1bHRGaXh0dXJlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdEZpeHR1cmVzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRGaXh0dXJlcyhvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICB2YXIgcmVzcG9uc2VzID0geHRlbmRfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHdlYjNfY2xpZW50VmVyc2lvbjogJ1Byb3ZpZGVyRW5naW5lJyArICcvamF2YXNjcmlwdCcsXG4gICAgICAgICAgICBuZXRfbGlzdGVuaW5nOiB0cnVlLFxuICAgICAgICAgICAgZXRoX2hhc2hyYXRlOiAnMHgwMCcsXG4gICAgICAgICAgICBldGhfbWluaW5nOiBmYWxzZSxcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVzcG9uc2VzKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBEZWZhdWx0Rml4dHVyZXM7XG59KGZpeHR1cmVfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZhdWx0Rml4dHVyZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFzeW5jaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL2FzeW5jaWZ5XCIpKTtcbnZhciByZXRyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3luYy9yZXRyeVwiKSk7XG52YXIgd2F0ZXJmYWxsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL3dhdGVyZmFsbFwiKSk7XG52YXIgY3Jvc3NfZmV0Y2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY3Jvc3MtZmV0Y2hcIikpO1xudmFyIGpzb25fcnBjX2Vycm9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLWVycm9yXCIpKTtcbnZhciBwcm9taXNlX3RvX2NhbGxiYWNrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb21pc2UtdG8tY2FsbGJhY2tcIikpO1xudmFyIHN1YnByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3N1YnByb3ZpZGVyXCIpKTtcbnZhciBjcmVhdGVfcGF5bG9hZF8xID0gcmVxdWlyZShcIi4uL3V0aWwvY3JlYXRlLXBheWxvYWRcIik7XG52YXIgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ1N5bnRheEVycm9yJyxcbl07XG52YXIgRmV0Y2hTdWJwcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmV0Y2hTdWJwcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGZXRjaFN1YnByb3ZpZGVyKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucnBjVXJsID0gb3B0cy5ycGNVcmw7XG4gICAgICAgIF90aGlzLm9yaWdpbkh0dHBIZWFkZXJLZXkgPSBvcHRzLm9yaWdpbkh0dHBIZWFkZXJLZXk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmV0Y2hTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG9yaWdpbkRvbWFpbiA9IHBheWxvYWQub3JpZ2luO1xuICAgICAgICAvLyBvdmVyd3JpdGUgaWQgdG8gbm90IGNvbmZsaWN0IHdpdGggb3RoZXIgY29uY3VycmVudCB1c2Vyc1xuICAgICAgICB2YXIgbmV3UGF5bG9hZCA9IHRoaXMuY3JlYXRlUGF5bG9hZChwYXlsb2FkKTtcbiAgICAgICAgLy8gcmVtb3ZlIGV4dHJhIHBhcmFtZXRlciBmcm9tIHJlcXVlc3RcbiAgICAgICAgZGVsZXRlIG5ld1BheWxvYWQub3JpZ2luO1xuICAgICAgICB2YXIgcmVxUGFyYW1zID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5ld1BheWxvYWQpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgICAgICAgICAgcmVxUGFyYW1zLmhlYWRlcnNbdGhpcy5vcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpbjtcbiAgICAgICAgfVxuICAgICAgICByZXRyeV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgdGltZXM6IDUsXG4gICAgICAgICAgICBpbnRlcnZhbDogMTAwMCxcbiAgICAgICAgICAgIGVycm9yRmlsdGVyOiBpc0Vycm9yUmV0cmlhYmxlLFxuICAgICAgICB9LCBmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIF90aGlzLl9zdWJtaXRSZXF1ZXN0KHJlcVBhcmFtcywgY2IpOyB9LCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIC8vIGVuZHMgb24gcmV0cmlhYmxlIGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyICYmIGlzRXJyb3JSZXRyaWFibGUoZXJyKSkge1xuICAgICAgICAgICAgICAgIHZhciBlcnJNc2cgPSBcIkZldGNoU3VicHJvdmlkZXIgLSBjYW5ub3QgY29tcGxldGUgcmVxdWVzdC4gQWxsIHJldHJpZXMgZXhoYXVzdGVkLlxcbk9yaWdpbmFsIEVycm9yOlxcblwiICsgZXJyLnRvU3RyaW5nKCkgKyBcIlxcblxcblwiO1xuICAgICAgICAgICAgICAgIHZhciByZXRyaWVzRXhoYXVzdGVkRXJyID0gbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZChyZXRyaWVzRXhoYXVzdGVkRXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjb250aW51ZSBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGVuZChlcnIsIHJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRmV0Y2hTdWJwcm92aWRlci5wcm90b3R5cGUuY3JlYXRlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVfcGF5bG9hZF8xLmNyZWF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgfTtcbiAgICBGZXRjaFN1YnByb3ZpZGVyLnByb3RvdHlwZS5fc3VibWl0UmVxdWVzdCA9IGZ1bmN0aW9uIChyZXFQYXJhbXMsIGRvbmUpIHtcbiAgICAgICAgdmFyIHRhcmdldFVybCA9IHRoaXMucnBjVXJsO1xuICAgICAgICBwcm9taXNlX3RvX2NhbGxiYWNrXzEuZGVmYXVsdChjcm9zc19mZXRjaF8xLmRlZmF1bHQodGFyZ2V0VXJsLCByZXFQYXJhbXMpKShmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29udGludWUgcGFyc2luZyByZXN1bHRcbiAgICAgICAgICAgIHdhdGVyZmFsbF8xLmRlZmF1bHQoW1xuICAgICAgICAgICAgICAgIGNoZWNrRm9ySHR0cEVycm9ycyxcbiAgICAgICAgICAgICAgICAvLyBidWZmZXIgYm9keVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjYikgeyByZXR1cm4gcHJvbWlzZV90b19jYWxsYmFja18xLmRlZmF1bHQocmVzLnRleHQoKSkoY2IpOyB9LFxuICAgICAgICAgICAgICAgIC8vIHBhcnNlIGJvZHlcbiAgICAgICAgICAgICAgICBhc3luY2lmeV8xLmRlZmF1bHQoZnVuY3Rpb24gKHJhd0JvZHkpIHsgcmV0dXJuIEpTT04ucGFyc2UocmF3Qm9keSk7IH0pLFxuICAgICAgICAgICAgICAgIHBhcnNlUmVzcG9uc2UsXG4gICAgICAgICAgICBdLCBkb25lKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrRm9ySHR0cEVycm9ycyhjYikge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBlcnJvcnNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlcy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IobmV3IGpzb25fcnBjX2Vycm9yXzEuZGVmYXVsdC5NZXRob2ROb3RGb3VuZCgpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0MTg6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIDUwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihjcmVhdGVUaW1lb3V0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGJvZHksIGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgICAgICAgICAgICAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihuZXcganNvbl9ycGNfZXJyb3JfMS5kZWZhdWx0LkludGVybmFsRXJyb3IoYm9keSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgcnBjIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKG5ldyBqc29uX3JwY19lcnJvcl8xLmRlZmF1bHQuSW50ZXJuYWxFcnJvcihib2R5LmVycm9yKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBzdWNjZXNzZnVsIHJlc3VsdFxuICAgICAgICAgICAgICAgIGNiKG51bGwsIGJvZHkucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmV0Y2hTdWJwcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGZXRjaFN1YnByb3ZpZGVyO1xuZnVuY3Rpb24gaXNFcnJvclJldHJpYWJsZShlcnIpIHtcbiAgICB2YXIgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIFJFVFJJQUJMRV9FUlJPUlMuc29tZShmdW5jdGlvbiAocGhyYXNlKSB7IHJldHVybiBlcnJNc2cuaW5jbHVkZXMocGhyYXNlKTsgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVSYXRlbGltaXRFcnJvcigpIHtcbiAgICB2YXIgbXNnID0gXCJSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5cIjtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgcmV0dXJuIG5ldyBqc29uX3JwY19lcnJvcl8xLmRlZmF1bHQuSW50ZXJuYWxFcnJvcihlcnIpO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIHZhciBtc2cgPSBcIkdhdGV3YXkgdGltZW91dC4gVGhlIHJlcXVlc3QgdG9vayB0b28gbG9uZyB0byBwcm9jZXNzLiBcIjtcbiAgICBtc2cgKz0gXCJUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5cIjtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gICAgcmV0dXJuIG5ldyBqc29uX3JwY19lcnJvcl8xLmRlZmF1bHQuSW50ZXJuYWxFcnJvcihlcnIpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwYXJhbGxlbF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3luYy9wYXJhbGxlbFwiKSk7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc3VicHJvdmlkZXJcIikpO1xudmFyIGV0aF91dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ldGgtdXRpbFwiKTtcbnZhciBzdG9wbGlnaHRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vdXRpbC9zdG9wbGlnaHRcIikpO1xudmFyIGJsb2NrX2ZpbHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlcnMvYmxvY2stZmlsdGVyXCIpKTtcbnZhciBsb2dfZmlsdGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZmlsdGVycy9sb2ctZmlsdGVyXCIpKTtcbnZhciBwZW5kaW5nX3R4X2ZpbHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlcnMvcGVuZGluZy10eC1maWx0ZXJcIikpO1xudmFyIEZpbHRlclN1YnByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXJTdWJwcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdWJwcm92aWRlcihvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBfdGhpcy5maWx0ZXJJbmRleCA9IDA7XG4gICAgICAgIF90aGlzLmZpbHRlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuZmlsdGVyRGVzdHJveUhhbmRsZXJzID0ge307XG4gICAgICAgIF90aGlzLmFzeW5jQmxvY2tIYW5kbGVycyA9IHt9O1xuICAgICAgICBfdGhpcy5hc3luY1BlbmRpbmdCbG9ja0hhbmRsZXJzID0ge307XG4gICAgICAgIF90aGlzLl9yZWFkeSA9IG5ldyBzdG9wbGlnaHRfMS5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLl9yZWFkeS5zZXRNYXhMaXN0ZW5lcnMob3B0cy5tYXhGaWx0ZXJzIHx8IDI1KTtcbiAgICAgICAgX3RoaXMuX3JlYWR5LmdvKCk7XG4gICAgICAgIF90aGlzLnBlbmRpbmdCbG9ja1RpbWVvdXQgPSBvcHRzLnBlbmRpbmdCbG9ja1RpbWVvdXQgfHwgNDAwMDtcbiAgICAgICAgX3RoaXMuY2hlY2tGb3JQZW5kaW5nQmxvY2tzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8vIFRPRE86IEFjdHVhbGx5IGxvYWQgdGhlIGJsb2Nrc1xuICAgICAgICAvLyB3ZSBkb250IGhhdmUgZW5naW5lIGltbWVkaXRhdGVseVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGFzeW5jQmxvY2tIYW5kbGVycyByZXF1aXJlIGxvY2tpbmcgcHJvdmlkZXIgdW50aWwgdXBkYXRlcyBhcmUgY29tcGxldGVkXG4gICAgICAgICAgICBfdGhpcy5lbmdpbmUub24oJ2Jsb2NrJywgZnVuY3Rpb24gKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgLy8gcGF1c2UgcHJvY2Vzc2luZ1xuICAgICAgICAgICAgICAgIF90aGlzLl9yZWFkeS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGZpbHRlcnNcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlcnMgPSB2YWx1ZXNGb3IoX3RoaXMuYXN5bmNCbG9ja0hhbmRsZXJzKS5tYXAoZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbi5iaW5kKG51bGwsIGJsb2NrKTsgfSk7XG4gICAgICAgICAgICAgICAgcGFyYWxsZWxfMS5kZWZhdWx0KHVwZGF0ZXJzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdW5wYXVzZSBwcm9jZXNzaW5nXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9yZWFkeS5nbygpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlICdldGhfbmV3QmxvY2tGaWx0ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMubmV3QmxvY2tGaWx0ZXIoZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcihlbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JQZW5kaW5nQmxvY2tzKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZXRoX25ld0ZpbHRlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdMb2dGaWx0ZXIocGF5bG9hZC5wYXJhbXNbMF0sIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSAnZXRoX2dldEZpbHRlckNoYW5nZXMnOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5LmF3YWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZ2V0RmlsdGVyQ2hhbmdlcyhwYXlsb2FkLnBhcmFtc1swXSwgZW5kKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZHkuYXdhaXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5nZXRGaWx0ZXJMb2dzKHBheWxvYWQucGFyYW1zWzBdLCBlbmQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOlxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWR5LmF3YWl0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMudW5pbnN0YWxsRmlsdGVyKHBheWxvYWQucGFyYW1zWzBdLCBlbmQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLm5ld0Jsb2NrRmlsdGVyID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2dldEJsb2NrTnVtYmVyKGZ1bmN0aW9uIChlcnIsIGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gbmV3IGJsb2NrX2ZpbHRlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBibG9ja051bWJlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIG5ld0Jsb2NrSGFuZGxlciA9IGZpbHRlci51cGRhdGUuYmluZChmaWx0ZXIpO1xuICAgICAgICAgICAgX3RoaXMuZW5naW5lLm9uKCdibG9jaycsIG5ld0Jsb2NrSGFuZGxlcik7XG4gICAgICAgICAgICB2YXIgZGVzdHJveUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5naW5lLnJlbW92ZUxpc3RlbmVyKCdibG9jaycsIG5ld0Jsb2NrSGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgX3RoaXMuZmlsdGVySW5kZXgrKztcbiAgICAgICAgICAgIF90aGlzLmZpbHRlcnNbX3RoaXMuZmlsdGVySW5kZXhdID0gZmlsdGVyO1xuICAgICAgICAgICAgX3RoaXMuZmlsdGVyRGVzdHJveUhhbmRsZXJzW190aGlzLmZpbHRlckluZGV4XSA9IGRlc3Ryb3lIYW5kbGVyO1xuICAgICAgICAgICAgdmFyIGhleEZpbHRlckluZGV4ID0gZXRoX3V0aWxfMS5pbnRUb0hleChfdGhpcy5maWx0ZXJJbmRleCk7XG4gICAgICAgICAgICBjYihudWxsLCBoZXhGaWx0ZXJJbmRleCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLm5ld0xvZ0ZpbHRlciA9IGZ1bmN0aW9uIChvcHRzLCBkb25lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBuZXcgbG9nX2ZpbHRlcl8xLmRlZmF1bHQob3B0cyk7XG4gICAgICAgIHZhciBuZXdMb2dIYW5kbGVyID0gZmlsdGVyLnVwZGF0ZS5iaW5kKGZpbHRlcik7XG4gICAgICAgIHZhciBibG9ja0hhbmRsZXIgPSBmdW5jdGlvbiAoYmxvY2ssIGNiKSB7XG4gICAgICAgICAgICBfdGhpcy5fbG9nc0ZvckJsb2NrKGJsb2NrLCBmdW5jdGlvbiAoZXJyLCBsb2dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3TG9nSGFuZGxlcihsb2dzKTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsdGVySW5kZXgrKztcbiAgICAgICAgdGhpcy5hc3luY0Jsb2NrSGFuZGxlcnNbdGhpcy5maWx0ZXJJbmRleF0gPSBibG9ja0hhbmRsZXI7XG4gICAgICAgIHRoaXMuZmlsdGVyc1t0aGlzLmZpbHRlckluZGV4XSA9IGZpbHRlcjtcbiAgICAgICAgdmFyIGhleEZpbHRlckluZGV4ID0gZXRoX3V0aWxfMS5pbnRUb0hleCh0aGlzLmZpbHRlckluZGV4KTtcbiAgICAgICAgZG9uZShudWxsLCBoZXhGaWx0ZXJJbmRleCk7XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUubmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyID0gZnVuY3Rpb24gKGRvbmUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlciA9IG5ldyBwZW5kaW5nX3R4X2ZpbHRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgdmFyIG5ld1R4SGFuZGxlciA9IGZpbHRlci51cGRhdGUuYmluZChmaWx0ZXIpO1xuICAgICAgICB2YXIgYmxvY2tIYW5kbGVyID0gZnVuY3Rpb24gKGJsb2NrLCBjYikge1xuICAgICAgICAgICAgX3RoaXMuX3R4SGFzaGVzRm9yQmxvY2soYmxvY2ssIGZ1bmN0aW9uIChlcnIsIHR4cykge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1R4SGFuZGxlcih0eHMpO1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5maWx0ZXJJbmRleCsrO1xuICAgICAgICB0aGlzLmFzeW5jUGVuZGluZ0Jsb2NrSGFuZGxlcnNbdGhpcy5maWx0ZXJJbmRleF0gPSBibG9ja0hhbmRsZXI7XG4gICAgICAgIHRoaXMuZmlsdGVyc1t0aGlzLmZpbHRlckluZGV4XSA9IGZpbHRlcjtcbiAgICAgICAgdmFyIGhleEZpbHRlckluZGV4ID0gZXRoX3V0aWxfMS5pbnRUb0hleCh0aGlzLmZpbHRlckluZGV4KTtcbiAgICAgICAgZG9uZShudWxsLCBoZXhGaWx0ZXJJbmRleCk7XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuZ2V0RmlsdGVyQ2hhbmdlcyA9IGZ1bmN0aW9uIChoZXhGaWx0ZXJJZCwgY2IpIHtcbiAgICAgICAgdmFyIGZpbHRlcklkID0gcGFyc2VJbnQoaGV4RmlsdGVySWQsIDE2KTtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZmlsdGVyc1tmaWx0ZXJJZF07XG4gICAgICAgIC8vIGlmICghZmlsdGVyKSB7IGNvbnNvbGUud2FybignRmlsdGVyU3VicHJvdmlkZXIgLSBubyBmaWx0ZXIgd2l0aCB0aGF0IGlkOicsIGhleEZpbHRlcklkKTsgfVxuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0cyA9IGZpbHRlci5nZXRDaGFuZ2VzKCk7XG4gICAgICAgIGZpbHRlci5jbGVhckNoYW5nZXMoKTtcbiAgICAgICAgY2IobnVsbCwgcmVzdWx0cyk7XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuZ2V0RmlsdGVyTG9ncyA9IGZ1bmN0aW9uIChoZXhGaWx0ZXJJZCwgY2IpIHtcbiAgICAgICAgdmFyIGZpbHRlcklkID0gcGFyc2VJbnQoaGV4RmlsdGVySWQsIDE2KTtcbiAgICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZmlsdGVyc1tmaWx0ZXJJZF07XG4gICAgICAgIC8vIGlmICghZmlsdGVyKSB7IGNvbnNvbGUud2FybignRmlsdGVyU3VicHJvdmlkZXIgLSBubyBmaWx0ZXIgd2l0aCB0aGF0IGlkOicsIGhleEZpbHRlcklkKTsgfVxuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKG51bGwsIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyLnR5cGUgPT09ICdsb2cnKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXRQYXlsb2FkKHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0TG9ncycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbUJsb2NrOiBmaWx0ZXIuZnJvbUJsb2NrLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9CbG9jazogZmlsdGVyLnRvQmxvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiBmaWx0ZXIuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljczogZmlsdGVyLnRvcGljcyxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYihudWxsLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2IobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBGaWx0ZXJTdWJwcm92aWRlci5wcm90b3R5cGUudW5pbnN0YWxsRmlsdGVyID0gZnVuY3Rpb24gKGhleEZpbHRlcklkLCBjYikge1xuICAgICAgICB2YXIgZmlsdGVySWQgPSBwYXJzZUludChoZXhGaWx0ZXJJZCwgMTYpO1xuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5maWx0ZXJzW2ZpbHRlcklkXTtcbiAgICAgICAgaWYgKCFmaWx0ZXIpIHtcbiAgICAgICAgICAgIGNiKG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbHRlcnNbZmlsdGVySWRdLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB2YXIgZGVzdHJveUhhbmRsZXIgPSB0aGlzLmZpbHRlckRlc3Ryb3lIYW5kbGVyc1tmaWx0ZXJJZF07XG4gICAgICAgIGRlbGV0ZSB0aGlzLmZpbHRlcnNbZmlsdGVySWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5hc3luY0Jsb2NrSGFuZGxlcnNbZmlsdGVySWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5hc3luY1BlbmRpbmdCbG9ja0hhbmRsZXJzW2ZpbHRlcklkXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmlsdGVyRGVzdHJveUhhbmRsZXJzW2ZpbHRlcklkXTtcbiAgICAgICAgaWYgKGRlc3Ryb3lIYW5kbGVyKSB7XG4gICAgICAgICAgICBkZXN0cm95SGFuZGxlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNiKG51bGwsIHRydWUpO1xuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLmNoZWNrRm9yUGVuZGluZ0Jsb2NrcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tGb3JQZW5kaW5nQmxvY2tzQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFjdGl2ZVBlbmRpbmdUeEZpbHRlcnMgPSAhIU9iamVjdC5rZXlzKHRoaXMuYXN5bmNQZW5kaW5nQmxvY2tIYW5kbGVycykubGVuZ3RoO1xuICAgICAgICBpZiAoYWN0aXZlUGVuZGluZ1R4RmlsdGVycykge1xuICAgICAgICAgICAgdGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3NBY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0UGF5bG9hZCh7XG4gICAgICAgICAgICAgICAgaWQ6IDAsXG4gICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLFxuICAgICAgICAgICAgICAgIHBhcmFtczogWydwZW5kaW5nJywgdHJ1ZV0sXG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrRm9yUGVuZGluZ0Jsb2Nrc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMub25OZXdQZW5kaW5nQmxvY2socmVzLnJlc3VsdCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoZXJyKSB7IGNvbnNvbGUuZXJyb3IoZXJyKTsgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3NBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChfdGhpcy5jaGVja0ZvclBlbmRpbmdCbG9ja3MuYmluZChfdGhpcyksIF90aGlzLnBlbmRpbmdCbG9ja1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5vbk5ld1BlbmRpbmdCbG9jayA9IGZ1bmN0aW9uIChibG9jaywgY2IpIHtcbiAgICAgICAgLy8gdXBkYXRlIGZpbHRlcnNcbiAgICAgICAgdmFyIHVwZGF0ZXJzID0gdmFsdWVzRm9yKHRoaXMuYXN5bmNQZW5kaW5nQmxvY2tIYW5kbGVycykubWFwKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4uYmluZChudWxsLCBibG9jayk7IH0pO1xuICAgICAgICBwYXJhbGxlbF8xLmRlZmF1bHQodXBkYXRlcnMsIGNiKTtcbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gYnVmZmVyVG9OdW1iZXJIZXgodGhpcy5lbmdpbmUuY3VycmVudEJsb2NrLm51bWJlcik7XG4gICAgICAgIGNiKG51bGwsIGJsb2NrTnVtYmVyKTtcbiAgICB9O1xuICAgIEZpbHRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5fbG9nc0ZvckJsb2NrID0gZnVuY3Rpb24gKGJsb2NrLCBjYikge1xuICAgICAgICB2YXIgYmxvY2tOdW1iZXIgPSBidWZmZXJUb051bWJlckhleChibG9jay5udW1iZXIpO1xuICAgICAgICB0aGlzLmVtaXRQYXlsb2FkKHtcbiAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0TG9ncycsXG4gICAgICAgICAgICBwYXJhbXM6IFt7XG4gICAgICAgICAgICAgICAgICAgIGZyb21CbG9jazogYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHRvQmxvY2s6IGJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNiKHJlc3BvbnNlLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiKG51bGwsIHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRmlsdGVyU3VicHJvdmlkZXIucHJvdG90eXBlLl90eEhhc2hlc0ZvckJsb2NrID0gZnVuY3Rpb24gKGJsb2NrLCBjYikge1xuICAgICAgICB2YXIgdHhzID0gYmxvY2sudHJhbnNhY3Rpb25zO1xuICAgICAgICAvLyBzaG9ydCBjaXJjdWl0IGlmIGVtcHR5XG4gICAgICAgIGlmICh0eHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgW10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHR4cyBhcmUgYWxyZWFkeSBoYXNoZXNcbiAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgdHhzWzBdKSB7XG4gICAgICAgICAgICBjYihudWxsLCB0eHMpO1xuICAgICAgICAgICAgLy8gdHhzIGFyZSBvYmosIG5lZWQgdG8gbWFwIHRvIGhhc2hlc1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSB0eHMubWFwKGZ1bmN0aW9uICh0eCkgeyByZXR1cm4gdHguaGFzaDsgfSk7XG4gICAgICAgICAgICBjYihudWxsLCByZXN1bHRzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN1YnByb3ZpZGVyO1xufShzdWJwcm92aWRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEZpbHRlclN1YnByb3ZpZGVyO1xuLy8gdXRpbFxuZnVuY3Rpb24gYnVmZmVyVG9OdW1iZXJIZXgoYnVmZmVyKSB7XG4gICAgcmV0dXJuIHN0cmlwTGVhZGluZ1plcm8oYnVmZmVyLnRvU3RyaW5nKCdoZXgnKSk7XG59XG5mdW5jdGlvbiBzdHJpcExlYWRpbmdaZXJvKGhleE51bSkge1xuICAgIHZhciBzdHJpcHBlZCA9IGV0aF91dGlsXzEuc3RyaXBIZXhQcmVmaXgoaGV4TnVtKTtcbiAgICB3aGlsZSAoc3RyaXBwZWRbMF0gPT09ICcwJykge1xuICAgICAgICBzdHJpcHBlZCA9IHN0cmlwcGVkLnN1YnN0cigxKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIHN0cmlwcGVkO1xufVxuZnVuY3Rpb24gdmFsdWVzRm9yKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XTsgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGZpbHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZpbHRlclwiKSk7XG4vL1xuLy8gQmxvY2tGaWx0ZXJcbi8vXG52YXIgQmxvY2tGaWx0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrRmlsdGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJsb2NrRmlsdGVyKG9wdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdCbG9ja0ZpbHRlciAtIG5ldycpXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnYmxvY2snO1xuICAgICAgICBfdGhpcy5lbmdpbmUgPSBvcHRzLmVuZ2luZTtcbiAgICAgICAgX3RoaXMuYmxvY2tOdW1iZXIgPSBvcHRzLmJsb2NrTnVtYmVyO1xuICAgICAgICBfdGhpcy51cGRhdGVzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQmxvY2tGaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICB2YXIgYmxvY2tIYXNoID0gYnVmZmVyVG9IZXgoYmxvY2suaGFzaCk7XG4gICAgICAgIHRoaXMudXBkYXRlcy5wdXNoKGJsb2NrSGFzaCk7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGJsb2NrKTtcbiAgICB9O1xuICAgIEJsb2NrRmlsdGVyLnByb3RvdHlwZS5nZXRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQmxvY2tGaWx0ZXIgLSBnZXRDaGFuZ2VzOicsIHJlc3VsdHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVzO1xuICAgIH07XG4gICAgQmxvY2tGaWx0ZXIucHJvdG90eXBlLmNsZWFyQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0Jsb2NrRmlsdGVyIC0gY2xlYXJDaGFuZ2VzJylcbiAgICAgICAgdGhpcy51cGRhdGVzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4gQmxvY2tGaWx0ZXI7XG59KGZpbHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEJsb2NrRmlsdGVyO1xuZnVuY3Rpb24gYnVmZmVyVG9IZXgoYnVmZmVyKSB7XG4gICAgcmV0dXJuICcweCcgKyBidWZmZXIudG9TdHJpbmcoJ2hleCcpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgRmlsdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGaWx0ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsdGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBGaWx0ZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRmlsdGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmaWx0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9maWx0ZXJcIikpO1xuLy9cbi8vIExvZ0ZpbHRlclxuLy9cbnZhciBMb2dGaWx0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExvZ0ZpbHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2dGaWx0ZXIob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIG5ldycpXG4gICAgICAgIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnR5cGUgPSAnbG9nJztcbiAgICAgICAgX3RoaXMuZnJvbUJsb2NrID0gKG9wdHMuZnJvbUJsb2NrICE9PSB1bmRlZmluZWQpID8gb3B0cy5mcm9tQmxvY2sgOiAnbGF0ZXN0JztcbiAgICAgICAgX3RoaXMudG9CbG9jayA9IChvcHRzLnRvQmxvY2sgIT09IHVuZGVmaW5lZCkgPyBvcHRzLnRvQmxvY2sgOiAnbGF0ZXN0JztcbiAgICAgICAgdmFyIGV4cGVjdGVkQWRkcmVzcyA9IG9wdHMuYWRkcmVzcyAmJiAoQXJyYXkuaXNBcnJheShvcHRzLmFkZHJlc3MpID8gb3B0cy5hZGRyZXNzIDogW29wdHMuYWRkcmVzc10pO1xuICAgICAgICBfdGhpcy5hZGRyZXNzID0gZXhwZWN0ZWRBZGRyZXNzICYmIGV4cGVjdGVkQWRkcmVzcy5tYXAobm9ybWFsaXplSGV4KTtcbiAgICAgICAgX3RoaXMudG9waWNzID0gb3B0cy50b3BpY3MgfHwgW107XG4gICAgICAgIF90aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICAgICAgX3RoaXMuYWxsUmVzdWx0cyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExvZ0ZpbHRlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGxvZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gdmFsaWRhdGUgZmlsdGVyIG1hdGNoXG4gICAgICAgIHZhciB2YWxpZExvZ3MgPSBbXTtcbiAgICAgICAgbG9ncy5mb3JFYWNoKGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZGF0ZWQgPSBfdGhpcy52YWxpZGF0ZUxvZyhsb2cpO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBhZGQgdG8gcmVzdWx0c1xuICAgICAgICAgICAgdmFsaWRMb2dzLnB1c2gobG9nKTtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZXMucHVzaChsb2cpO1xuICAgICAgICAgICAgX3RoaXMuYWxsUmVzdWx0cy5wdXNoKGxvZyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWRMb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHZhbGlkTG9ncyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ0ZpbHRlci5wcm90b3R5cGUuZ2V0Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIGdldENoYW5nZXMnKVxuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVzO1xuICAgIH07XG4gICAgTG9nRmlsdGVyLnByb3RvdHlwZS5nZXRBbGxSZXN1bHRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gZ2V0QWxsUmVzdWx0cycpXG4gICAgICAgIHJldHVybiB0aGlzLmFsbFJlc3VsdHM7XG4gICAgfTtcbiAgICBMb2dGaWx0ZXIucHJvdG90eXBlLmNsZWFyQ2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIGNsZWFyQ2hhbmdlcycpXG4gICAgICAgIHRoaXMudXBkYXRlcyA9IFtdO1xuICAgIH07XG4gICAgTG9nRmlsdGVyLnByb3RvdHlwZS52YWxpZGF0ZUxvZyA9IGZ1bmN0aW9uIChsb2cpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIHZhbGlkYXRlTG9nOicsIGxvZylcbiAgICAgICAgLy8gY2hlY2sgaWYgYmxvY2sgbnVtYmVyIGluIGJvdW5kczpcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIHZhbGlkYXRlTG9nIC0gYmxvY2tOdW1iZXInLCB0aGlzLmZyb21CbG9jaywgdGhpcy50b0Jsb2NrKVxuICAgICAgICBpZiAoYmxvY2tUYWdJc051bWJlcih0aGlzLmZyb21CbG9jaykgJiYgaGV4VG9JbnQodGhpcy5mcm9tQmxvY2spID49IGhleFRvSW50KGxvZy5ibG9ja051bWJlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tUYWdJc051bWJlcih0aGlzLnRvQmxvY2spICYmIGhleFRvSW50KHRoaXMudG9CbG9jaykgPD0gaGV4VG9JbnQobG9nLmJsb2NrTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZHJlc3MgaXMgY29ycmVjdDpcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xvZ0ZpbHRlciAtIHZhbGlkYXRlTG9nIC0gYWRkcmVzcycsIHRoaXMuYWRkcmVzcylcbiAgICAgICAgaWYgKHRoaXMuYWRkcmVzcyAmJiAhKHRoaXMuYWRkcmVzcy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIGEudG9Mb3dlckNhc2UoKTsgfSkuaW5jbHVkZXMobG9nLmFkZHJlc3MudG9Mb3dlckNhc2UoKSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9waWNzIG1hdGNoOlxuICAgICAgICAvLyB0b3BpY3MgYXJlIHBvc2l0aW9uLWRlcGVuZGFudFxuICAgICAgICAvLyB0b3BpY3MgY2FuIGJlIG5lc3RlZCB0byByZXByZXNlbnQgYG9yYCBbW2EgfHwgYl0sIGNdXG4gICAgICAgIC8vIHRvcGljcyBjYW4gYmUgbnVsbCwgcmVwcmVzZW50aW5nIGEgd2lsZCBjYXJkIGZvciB0aGF0IHBvc2l0aW9uXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2dGaWx0ZXIgLSB2YWxpZGF0ZUxvZyAtIHRvcGljcycsIGxvZy50b3BpY3MpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMb2dGaWx0ZXIgLSB2YWxpZGF0ZUxvZyAtIGFnYWluc3QgdG9waWNzJywgdGhpcy50b3BpY3MpXG4gICAgICAgIHZhciB0b3BpY3NNYXRjaCA9IHRoaXMudG9waWNzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNNYXRjaGVkLCB0b3BpY1BhdHRlcm4sIGluZGV4KSB7XG4gICAgICAgICAgICAvLyBhYm9ydCBpbiBwcm9ncmVzc1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c01hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB3aWxkIGNhcmRcbiAgICAgICAgICAgIGlmICghdG9waWNQYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBwYXR0ZXJuIGlzIGxvbmdlciB0aGFuIGFjdHVhbCB0b3BpY3NcbiAgICAgICAgICAgIHZhciBsb2dUb3BpYyA9IGxvZy50b3BpY3NbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFsb2dUb3BpYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNoZWNrIGVhY2ggcG9zc2libGUgbWF0Y2hpbmcgdG9waWNcbiAgICAgICAgICAgIHZhciBzdWJ0b3BpY3NUb01hdGNoID0gQXJyYXkuaXNBcnJheSh0b3BpY1BhdHRlcm4pID8gdG9waWNQYXR0ZXJuIDogW3RvcGljUGF0dGVybl07XG4gICAgICAgICAgICB2YXIgdG9waWNEb2VzTWF0Y2ggPSBzdWJ0b3BpY3NUb01hdGNoLmZpbHRlcihmdW5jdGlvbiAoc3ViVG9waWMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nVG9waWMudG9Mb3dlckNhc2UoKSA9PT0gc3ViVG9waWMudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH0pLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICByZXR1cm4gdG9waWNEb2VzTWF0Y2g7XG4gICAgICAgIH0sIHRydWUpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTG9nRmlsdGVyIC0gdmFsaWRhdGVMb2cgLSAnKyh0b3BpY3NNYXRjaCA/ICdhcHByb3ZlZCEnIDogJ2RlbmllZCEnKSsnID09PT09PT09PT09PT09JylcbiAgICAgICAgcmV0dXJuIHRvcGljc01hdGNoO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ0ZpbHRlcjtcbn0oZmlsdGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTG9nRmlsdGVyO1xuZnVuY3Rpb24gYmxvY2tUYWdJc051bWJlcihibG9ja1RhZykge1xuICAgIHJldHVybiBibG9ja1RhZyAmJiBbJ2VhcmxpZXN0JywgJ2xhdGVzdCcsICdwZW5kaW5nJ10uaW5kZXhPZihibG9ja1RhZykgPT09IC0xO1xufVxuZnVuY3Rpb24gaGV4VG9JbnQoaGV4U3RyaW5nKSB7XG4gICAgcmV0dXJuIE51bWJlcihoZXhTdHJpbmcpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSGV4KGhleFN0cmluZykge1xuICAgIHJldHVybiBoZXhTdHJpbmcuc2xpY2UoMCwgMikgPT09ICcweCcgPyBoZXhTdHJpbmcgOiAnMHgnICsgaGV4U3RyaW5nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBmaWx0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9maWx0ZXJcIikpO1xuLy9cbi8vIFBlbmRpbmdUeEZpbHRlclxuLy9cbnZhciBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyIC0gbmV3JylcbiAgICAgICAgX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudHlwZSA9ICdwZW5kaW5nVHgnO1xuICAgICAgICBfdGhpcy51cGRhdGVzID0gW107XG4gICAgICAgIF90aGlzLmFsbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh0eHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciAtIHVwZGF0ZScpXG4gICAgICAgIHZhciB2YWxpZFR4cyA9IFtdO1xuICAgICAgICB0eHMuZm9yRWFjaChmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgIC8vIHZhbGlkYXRlIGZpbHRlciBtYXRjaFxuICAgICAgICAgICAgdmFyIHZhbGlkYXRlZCA9IF90aGlzLnZhbGlkYXRlVW5pcXVlKHR4KTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIHRvIHJlc3VsdHNcbiAgICAgICAgICAgIHZhbGlkVHhzLnB1c2godHgpO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlcy5wdXNoKHR4KTtcbiAgICAgICAgICAgIF90aGlzLmFsbFJlc3VsdHMucHVzaCh0eCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodmFsaWRUeHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgdmFsaWRUeHMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIucHJvdG90eXBlLmdldENoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgLSBnZXRDaGFuZ2VzJylcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlcztcbiAgICB9O1xuICAgIFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGUuZ2V0QWxsUmVzdWx0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlciAtIGdldEFsbFJlc3VsdHMnKVxuICAgICAgICByZXR1cm4gdGhpcy5hbGxSZXN1bHRzO1xuICAgIH07XG4gICAgUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyLnByb3RvdHlwZS5jbGVhckNoYW5nZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXIgLSBjbGVhckNoYW5nZXMnKVxuICAgICAgICB0aGlzLnVwZGF0ZXMgPSBbXTtcbiAgICB9O1xuICAgIFBlbmRpbmdUcmFuc2FjdGlvbkZpbHRlci5wcm90b3R5cGUudmFsaWRhdGVVbmlxdWUgPSBmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUmVzdWx0cy5pbmRleE9mKHR4KSA9PT0gLTE7XG4gICAgfTtcbiAgICByZXR1cm4gUGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyO1xufShmaWx0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHN1YnByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL3N1YnByb3ZpZGVyXCIpKTtcbnZhciBGaXh0dXJlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpeHR1cmVQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaXh0dXJlUHJvdmlkZXIoc3RhdGljUmVzcG9uc2VzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXRpY1Jlc3BvbnNlcyA9IHN0YXRpY1Jlc3BvbnNlcyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaXh0dXJlUHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIHZhciBzdGF0aWNSZXNwb25zZSA9IHRoaXMuc3RhdGljUmVzcG9uc2VzW3BheWxvYWQubWV0aG9kXTtcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25cbiAgICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBzdGF0aWNSZXNwb25zZSkge1xuICAgICAgICAgICAgc3RhdGljUmVzcG9uc2UocGF5bG9hZCwgbmV4dCwgZW5kKTtcbiAgICAgICAgICAgIC8vIHN0YXRpYyByZXNwb25zZSAtIG51bGwgaXMgdmFsaWQgcmVzcG9uc2VcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0aWNSZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gcmVzdWx0IGFzeW5jaHJvbm91c2x5XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuZChudWxsLCBzdGF0aWNSZXNwb25zZSk7IH0pO1xuICAgICAgICAgICAgLy8gbm8gcHJlcGFyZWQgcmVzcG9uc2UgLSBza2lwXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBGaXh0dXJlUHJvdmlkZXI7XG59KHN1YnByb3ZpZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gRml4dHVyZVByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuICogQ2FsY3VsYXRlIGdhc1ByaWNlIGJhc2VkIG9uIGxhc3QgYmxvY2tzLlxuICogQGF1dGhvciBnaXRodWIuY29tL2F4aWNcbiAqXG4gKiBGSVhNRTogc3VwcG9ydCBtaW5pbXVtIHN1Z2dlc3RlZCBnYXMgYW5kIHBlcmhhcHMgb3RoZXIgb3B0aW9ucyBmcm9tIGdldGg6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vYmxvYi9tYXN0ZXIvZXRoL2dhc3ByaWNlLmdvXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vd2lraS9HYXMtUHJpY2UtT3JhY2xlXG4gKi9cbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIG1hcF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJhc3luYy9tYXBcIikpO1xudmFyIGdhc19wcmljZV9lcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9ycy9nYXMtcHJpY2UtZXJyb3JcIik7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc3VicHJvdmlkZXJcIikpO1xudmFyIEdhc3ByaWNlUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEdhc3ByaWNlUHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR2FzcHJpY2VQcm92aWRlcihvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm51bWJlck9mQmxvY2tzID0gb3B0cy5udW1iZXJPZkJsb2NrcyB8fCAxMDtcbiAgICAgICAgX3RoaXMuZGVsYXlJbkJsb2NrcyA9IG9wdHMuZGVsYXlJbkJsb2NrcyB8fCA1O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEdhc3ByaWNlUHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCAhPT0gJ2V0aF9nYXNQcmljZScpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHAgPSB7IGlkOiAwLCBqc29ucnBjOiAnMi4wJywgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJywgcGFyYW1zOiBbXSB9O1xuICAgICAgICB0aGlzLmVtaXRQYXlsb2FkKHAsIGZ1bmN0aW9uIChfLCByZXMpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FOiBjb252ZXJ0IG51bWJlciB1c2luZyBhIGJpZ251bSBsaWJyYXJ5XG4gICAgICAgICAgICB2YXIgbGFzdEJsb2NrID0gcGFyc2VJbnQocmVzLnJlc3VsdCwgMTYpIC0gX3RoaXMuZGVsYXlJbkJsb2NrcztcbiAgICAgICAgICAgIHZhciBibG9ja051bWJlcnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX3RoaXMubnVtYmVyT2ZCbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVycy5wdXNoKCcweCcgKyBsYXN0QmxvY2sudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICBsYXN0QmxvY2stLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBnZXRCbG9jayA9IGZ1bmN0aW9uIChpdGVtLCBjYikge1xuICAgICAgICAgICAgICAgIHZhciBwMiA9IHsgaWQ6IDAsIGpzb25ycGM6ICcyLjAnLCBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsIHBhcmFtczogW2l0ZW0sIHRydWVdIH07XG4gICAgICAgICAgICAgICAgX3RoaXMuZW1pdFBheWxvYWQocDIsIGZ1bmN0aW9uIChlcnIsIGJsb2NrUmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmxvY2tSZXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2IoZ2FzX3ByaWNlX2Vycm9yXzEuR2FzUHJpY2VFcnJvci5CbG9ja05vdEZvdW5kKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYihudWxsLCBibG9ja1Jlcy5yZXN1bHQudHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBjb3VsZCBiZSBtYWRlIG11Y2ggZmFzdGVyXG4gICAgICAgICAgICB2YXIgY2FsY1ByaWNlID0gZnVuY3Rpb24gKGVyciwgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gZmxhdHRlbiBhcnJheVxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuY29uY2F0KGIpOyB9LCBbXSk7XG4gICAgICAgICAgICAgICAgLy8gbGVhdmUgb25seSB0aGUgZ2FzcHJpY2VcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogY29udmVydCBudW1iZXIgdXNpbmcgYSBiaWdudW0gbGlicmFyeVxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuIHBhcnNlSW50KGEuZ2FzUHJpY2UsIDE2KTsgfSwgW10pO1xuICAgICAgICAgICAgICAgIC8vIG9yZGVyIGFzY2VuZGluZ1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgICAgICAgICAgICAgLy8gemUgbWVkaWFuXG4gICAgICAgICAgICAgICAgdmFyIGhhbGYgPSBNYXRoLmZsb29yKHRyYW5zYWN0aW9ucy5sZW5ndGggLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgbWVkaWFuO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbnMubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYW4gPSB0cmFuc2FjdGlvbnNbaGFsZl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYW4gPSBNYXRoLmZsb29yKCh0cmFuc2FjdGlvbnNbaGFsZiAtIDFdICsgdHJhbnNhY3Rpb25zW2hhbGZdKSAvIDIuMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuZChudWxsLCBtZWRpYW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG1hcF8xLmRlZmF1bHQoYmxvY2tOdW1iZXJzLCBnZXRCbG9jaywgY2FsY1ByaWNlKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gR2FzcHJpY2VQcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBHYXNwcmljZVByb3ZpZGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL2NhY2hlXCIpO1xuZXhwb3J0cy5CbG9ja0NhY2hlU3VicHJvdmlkZXIgPSBjYWNoZV8xLmRlZmF1bHQ7XG52YXIgZGVmYXVsdF9maXh0dXJlXzEgPSByZXF1aXJlKFwiLi9kZWZhdWx0LWZpeHR1cmVcIik7XG5leHBvcnRzLkRlZmF1bHRGaXh0dXJlU3VicHJvdmlkZXIgPSBkZWZhdWx0X2ZpeHR1cmVfMS5kZWZhdWx0O1xudmFyIGZldGNoXzEgPSByZXF1aXJlKFwiLi9mZXRjaFwiKTtcbmV4cG9ydHMuRmV0Y2hTdWJwcm92aWRlciA9IGZldGNoXzEuZGVmYXVsdDtcbnZhciBmaWx0ZXJzXzEgPSByZXF1aXJlKFwiLi9maWx0ZXJzXCIpO1xuZXhwb3J0cy5GaWx0ZXJTdWJwcm92aWRlciA9IGZpbHRlcnNfMS5kZWZhdWx0O1xudmFyIGZpeHR1cmVfMSA9IHJlcXVpcmUoXCIuL2ZpeHR1cmVcIik7XG5leHBvcnRzLkZpeHR1cmVTdWJwcm92aWRlciA9IGZpeHR1cmVfMS5kZWZhdWx0O1xudmFyIGdhc3ByaWNlXzEgPSByZXF1aXJlKFwiLi9nYXNwcmljZVwiKTtcbmV4cG9ydHMuR2FzUHJpY2VTdWJwcm92aWRlciA9IGdhc3ByaWNlXzEuZGVmYXVsdDtcbnZhciBpbmZsaWdodF9jYWNoZV8xID0gcmVxdWlyZShcIi4vaW5mbGlnaHQtY2FjaGVcIik7XG5leHBvcnRzLkluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlciA9IGluZmxpZ2h0X2NhY2hlXzEuZGVmYXVsdDtcbnZhciBwcm92aWRlcl8xID0gcmVxdWlyZShcIi4vcHJvdmlkZXJcIik7XG5leHBvcnRzLlByb3ZpZGVyU3VicHJvdmlkZXIgPSBwcm92aWRlcl8xLmRlZmF1bHQ7XG52YXIgc2FuaXRpemVyXzEgPSByZXF1aXJlKFwiLi9zYW5pdGl6ZXJcIik7XG5leHBvcnRzLlNhbml0aXplclN1YnByb3ZpZGVyID0gc2FuaXRpemVyXzEuZGVmYXVsdDtcbnZhciBzdWJzY3JpcHRpb25zXzEgPSByZXF1aXJlKFwiLi9zdWJzY3JpcHRpb25zXCIpO1xuZXhwb3J0cy5TdWJzY3JpcHRpb25TdWJwcm92aWRlciA9IHN1YnNjcmlwdGlvbnNfMS5kZWZhdWx0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc3VicHJvdmlkZXJcIikpO1xudmFyIHJwY19jYWNoZV91dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWwvcnBjLWNhY2hlLXV0aWxzXCIpO1xudmFyIEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5mbGlnaHRSZXF1ZXN0cyA9IHt9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNhY2hlSWQgPSBycGNfY2FjaGVfdXRpbHNfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHsgaW5jbHVkZUJsb2NrUmVmOiB0cnVlIH0pO1xuICAgICAgICAvLyBpZiBub3QgY2FjaGVhYmxlLCBza2lwXG4gICAgICAgIGlmICghY2FjaGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICAgICAgdmFyIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyA9IHRoaXMuaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgaWYgKCFhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBpbmZsaWdodCBjYWNoZSBmb3IgY2FjaGVJZFxuICAgICAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW107XG4gICAgICAgICAgICB0aGlzLmluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF0gPSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnM7XG4gICAgICAgICAgICBuZXh0KGZ1bmN0aW9uIChlcnIsIHJlc3VsdCwgY2IpIHtcbiAgICAgICAgICAgICAgICAvLyBjb21wbGV0ZSBpbmZsaWdodCBmb3IgY2FjaGVJZFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5pbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdO1xuICAgICAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGVyKSB7IHJldHVybiBoYW5kbGVyKGVyciwgY2xvbmVfMS5kZWZhdWx0KHJlc3VsdCkpOyB9KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBjbG9uZV8xLmRlZmF1bHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoaXQgaW5mbGlnaHQgY2FjaGUgZm9yIGNhY2hlSWRcbiAgICAgICAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lclxuICAgICAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLnB1c2goZW5kKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBJbmZsaWdodENhY2hlU3VicHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGpzb25fcnBjX2Vycm9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tcnBjLWVycm9yXCIpKTtcbnZhciBzdWJwcm92aWRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9zdWJwcm92aWRlclwiKSk7XG4vLyB3cmFwcyBhIHByb3ZpZGVyIGluIGEgc3VicHJvdmlkZXIgaW50ZXJmYWNlXG52YXIgUHJvdmlkZXJTdWJwcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJvdmlkZXJTdWJwcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcm92aWRlclN1YnByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUHJvdmlkZXJTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uIChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzcG9uc2UuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKG5ldyBqc29uX3JwY19lcnJvcl8xLmRlZmF1bHQuSW50ZXJuYWxFcnJvcihyZXNwb25zZS5lcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kKG51bGwsIHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFByb3ZpZGVyU3VicHJvdmlkZXI7XG59KHN1YnByb3ZpZGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJvdmlkZXJTdWJwcm92aWRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc3VicHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi4vc3VicHJvdmlkZXJcIikpO1xudmFyIGV0aF91dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ldGgtdXRpbFwiKTtcbnZhciBTYW5pdGl6ZXJTdWJwcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2FuaXRpemVyU3VicHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2FuaXRpemVyU3VicHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2FuaXRpemVyU3VicHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIHZhciB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHR4UGFyYW1zID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh0eFBhcmFtcykpIHtcbiAgICAgICAgICAgIHZhciBzYW5pdGl6ZWQgPSBjbG9uZVR4UGFyYW1zKHR4UGFyYW1zKTtcbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdID0gc2FuaXRpemVkO1xuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICB9O1xuICAgIHJldHVybiBTYW5pdGl6ZXJTdWJwcm92aWRlcjtcbn0oc3VicHJvdmlkZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTYW5pdGl6ZXJTdWJwcm92aWRlcjtcbi8vIHdlIHVzZSB0aGlzIHRvIGNsZWFuIGFueSBjdXN0b20gcGFyYW1zIGZyb20gdGhlIHR4UGFyYW1zXG52YXIgcGVybWl0dGVkID0gW1xuICAgICdmcm9tJyxcbiAgICAndG8nLFxuICAgICd2YWx1ZScsXG4gICAgJ2RhdGEnLFxuICAgICdnYXMnLFxuICAgICdnYXNQcmljZScsXG4gICAgJ25vbmNlJyxcbiAgICAnZnJvbUJsb2NrJyxcbiAgICAndG9CbG9jaycsXG4gICAgJ2FkZHJlc3MnLFxuICAgICd0b3BpY3MnLFxuXTtcbmZ1bmN0aW9uIGNsb25lVHhQYXJhbXModHhQYXJhbXMpIHtcbiAgICB2YXIgc2FuaXRpemVkID0gcGVybWl0dGVkLnJlZHVjZShmdW5jdGlvbiAoY29weSwgcCkge1xuICAgICAgICBpZiAocCBpbiB0eFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHhQYXJhbXNbcF0pKSB7XG4gICAgICAgICAgICAgICAgY29weVtwXSA9IHR4UGFyYW1zW3BdLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2FuaXRpemUoaXRlbSk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVtwXSA9IHNhbml0aXplKHR4UGFyYW1zW3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9LCB7fSk7XG4gICAgcmV0dXJuIHNhbml0aXplZDtcbn1cbmZ1bmN0aW9uIHNhbml0aXplKHZhbHVlKSB7XG4gICAgc3dpdGNoICh2YWx1ZSkge1xuICAgICAgICBjYXNlICdsYXRlc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBjYXNlICdwZW5kaW5nJzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY2FzZSAnZWFybGllc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXRoX3V0aWxfMS5hZGRIZXhQcmVmaXgodmFsdWUudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdWJzY3JpcHRpb25fZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvc3Vic2NyaXB0aW9uLWVycm9yXCIpO1xudmFyIGV0aF91dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ldGgtdXRpbFwiKTtcbnZhciBycGNfaGV4X2VuY29kaW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9ycGMtaGV4LWVuY29kaW5nXCIpO1xudmFyIGZpbHRlcnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9maWx0ZXJzXCIpKTtcbnZhciBTdWJzY3JpcHRpb25TdWJwcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3Vic2NyaXB0aW9uU3VicHJvdmlkZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uU3VicHJvdmlkZXIob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3Vic2NyaXB0aW9uU3VicHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbiAocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgJ2V0aF9zdWJzY3JpYmUnOlxuICAgICAgICAgICAgICAgIHRoaXMuZXRoX3N1YnNjcmliZShwYXlsb2FkLCBlbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZXRoX3Vuc3Vic2NyaWJlJzpcbiAgICAgICAgICAgICAgICB0aGlzLmV0aF91bnN1YnNjcmliZShwYXlsb2FkLCBlbmQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QuY2FsbCh0aGlzLCBwYXlsb2FkLCBuZXh0LCBlbmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25TdWJwcm92aWRlci5wcm90b3R5cGUuZXRoX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChwYXlsb2FkLCBjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc3Vic2NyaXB0aW9uVHlwZSA9IHBheWxvYWQucGFyYW1zWzBdO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCBoZXhJZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQoaGV4SWQsIDE2KTtcbiAgICAgICAgICAgIF90aGlzLnN1YnNjcmlwdGlvbnNbaWRdID0gc3Vic2NyaXB0aW9uVHlwZTtcbiAgICAgICAgICAgIF90aGlzLmZpbHRlcnNbaWRdLm9uKCdkYXRhJywgZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maWx0ZXJzW2lkXS5jbGVhckNoYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IFtyZXN1bHRzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7IHJldHVybiBfdGhpcy5fbm90aWZpY2F0aW9uSGFuZGxlcihoZXhJZCwgc3Vic2NyaXB0aW9uVHlwZSwgcik7IH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uVHlwZSA9PT0gJ25ld1BlbmRpbmdUcmFuc2FjdGlvbnMnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2tGb3JQZW5kaW5nQmxvY2tzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYihudWxsLCBoZXhJZCk7XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoc3Vic2NyaXB0aW9uVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbG9ncyc6XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBwYXlsb2FkLnBhcmFtc1sxXTtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0xvZ0ZpbHRlcihvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdQZW5kaW5nVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdIZWFkcyc6XG4gICAgICAgICAgICAgICAgdGhpcy5uZXdCbG9ja0ZpbHRlcihjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzeW5jaW5nJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2Ioc3Vic2NyaXB0aW9uX2Vycm9yXzEuU3Vic2NyaXB0aW9uRXJyb3IuVW5zdXBwb3J0ZWRUeXBlKHN1YnNjcmlwdGlvblR5cGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyLnByb3RvdHlwZS5ldGhfdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAocGF5bG9hZCwgY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGhleElkID0gcGF5bG9hZC5wYXJhbXNbMF07XG4gICAgICAgIHZhciBpZCA9IHBhcnNlSW50KGhleElkLCAxNik7XG4gICAgICAgIGlmICghdGhpcy5zdWJzY3JpcHRpb25zW2lkXSkge1xuICAgICAgICAgICAgY2Ioc3Vic2NyaXB0aW9uX2Vycm9yXzEuU3Vic2NyaXB0aW9uRXJyb3IuTm90Rm91bmQoaGV4SWQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5pbnN0YWxsRmlsdGVyKGhleElkLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuc3Vic2NyaXB0aW9uc1tpZF07XG4gICAgICAgICAgICAgICAgY2IoZXJyLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyLnByb3RvdHlwZS5fbm90aWZpY2F0aW9uSGFuZGxlciA9IGZ1bmN0aW9uIChoZXhJZCwgc3Vic2NyaXB0aW9uVHlwZSwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb25UeXBlID09PSAnbmV3SGVhZHMnKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLl9ub3RpZmljYXRpb25SZXN1bHRGcm9tQmxvY2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpdCBzZWVtcyB0aGF0IHdlYjMgZG9lc24ndCBleHBlY3QgdGhlcmUgdG8gYmUgYSBzZXBhcmF0ZSBlcnJvciBldmVudFxuICAgICAgICAvLyBzbyB3ZSBtdXN0IGVtaXQgbnVsbCBhbG9uZyB3aXRoIHRoZSByZXN1bHQgb2JqZWN0XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG51bGwsIHtcbiAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3N1YnNjcmlwdGlvbicsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb246IGhleElkLFxuICAgICAgICAgICAgICAgIHJlc3VsdDogcmVzdWx0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25TdWJwcm92aWRlci5wcm90b3R5cGUuX25vdGlmaWNhdGlvblJlc3VsdEZyb21CbG9jayA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzaDogZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5oYXNoKSxcbiAgICAgICAgICAgIHBhcmVudEhhc2g6IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2sucGFyZW50SGFzaCksXG4gICAgICAgICAgICBzaGEzVW5jbGVzOiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLnNoYTNVbmNsZXMpLFxuICAgICAgICAgICAgbWluZXI6IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2subWluZXIpLFxuICAgICAgICAgICAgc3RhdGVSb290OiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLnN0YXRlUm9vdCksXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnNSb290OiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLnRyYW5zYWN0aW9uc1Jvb3QpLFxuICAgICAgICAgICAgcmVjZWlwdHNSb290OiBldGhfdXRpbF8xLmJ1ZmZlclRvSGV4KGJsb2NrLnJlY2VpcHRzUm9vdCksXG4gICAgICAgICAgICBsb2dzQmxvb206IGV0aF91dGlsXzEuYnVmZmVyVG9IZXgoYmxvY2subG9nc0Jsb29tKSxcbiAgICAgICAgICAgIGRpZmZpY3VsdHk6IHJwY19oZXhfZW5jb2RpbmdfMS5idWZmZXJUb1F1YW50aXR5SGV4KGJsb2NrLmRpZmZpY3VsdHkpLFxuICAgICAgICAgICAgbnVtYmVyOiBycGNfaGV4X2VuY29kaW5nXzEuYnVmZmVyVG9RdWFudGl0eUhleChibG9jay5udW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IHJwY19oZXhfZW5jb2RpbmdfMS5idWZmZXJUb1F1YW50aXR5SGV4KGJsb2NrLmdhc0xpbWl0KSxcbiAgICAgICAgICAgIGdhc1VzZWQ6IHJwY19oZXhfZW5jb2RpbmdfMS5idWZmZXJUb1F1YW50aXR5SGV4KGJsb2NrLmdhc1VzZWQpLFxuICAgICAgICAgICAgbm9uY2U6IGJsb2NrLm5vbmNlID8gZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5ub25jZSkgOiBudWxsLFxuICAgICAgICAgICAgbWl4SGFzaDogZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5taXhIYXNoKSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcnBjX2hleF9lbmNvZGluZ18xLmJ1ZmZlclRvUXVhbnRpdHlIZXgoYmxvY2sudGltZXN0YW1wKSxcbiAgICAgICAgICAgIGV4dHJhRGF0YTogZXRoX3V0aWxfMS5idWZmZXJUb0hleChibG9jay5leHRyYURhdGEpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyO1xufShmaWx0ZXJzXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3Vic2NyaXB0aW9uU3VicHJvdmlkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGFzc2VydChjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJztcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV0aF9ibG9ja190cmFja2VyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1ibG9jay10cmFja2VyXCIpKTtcbnZhciBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG52YXIgYmxvY2tfdHJhY2tlcl9lcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9ycy9ibG9jay10cmFja2VyLWVycm9yXCIpO1xudmFyIGNyZWF0ZV9wYXlsb2FkXzEgPSByZXF1aXJlKFwiLi9jcmVhdGUtcGF5bG9hZFwiKTtcbnZhciBldGhfdXRpbF8xID0gcmVxdWlyZShcIi4vZXRoLXV0aWxcIik7XG4vLyBDbGFzcyByZXNwb25zaWJsZSBmb3IgdHJhY2tpbmcgbmV3IGJsb2NrcyBhcyB0aGV5IGFyZSBtaW5lZCxcbi8vIGxvYWRpbmcgdGhlbSwgcGFyc2luZyB0aGVtLCBhbmQgYWxlcnRpbmcgc3Vic2NyaWJlcnMgdmlhIGV2ZW50cy5cbnZhciBCbG9ja1RyYWNrZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJsb2NrVHJhY2tlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBCbG9ja1RyYWNrZXIob3B0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICAvLyBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJldHJ5aW5nXG4gICAgICAgIF90aGlzLmJsb2NrVGltZW91dCA9IDMwMDtcbiAgICAgICAgLy8gTWF4aW11bSBhdHRlbXB0cyB0byBsb2FkIGEgYmxvY2tcbiAgICAgICAgX3RoaXMubWF4QmxvY2tSZXRyaWVzID0gMztcbiAgICAgICAgX3RoaXMucHJvdmlkZXIgPSBvcHRzLnByb3ZpZGVyO1xuICAgICAgICBfdGhpcy5fYmxvY2tUcmFja2VyID0gb3B0cy5ibG9ja1RyYWNrZXIgfHwgbmV3IGV0aF9ibG9ja190cmFja2VyXzEuZGVmYXVsdChfX2Fzc2lnbih7fSwgb3B0cywgeyBzZXRTa2lwQ2FjaGVGbGFnOiB0cnVlIH0pKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICB9O1xuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95U3Vic2NyaXB0aW9ucygpO1xuICAgIH07XG4gICAgQmxvY2tUcmFja2VyLnByb3RvdHlwZS5mZXRjaExhdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrVHJhY2tlci5jaGVja0ZvckxhdGVzdEJsb2NrKCkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBfdGhpcy5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLmNyZWF0ZVN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG9uIG5ldyBibG9jaywgcmVxdWVzdCBibG9jayBib2R5IGFuZCBlbWl0IGFzIGV2ZW50c1xuICAgICAgICB0aGlzLl9ibG9ja1RyYWNrZXIub24oJ2xhdGVzdCcsIHRoaXMub25MYXRlc3QuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vIGZvcndhcmQgb3RoZXIgZXZlbnRzXG4gICAgICAgIHRoaXMuX2Jsb2NrVHJhY2tlci5vbignc3luYycsIHRoaXMuZW1pdC5iaW5kKHRoaXMsICdzeW5jJykpO1xuICAgICAgICB0aGlzLl9ibG9ja1RyYWNrZXIub24oJ2Vycm9yJywgdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Vycm9yJykpO1xuICAgIH07XG4gICAgQmxvY2tUcmFja2VyLnByb3RvdHlwZS5kZXN0cm95U3Vic2NyaXB0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gc3RvcCBibG9jayBwb2xsaW5nIGJ5IHJlbW92aW5nIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9ibG9ja1RyYWNrZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLm9uTGF0ZXN0ID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgIHRoaXMubG9hZEJsb2NrKGJsb2NrTnVtYmVyKTtcbiAgICB9O1xuICAgIC8vIFRyaWVzIHRvIGdldCB0aGUgYmxvY2sgcGF5bG9hZCByZWN1cnNpdmVseVxuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUubG9hZEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyLCBjYWxsQ291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGNhbGxDb3VudCA9PT0gdm9pZCAwKSB7IGNhbGxDb3VudCA9IDA7IH1cbiAgICAgICAgdGhpcy5fZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlcikudGhlbihmdW5jdGlvbiAoYmxvY2tSZXNwb25zZSkge1xuICAgICAgICAgICAgLy8gUmVzdWx0IGNhbiBiZSBudWxsIGlmIHRoZSBibG9jayBoYXNuJ3QgZnVsbHkgcHJvcGFnYXRlZCB0byB0aGUgbm9kZXNcbiAgICAgICAgICAgIGlmIChibG9ja1Jlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZUJsb2NrKGJsb2NrUmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNhbGxDb3VudCA8IF90aGlzLm1heEJsb2NrUmV0cmllcyAmJiBibG9ja051bWJlciA9PT0gX3RoaXMuY3VycmVudEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBjYWxsIHJlY3Vyc2l2ZWx5IGlmIHRoZSBjdXJyZW50IGJsb2NrIG51bWJlciBpcyBzdGlsbCB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vIGFuZCBpZiB3ZSBhcmUgdW5kZXIgdGhlIHJldHJ5IGxpbWl0LlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sb2FkQmxvY2soYmxvY2tOdW1iZXIsIGNhbGxDb3VudCArIDEpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzLmJsb2NrVGltZW91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBibG9ja190cmFja2VyX2Vycm9yXzEuQmxvY2tUcmFja2VyRXJyb3IuQmxvY2tOb3RGb3VuZChibG9ja051bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIC8vIERvbid0IHJldHJ5IGZvciBlcnJvcnMgKHByb3ZpZGVyIHNob3VsZCBoYXZlIGFscmVhZHkgcmV0cmllZClcbiAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLl9nZXRCbG9ja0J5TnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciByZXEgPSBjcmVhdGVfcGF5bG9hZF8xLmNyZWF0ZVBheWxvYWQoeyBtZXRob2Q6ICdldGhfZ2V0QmxvY2tCeU51bWJlcicsIHBhcmFtczogW2Jsb2NrTnVtYmVyLCBmYWxzZV0sIHNraXBDYWNoZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChmdWxmaWxsLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLnByb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmdWxmaWxsKHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvLyBQYXJzZSB0aGUgYmxvY2sgaW50byBhIGJ1ZmZlciByZXByZXNlbnRhdGlvbiBhbmQgdXBkYXRlIHN1YnNjcmliZXJzLlxuICAgIEJsb2NrVHJhY2tlci5wcm90b3R5cGUudXBkYXRlQmxvY2sgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgdmFyIGJ1ZmZlckJsb2NrID0gdG9CdWZmZXJCbG9jayhibG9jayk7XG4gICAgICAgIC8vIHNldCBjdXJyZW50ICsgZW1pdCBcImJsb2NrXCIgZXZlbnRcbiAgICAgICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKGJ1ZmZlckJsb2NrKTtcbiAgICAgICAgLy8gZW1pdCBvdGhlciBldmVudHNcbiAgICAgICAgdGhpcy5lbWl0KCdyYXdCbG9jaycsIGJsb2NrKTtcbiAgICAgICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBibG9jayk7XG4gICAgfTtcbiAgICBCbG9ja1RyYWNrZXIucHJvdG90eXBlLl9zZXRDdXJyZW50QmxvY2sgPSBmdW5jdGlvbiAoYnVmZmVyQmxvY2spIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QmxvY2sgPSBidWZmZXJCbG9jaztcbiAgICAgICAgdGhpcy5lbWl0KCdibG9jaycsIGJ1ZmZlckJsb2NrKTtcbiAgICB9O1xuICAgIHJldHVybiBCbG9ja1RyYWNrZXI7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmxvY2tUcmFja2VyO1xuLy8gdXRpbFxuZnVuY3Rpb24gdG9CdWZmZXJCbG9jayhqc29uQmxvY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBudW1iZXI6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLm51bWJlciksXG4gICAgICAgIGhhc2g6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLmhhc2gpLFxuICAgICAgICBwYXJlbnRIYXNoOiBldGhfdXRpbF8xLnRvQnVmZmVyKGpzb25CbG9jay5wYXJlbnRIYXNoKSxcbiAgICAgICAgbm9uY2U6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLm5vbmNlKSxcbiAgICAgICAgbWl4SGFzaDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2subWl4SGFzaCksXG4gICAgICAgIHNoYTNVbmNsZXM6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLnNoYTNVbmNsZXMpLFxuICAgICAgICBsb2dzQmxvb206IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLmxvZ3NCbG9vbSksXG4gICAgICAgIHRyYW5zYWN0aW9uc1Jvb3Q6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLnRyYW5zYWN0aW9uc1Jvb3QpLFxuICAgICAgICBzdGF0ZVJvb3Q6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLnN0YXRlUm9vdCksXG4gICAgICAgIHJlY2VpcHRzUm9vdDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2sucmVjZWlwdHNSb290KSxcbiAgICAgICAgbWluZXI6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLm1pbmVyKSxcbiAgICAgICAgZGlmZmljdWx0eTogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suZGlmZmljdWx0eSksXG4gICAgICAgIHRvdGFsRGlmZmljdWx0eTogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2sudG90YWxEaWZmaWN1bHR5KSxcbiAgICAgICAgc2l6ZTogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suc2l6ZSksXG4gICAgICAgIGV4dHJhRGF0YTogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suZXh0cmFEYXRhKSxcbiAgICAgICAgZ2FzTGltaXQ6IGV0aF91dGlsXzEudG9CdWZmZXIoanNvbkJsb2NrLmdhc0xpbWl0KSxcbiAgICAgICAgZ2FzVXNlZDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2suZ2FzVXNlZCksXG4gICAgICAgIHRpbWVzdGFtcDogZXRoX3V0aWxfMS50b0J1ZmZlcihqc29uQmxvY2sudGltZXN0YW1wKSxcbiAgICAgICAgdHJhbnNhY3Rpb25zOiBqc29uQmxvY2sudHJhbnNhY3Rpb25zLFxuICAgIH07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4dGVuZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJ4dGVuZFwiKSk7XG52YXIgcmFuZG9tX2lkXzEgPSByZXF1aXJlKFwiLi9yYW5kb20taWRcIik7XG5mdW5jdGlvbiBjcmVhdGVQYXlsb2FkKGRhdGEpIHtcbiAgICByZXR1cm4geHRlbmRfMS5kZWZhdWx0KHtcbiAgICAgICAgLy8gZGVmYXVsdHNcbiAgICAgICAgaWQ6IHJhbmRvbV9pZF8xLmNyZWF0ZVJhbmRvbUlkKCksXG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgIH0sIGRhdGEpO1xufVxuZXhwb3J0cy5jcmVhdGVQYXlsb2FkID0gY3JlYXRlUGF5bG9hZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbnZhciBldGhqc191dGlsXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aGpzLXV0aWxcIikpO1xuLy8gTWV0aG9kcyBmcm9tIGV0aGVyZXVtanMtdXRpbFxuLyoqXG4gKiBBdHRlbXB0cyB0byB0dXJuIGEgdmFsdWUgaW50byBhIGBCdWZmZXJgLiBBcyBpbnB1dCBpdCBzdXBwb3J0c1xuICogYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB2IHRoZSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0J1ZmZlcih2KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChldGhqc191dGlsXzEuZGVmYXVsdC5pc0hleFN0cmluZyh2KSkge1xuICAgICAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbShldGhqc191dGlsXzEuZGVmYXVsdC5wYWRUb0V2ZW4oZXRoanNfdXRpbF8xLmRlZmF1bHQuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbWF4LWxpbmUtbGVuZ3RoXG4gICAgICAgICAgICAgICAgXCJDYW5ub3QgY29udmVydCBzdHJpbmcgdG8gYnVmZmVyLiB0b0J1ZmZlciBvbmx5IHN1cHBvcnRzIDB4LXByZWZpeGVkIGhleCBzdHJpbmdzIGFuZCB0aGlzIHN0cmluZyB3YXMgZ2l2ZW46IFwiICsgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB2ID0gZXRoanNfdXRpbF8xLmRlZmF1bHQuaW50VG9CdWZmZXIodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYm5fanNfMS5kZWZhdWx0LmlzQk4odikpIHtcbiAgICAgICAgICAgIHYgPSB2LnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAgICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICAgICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgdHlwZTogXCIgKyB2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbn1cbmV4cG9ydHMudG9CdWZmZXIgPSB0b0J1ZmZlcjtcbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiLlxuICovXG5mdW5jdGlvbiBhZGRIZXhQcmVmaXgoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBldGhqc191dGlsXzEuZGVmYXVsdC5pc0hleFByZWZpeGVkKHN0cikgPyBzdHIgOiAnMHgnICsgc3RyO1xufVxuZXhwb3J0cy5hZGRIZXhQcmVmaXggPSBhZGRIZXhQcmVmaXg7XG5mdW5jdGlvbiBzdHJpcEhleFByZWZpeChzdHIpIHtcbiAgICByZXR1cm4gZXRoanNfdXRpbF8xLmRlZmF1bHQuc3RyaXBIZXhQcmVmaXgoc3RyKTtcbn1cbmV4cG9ydHMuc3RyaXBIZXhQcmVmaXggPSBzdHJpcEhleFByZWZpeDtcbmZ1bmN0aW9uIGludFRvSGV4KG4pIHtcbiAgICByZXR1cm4gZXRoanNfdXRpbF8xLmRlZmF1bHQuaW50VG9IZXgobik7XG59XG5leHBvcnRzLmludFRvSGV4ID0gaW50VG9IZXg7XG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihuKSB7XG4gICAgcmV0dXJuIGV0aGpzX3V0aWxfMS5kZWZhdWx0LmludFRvQnVmZmVyKG4pO1xufVxuZXhwb3J0cy5pbnRUb0J1ZmZlciA9IGludFRvQnVmZmVyO1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIGludG8gYSBoZXggYFN0cmluZ2AuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvSGV4KGJ1Zikge1xuICAgIGJ1ZiA9IHRvQnVmZmVyKGJ1Zik7XG4gICAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufVxuZXhwb3J0cy5idWZmZXJUb0hleCA9IGJ1ZmZlclRvSGV4O1xuLyoqXG4gKiBDb252ZXJ0cyBhIGBCdWZmZXJgIHRvIGEgYE51bWJlcmAuXG4gKiBAcGFyYW0gYnVmIGBCdWZmZXJgIG9iamVjdCB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5mdW5jdGlvbiBidWZmZXJUb0ludChidWYpIHtcbiAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdCh0b0J1ZmZlcihidWYpKS50b051bWJlcigpO1xufVxuZXhwb3J0cy5idWZmZXJUb0ludCA9IGJ1ZmZlclRvSW50O1xuLyoqXG4gKiBUcmltcyBsZWFkaW5nIHplcm9zIGZyb20gYSBgQnVmZmVyYCBvciBhbiBgQXJyYXlgLlxuICogQHBhcmFtIGEgKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKiBAcmV0dXJuIChCdWZmZXJ8QXJyYXl8U3RyaW5nKVxuICovXG5mdW5jdGlvbiB1bnBhZChhKSB7XG4gICAgYSA9IGV0aGpzX3V0aWxfMS5kZWZhdWx0LnN0cmlwSGV4UHJlZml4KGEpO1xuICAgIHZhciBmaXJzdCA9IGFbMF07XG4gICAgd2hpbGUgKGEubGVuZ3RoID4gMCAmJiBmaXJzdC50b1N0cmluZygpID09PSAnMCcpIHtcbiAgICAgICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgICAgIGZpcnN0ID0gYVswXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnRzLnVucGFkID0gdW5wYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8vIGdvdHRhIGtlZXAgaXQgd2l0aGluIE1BWF9TQUZFX0lOVEVHRVJcbnZhciBleHRyYURpZ2l0cyA9IDM7XG5mdW5jdGlvbiBjcmVhdGVSYW5kb21JZCgpIHtcbiAgICAvLyAxMyB0aW1lIGRpZ2l0c1xuICAgIHZhciBkYXRlUGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICogTWF0aC5wb3coMTAsIGV4dHJhRGlnaXRzKTtcbiAgICAvLyAzIHJhbmRvbSBkaWdpdHNcbiAgICB2YXIgZXh0cmFQYXJ0ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMTAsIGV4dHJhRGlnaXRzKSk7XG4gICAgLy8gMTYgZGlnaXRzXG4gICAgcmV0dXJuIGRhdGVQYXJ0ICsgZXh0cmFQYXJ0O1xufVxuZXhwb3J0cy5jcmVhdGVSYW5kb21JZCA9IGNyZWF0ZVJhbmRvbUlkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIganNvbl9zdGFibGVfc3RyaW5naWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKSk7XG5mdW5jdGlvbiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7IG9wdHMgPSB7fTsgfVxuICAgIGlmICghY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBpbmNsdWRlQmxvY2tSZWYgPSBvcHRzLmluY2x1ZGVCbG9ja1JlZjtcbiAgICB2YXIgcGFyYW1zID0gaW5jbHVkZUJsb2NrUmVmID8gcGF5bG9hZC5wYXJhbXMgOiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZCk7XG4gICAgcmV0dXJuIHBheWxvYWQubWV0aG9kICsgJzonICsganNvbl9zdGFibGVfc3RyaW5naWZ5XzEuZGVmYXVsdChwYXJhbXMpO1xufVxuZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkID0gY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIGNhbkNhY2hlKHBheWxvYWQpIHtcbiAgICByZXR1cm4gY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKSAhPT0gJ25ldmVyJztcbn1cbmV4cG9ydHMuY2FuQ2FjaGUgPSBjYW5DYWNoZTtcbmZ1bmN0aW9uIGJsb2NrVGFnRm9yUGF5bG9hZChwYXlsb2FkKSB7XG4gICAgdmFyIGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA+PSBwYXlsb2FkLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1tpbmRleF07XG59XG5leHBvcnRzLmJsb2NrVGFnRm9yUGF5bG9hZCA9IGJsb2NrVGFnRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSB7XG4gICAgdmFyIGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA+PSBwYXlsb2FkLnBhcmFtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQucGFyYW1zO1xuICAgIH1cbiAgICAvLyBldGhfZ2V0QmxvY2tCeU51bWJlciBoYXMgdGhlIGJsb2NrIHRhZyBmaXJzdCwgdGhlbiB0aGUgb3B0aW9uYWwgaW5jbHVkZVR4PyBwYXJhbVxuICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXMuc2xpY2UoMSk7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgwLCBpbmRleCk7XG59XG5leHBvcnRzLnBhcmFtc1dpdGhvdXRCbG9ja1RhZyA9IHBhcmFtc1dpdGhvdXRCbG9ja1RhZztcbmZ1bmN0aW9uIGJsb2NrVGFnUGFyYW1JbmRleChwYXlsb2FkKSB7XG4gICAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgICAgICAvLyBibG9ja1RhZyBpcyB0aGlyZCBwYXJhbVxuICAgICAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICAvLyBibG9ja1RhZyBpcyBzZWNvbmQgcGFyYW1cbiAgICAgICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29kZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVHYXMnOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGZpcnN0IHBhcmFtXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAvLyB0aGVyZSBpcyBubyBibG9ja1RhZ1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleDtcbmZ1bmN0aW9uIGNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCkge1xuICAgIHN3aXRjaCAocGF5bG9hZC5tZXRob2QpIHtcbiAgICAgICAgLy8gY2FjaGUgcGVybWFuZW50bHlcbiAgICAgICAgY2FzZSAnbmV0X3ZlcnNpb24nOlxuICAgICAgICBjYXNlICd3ZWIzX2NsaWVudFZlcnNpb24nOlxuICAgICAgICBjYXNlICd3ZWIzX3NoYTMnOlxuICAgICAgICBjYXNlICdldGhfcHJvdG9jb2xWZXJzaW9uJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnOlxuICAgICAgICBjYXNlICdldGhfZ2V0Q29kZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb21waWxlcnMnOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZUxMTCc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU29saWRpdHknOlxuICAgICAgICBjYXNlICdldGhfY29tcGlsZVNlcnBlbnQnOlxuICAgICAgICBjYXNlICdzaGhfdmVyc2lvbic6XG4gICAgICAgICAgICByZXR1cm4gJ3Blcm1hJztcbiAgICAgICAgLy8gY2FjaGUgdW50aWwgZm9ya1xuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgICAgICAgICByZXR1cm4gJ2ZvcmsnO1xuICAgICAgICAvLyBjYWNoZSBmb3IgYmxvY2tcbiAgICAgICAgY2FzZSAnZXRoX2dhc1ByaWNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2Jsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgICAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZUdhcyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJMb2dzJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldExvZ3MnOlxuICAgICAgICBjYXNlICduZXRfcGVlckNvdW50JzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2snO1xuICAgICAgICAvLyBuZXZlciBjYWNoZVxuICAgICAgICBjYXNlICduZXRfcGVlckNvdW50JzpcbiAgICAgICAgY2FzZSAnbmV0X2xpc3RlbmluZyc6XG4gICAgICAgIGNhc2UgJ2V0aF9zeW5jaW5nJzpcbiAgICAgICAgY2FzZSAnZXRoX3NpZ24nOlxuICAgICAgICBjYXNlICdldGhfY29pbmJhc2UnOlxuICAgICAgICBjYXNlICdldGhfbWluaW5nJzpcbiAgICAgICAgY2FzZSAnZXRoX2hhc2hyYXRlJzpcbiAgICAgICAgY2FzZSAnZXRoX2FjY291bnRzJzpcbiAgICAgICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgICAgIGNhc2UgJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nOlxuICAgICAgICBjYXNlICdldGhfbmV3RmlsdGVyJzpcbiAgICAgICAgY2FzZSAnZXRoX25ld0Jsb2NrRmlsdGVyJzpcbiAgICAgICAgY2FzZSAnZXRoX25ld1BlbmRpbmdUcmFuc2FjdGlvbkZpbHRlcic6XG4gICAgICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOlxuICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRXb3JrJzpcbiAgICAgICAgY2FzZSAnZXRoX3N1Ym1pdFdvcmsnOlxuICAgICAgICBjYXNlICdldGhfc3VibWl0SGFzaHJhdGUnOlxuICAgICAgICBjYXNlICdkYl9wdXRTdHJpbmcnOlxuICAgICAgICBjYXNlICdkYl9nZXRTdHJpbmcnOlxuICAgICAgICBjYXNlICdkYl9wdXRIZXgnOlxuICAgICAgICBjYXNlICdkYl9nZXRIZXgnOlxuICAgICAgICBjYXNlICdzaGhfcG9zdCc6XG4gICAgICAgIGNhc2UgJ3NoaF9uZXdJZGVudGl0eSc6XG4gICAgICAgIGNhc2UgJ3NoaF9oYXNJZGVudGl0eSc6XG4gICAgICAgIGNhc2UgJ3NoaF9uZXdHcm91cCc6XG4gICAgICAgIGNhc2UgJ3NoaF9hZGRUb0dyb3VwJzpcbiAgICAgICAgY2FzZSAnc2hoX25ld0ZpbHRlcic6XG4gICAgICAgIGNhc2UgJ3NoaF91bmluc3RhbGxGaWx0ZXInOlxuICAgICAgICBjYXNlICdzaGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgICAgIGNhc2UgJ3NoaF9nZXRNZXNzYWdlcyc6XG4gICAgICAgICAgICByZXR1cm4gJ25ldmVyJztcbiAgICB9XG59XG5leHBvcnRzLmNhY2hlVHlwZUZvclBheWxvYWQgPSBjYWNoZVR5cGVGb3JQYXlsb2FkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYXNzZXJ0XzEgPSByZXF1aXJlKFwiLi9hc3NlcnRcIik7XG52YXIgZXRoX3V0aWxfMSA9IHJlcXVpcmUoXCIuL2V0aC11dGlsXCIpO1xuLypcbiAqIEFzIHBlciBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL0pTT04tUlBDI2hleC12YWx1ZS1lbmNvZGluZ1xuICogUXVhbnRpdGllcyBzaG91bGQgYmUgcmVwcmVzZW50ZWQgYnkgdGhlIG1vc3QgY29tcGFjdCBoZXggcmVwcmVzZW50YXRpb24gcG9zc2libGVcbiAqIFRoaXMgbWVhbnMgdGhhdCBubyBsZWFkaW5nIHplcm9lcyBhcmUgYWxsb3dlZC4gVGhlcmUgaGVscGVycyBtYWtlIGl0IGVhc3lcbiAqIHRvIGNvbnZlcnQgdG8gYW5kIGZyb20gaW50ZWdlcnMgYW5kIHRoZWlyIGNvbXBhY3QgaGV4IHJlcHJlc2VudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvUXVhbnRpdHlIZXgoYnVmZmVyKSB7XG4gICAgYnVmZmVyID0gZXRoX3V0aWxfMS50b0J1ZmZlcihidWZmZXIpO1xuICAgIHZhciBoZXggPSBidWZmZXIudG9TdHJpbmcoJ2hleCcpO1xuICAgIHZhciB0cmltbWVkID0gZXRoX3V0aWxfMS51bnBhZChoZXgpO1xuICAgIHJldHVybiBldGhfdXRpbF8xLmFkZEhleFByZWZpeCh0cmltbWVkKTtcbn1cbmV4cG9ydHMuYnVmZmVyVG9RdWFudGl0eUhleCA9IGJ1ZmZlclRvUXVhbnRpdHlIZXg7XG5mdW5jdGlvbiBpbnRUb1F1YW50aXR5SGV4KG4pIHtcbiAgICBhc3NlcnRfMS5hc3NlcnQodHlwZW9mIG4gPT09ICdudW1iZXInICYmIG4gPT09IE1hdGguZmxvb3IobiksICdpbnRUb1F1YW50aXR5SGV4IGFyZyBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICB2YXIgbkhleCA9IGV0aF91dGlsXzEudG9CdWZmZXIobikudG9TdHJpbmcoJ2hleCcpO1xuICAgIGlmIChuSGV4WzBdID09PSAnMCcpIHtcbiAgICAgICAgbkhleCA9IG5IZXguc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICByZXR1cm4gZXRoX3V0aWxfMS5hZGRIZXhQcmVmaXgobkhleCk7XG59XG5leHBvcnRzLmludFRvUXVhbnRpdHlIZXggPSBpbnRUb1F1YW50aXR5SGV4O1xuZnVuY3Rpb24gcXVhbnRpdHlIZXhUb0ludChwcmVmaXhlZFF1YW50aXR5SGV4KSB7XG4gICAgYXNzZXJ0XzEuYXNzZXJ0KHR5cGVvZiBwcmVmaXhlZFF1YW50aXR5SGV4ID09PSAnc3RyaW5nJywgJ2FyZyB0byBxdWFudGl0eUhleFRvSW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB2YXIgcXVhbnRpdHlIZXggPSBldGhfdXRpbF8xLnN0cmlwSGV4UHJlZml4KHByZWZpeGVkUXVhbnRpdHlIZXgpO1xuICAgIHZhciBpc0V2ZW4gPSBxdWFudGl0eUhleC5sZW5ndGggJSAyID09PSAwO1xuICAgIGlmICghaXNFdmVuKSB7XG4gICAgICAgIHF1YW50aXR5SGV4ID0gJzAnICsgcXVhbnRpdHlIZXg7XG4gICAgfVxuICAgIHZhciBidWYgPSBuZXcgQnVmZmVyKHF1YW50aXR5SGV4LCAnaGV4Jyk7XG4gICAgcmV0dXJuIGV0aF91dGlsXzEuYnVmZmVyVG9JbnQoYnVmKTtcbn1cbmV4cG9ydHMucXVhbnRpdHlIZXhUb0ludCA9IHF1YW50aXR5SGV4VG9JbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbnZhciBTdG9wbGlnaHQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN0b3BsaWdodCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdG9wbGlnaHQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmlzTG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdG9wbGlnaHQucHJvdG90eXBlLmdvID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzTG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgndW5sb2NrJyk7XG4gICAgfTtcbiAgICBTdG9wbGlnaHQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNMb2NrZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ2xvY2snKTtcbiAgICB9O1xuICAgIFN0b3BsaWdodC5wcm90b3R5cGUuYXdhaXQgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2NrZWQpIHtcbiAgICAgICAgICAgIHRoaXMub25jZSgndW5sb2NrJywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0VGltZW91dChmbik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTdG9wbGlnaHQ7XG59KGV2ZW50c18xLkV2ZW50RW1pdHRlcikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU3RvcGxpZ2h0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBhc3luY2lmeTtcblxudmFyIF9pbml0aWFsUGFyYW1zID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9pbml0aWFsUGFyYW1zJyk7XG5cbnZhciBfaW5pdGlhbFBhcmFtczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbml0aWFsUGFyYW1zKTtcblxudmFyIF9zZXRJbW1lZGlhdGUgPSByZXF1aXJlKCcuL2ludGVybmFsL3NldEltbWVkaWF0ZScpO1xuXG52YXIgX3NldEltbWVkaWF0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRJbW1lZGlhdGUpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvd3JhcEFzeW5jJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGFrZSBhIHN5bmMgZnVuY3Rpb24gYW5kIG1ha2UgaXQgYXN5bmMsIHBhc3NpbmcgaXRzIHJldHVybiB2YWx1ZSB0byBhXG4gKiBjYWxsYmFjay4gVGhpcyBpcyB1c2VmdWwgZm9yIHBsdWdnaW5nIHN5bmMgZnVuY3Rpb25zIGludG8gYSB3YXRlcmZhbGwsXG4gKiBzZXJpZXMsIG9yIG90aGVyIGFzeW5jIGZ1bmN0aW9ucy4gQW55IGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGdlbmVyYXRlZFxuICogZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHdyYXBwZWQgZnVuY3Rpb24gKGV4Y2VwdCBmb3IgdGhlIGZpbmFsXG4gKiBjYWxsYmFjayBhcmd1bWVudCkuIEVycm9ycyB0aHJvd24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrLlxuICpcbiAqIElmIHRoZSBmdW5jdGlvbiBwYXNzZWQgdG8gYGFzeW5jaWZ5YCByZXR1cm5zIGEgUHJvbWlzZSwgdGhhdCBwcm9taXNlcydzXG4gKiByZXNvbHZlZC9yZWplY3RlZCBzdGF0ZSB3aWxsIGJlIHVzZWQgdG8gY2FsbCB0aGUgY2FsbGJhY2ssIHJhdGhlciB0aGFuIHNpbXBseVxuICogdGhlIHN5bmNocm9ub3VzIHJldHVybiB2YWx1ZS5cbiAqXG4gKiBUaGlzIGFsc28gbWVhbnMgeW91IGNhbiBhc3luY2lmeSBFUzIwMTcgYGFzeW5jYCBmdW5jdGlvbnMuXG4gKlxuICogQG5hbWUgYXN5bmNpZnlcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6VXRpbHNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyB3cmFwU3luY1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBUaGUgc3luY2hyb25vdXMgZnVuY3Rpb24sIG9yIFByb21pc2UtcmV0dXJuaW5nXG4gKiBmdW5jdGlvbiB0byBjb252ZXJ0IHRvIGFuIHtAbGluayBBc3luY0Z1bmN0aW9ufS5cbiAqIEByZXR1cm5zIHtBc3luY0Z1bmN0aW9ufSBBbiBhc3luY2hyb25vdXMgd3JhcHBlciBvZiB0aGUgYGZ1bmNgLiBUbyBiZVxuICogaW52b2tlZCB3aXRoIGAoYXJncy4uLiwgY2FsbGJhY2spYC5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gcGFzc2luZyBhIHJlZ3VsYXIgc3luY2hyb25vdXMgZnVuY3Rpb25cbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgYXN5bmMuYXBwbHkoZnMucmVhZEZpbGUsIGZpbGVuYW1lLCBcInV0ZjhcIiksXG4gKiAgICAgYXN5bmMuYXN5bmNpZnkoSlNPTi5wYXJzZSksXG4gKiAgICAgZnVuY3Rpb24gKGRhdGEsIG5leHQpIHtcbiAqICAgICAgICAgLy8gZGF0YSBpcyB0aGUgcmVzdWx0IG9mIHBhcnNpbmcgdGhlIHRleHQuXG4gKiAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIHBhcnNpbmcgZXJyb3IsIGl0IHdvdWxkIGhhdmUgYmVlbiBjYXVnaHQuXG4gKiAgICAgfVxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIC8vIHBhc3NpbmcgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBwcm9taXNlXG4gKiBhc3luYy53YXRlcmZhbGwoW1xuICogICAgIGFzeW5jLmFwcGx5KGZzLnJlYWRGaWxlLCBmaWxlbmFtZSwgXCJ1dGY4XCIpLFxuICogICAgIGFzeW5jLmFzeW5jaWZ5KGZ1bmN0aW9uIChjb250ZW50cykge1xuICogICAgICAgICByZXR1cm4gZGIubW9kZWwuY3JlYXRlKGNvbnRlbnRzKTtcbiAqICAgICB9KSxcbiAqICAgICBmdW5jdGlvbiAobW9kZWwsIG5leHQpIHtcbiAqICAgICAgICAgLy8gYG1vZGVsYCBpcyB0aGUgaW5zdGFudGlhdGVkIG1vZGVsIG9iamVjdC5cbiAqICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGVycm9yLCB0aGlzIGZ1bmN0aW9uIHdvdWxkIGJlIHNraXBwZWQuXG4gKiAgICAgfVxuICogXSwgY2FsbGJhY2spO1xuICpcbiAqIC8vIGVzMjAxNyBleGFtcGxlLCB0aG91Z2ggYGFzeW5jaWZ5YCBpcyBub3QgbmVlZGVkIGlmIHlvdXIgSlMgZW52aXJvbm1lbnRcbiAqIC8vIHN1cHBvcnRzIGFzeW5jIGZ1bmN0aW9ucyBvdXQgb2YgdGhlIGJveFxuICogdmFyIHEgPSBhc3luYy5xdWV1ZShhc3luYy5hc3luY2lmeShhc3luYyBmdW5jdGlvbihmaWxlKSB7XG4gKiAgICAgdmFyIGludGVybWVkaWF0ZVN0ZXAgPSBhd2FpdCBwcm9jZXNzRmlsZShmaWxlKTtcbiAqICAgICByZXR1cm4gYXdhaXQgc29tZVByb21pc2UoaW50ZXJtZWRpYXRlU3RlcClcbiAqIH0pKTtcbiAqXG4gKiBxLnB1c2goZmlsZXMpO1xuICovXG5mdW5jdGlvbiBhc3luY2lmeShmdW5jKSB7XG4gICAgaWYgKCgwLCBfd3JhcEFzeW5jLmlzQXN5bmMpKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncyAvKiwgY2FsbGJhY2sqLykge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUHJvbWlzZShwcm9taXNlLCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfaW5pdGlhbFBhcmFtczIuZGVmYXVsdCkoZnVuY3Rpb24gKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgcmVzdWx0IGlzIFByb21pc2Ugb2JqZWN0XG4gICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUHJvbWlzZShyZXN1bHQsIGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUHJvbWlzZShwcm9taXNlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICBpbnZva2VDYWxsYmFjayhjYWxsYmFjaywgbnVsbCwgdmFsdWUpO1xuICAgIH0sIGVyciA9PiB7XG4gICAgICAgIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnIgJiYgZXJyLm1lc3NhZ2UgPyBlcnIgOiBuZXcgRXJyb3IoZXJyKSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGludm9rZUNhbGxiYWNrKGNhbGxiYWNrLCBlcnJvciwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgICBjYWxsYmFjayhlcnJvciwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAoMCwgX3NldEltbWVkaWF0ZTIuZGVmYXVsdCkoZSA9PiB7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9LCBlcnIpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvZWFjaE9mTGltaXQnKTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2ZMaW1pdCk7XG5cbnZhciBfd2l0aG91dEluZGV4ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93aXRob3V0SW5kZXgnKTtcblxudmFyIF93aXRob3V0SW5kZXgyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2l0aG91dEluZGV4KTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeScpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgYSBtYXhpbXVtIG9mIGBsaW1pdGAgYXN5bmMgb3BlcmF0aW9ucyBhdCBhIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaExpbWl0XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBhbGlhcyBmb3JFYWNoTGltaXRcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fEl0ZXJhYmxlfEFzeW5jSXRlcmFibGV8T2JqZWN0fSBjb2xsIC0gQSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBsaW1pdCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBhc3luYyBvcGVyYXRpb25zIGF0IGEgdGltZS5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gaXRlcmF0ZWUgLSBBbiBhc3luYyBmdW5jdGlvbiB0byBhcHBseSB0byBlYWNoIGl0ZW0gaW5cbiAqIGBjb2xsYC5cbiAqIFRoZSBhcnJheSBpbmRleCBpcyBub3QgcGFzc2VkIHRvIHRoZSBpdGVyYXRlZS5cbiAqIElmIHlvdSBuZWVkIHRoZSBpbmRleCwgdXNlIGBlYWNoT2ZMaW1pdGAuXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqL1xuZnVuY3Rpb24gZWFjaExpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuICgwLCBfZWFjaE9mTGltaXQyLmRlZmF1bHQpKGxpbWl0KShjb2xsLCAoMCwgX3dpdGhvdXRJbmRleDIuZGVmYXVsdCkoKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKGl0ZXJhdGVlKSksIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKGVhY2hMaW1pdCwgNCk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvaXNBcnJheUxpa2UnKTtcblxudmFyIF9pc0FycmF5TGlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5TGlrZSk7XG5cbnZhciBfYnJlYWtMb29wID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9icmVha0xvb3AnKTtcblxudmFyIF9icmVha0xvb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWtMb29wKTtcblxudmFyIF9lYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vZWFjaE9mTGltaXQnKTtcblxudmFyIF9lYWNoT2ZMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2ZMaW1pdCk7XG5cbnZhciBfb25jZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvb25jZScpO1xuXG52YXIgX29uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25jZSk7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL2ludGVybmFsL29ubHlPbmNlJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvd3JhcEFzeW5jJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbnZhciBfYXdhaXRpZnkgPSByZXF1aXJlKCcuL2ludGVybmFsL2F3YWl0aWZ5Jyk7XG5cbnZhciBfYXdhaXRpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXdhaXRpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBlYWNoT2YgaW1wbGVtZW50YXRpb24gb3B0aW1pemVkIGZvciBhcnJheS1saWtlc1xuZnVuY3Rpb24gZWFjaE9mQXJyYXlMaWtlKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gKDAsIF9vbmNlMi5kZWZhdWx0KShjYWxsYmFjayk7XG4gICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgY29tcGxldGVkID0gMCxcbiAgICAgICAgeyBsZW5ndGggfSA9IGNvbGwsXG4gICAgICAgIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpdGVyYXRvckNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNhbmNlbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsZWQgPT09IHRydWUpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSBlbHNlIGlmICgrK2NvbXBsZXRlZCA9PT0gbGVuZ3RoIHx8IHZhbHVlID09PSBfYnJlYWtMb29wMi5kZWZhdWx0KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpdGVyYXRlZShjb2xsW2luZGV4XSwgaW5kZXgsICgwLCBfb25seU9uY2UyLmRlZmF1bHQpKGl0ZXJhdG9yQ2FsbGJhY2spKTtcbiAgICB9XG59XG5cbi8vIGEgZ2VuZXJpYyB2ZXJzaW9uIG9mIGVhY2hPZiB3aGljaCBjYW4gaGFuZGxlIGFycmF5LCBvYmplY3QsIGFuZCBpdGVyYXRvciBjYXNlcy5cbmZ1bmN0aW9uIGVhY2hPZkdlbmVyaWMoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuICgwLCBfZWFjaE9mTGltaXQyLmRlZmF1bHQpKGNvbGwsIEluZmluaXR5LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIExpa2UgW2BlYWNoYF17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2h9LCBleGNlcHQgdGhhdCBpdCBwYXNzZXMgdGhlIGtleSAob3IgaW5kZXgpIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIHRvIHRoZSBpdGVyYXRlZS5cbiAqXG4gKiBAbmFtZSBlYWNoT2ZcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBhbGlhcyBmb3JFYWNoT2ZcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEEgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuIGFycmF5LlxuICogSW52b2tlZCB3aXRoIChpdGVtLCBrZXksIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbFxuICogYGl0ZXJhdGVlYCBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBJbnZva2VkIHdpdGggKGVycikuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBhIGNhbGxiYWNrIGlzIG9taXR0ZWRcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iaiA9IHtkZXY6IFwiL2Rldi5qc29uXCIsIHRlc3Q6IFwiL3Rlc3QuanNvblwiLCBwcm9kOiBcIi9wcm9kLmpzb25cIn07XG4gKiB2YXIgY29uZmlncyA9IHt9O1xuICpcbiAqIGFzeW5jLmZvckVhY2hPZihvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5LCBjYWxsYmFjaykge1xuICogICAgIGZzLnJlYWRGaWxlKF9fZGlybmFtZSArIHZhbHVlLCBcInV0ZjhcIiwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICogICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAqICAgICAgICAgdHJ5IHtcbiAqICAgICAgICAgICAgIGNvbmZpZ3Nba2V5XSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gKiAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAqICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlKTtcbiAqICAgICAgICAgfVxuICogICAgICAgICBjYWxsYmFjaygpO1xuICogICAgIH0pO1xuICogfSwgZnVuY3Rpb24gKGVycikge1xuICogICAgIGlmIChlcnIpIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpO1xuICogICAgIC8vIGNvbmZpZ3MgaXMgbm93IGEgbWFwIG9mIEpTT04gZGF0YVxuICogICAgIGRvU29tZXRoaW5nV2l0aChjb25maWdzKTtcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBlYWNoT2YoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVhY2hPZkltcGxlbWVudGF0aW9uID0gKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkoY29sbCkgPyBlYWNoT2ZBcnJheUxpa2UgOiBlYWNoT2ZHZW5lcmljO1xuICAgIHJldHVybiBlYWNoT2ZJbXBsZW1lbnRhdGlvbihjb2xsLCAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKGVhY2hPZiwgMyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfZWFjaE9mTGltaXQyID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9lYWNoT2ZMaW1pdCcpO1xuXG52YXIgX2VhY2hPZkxpbWl0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2VhY2hPZkxpbWl0Mik7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxudmFyIF9hd2FpdGlmeSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvYXdhaXRpZnknKTtcblxudmFyIF9hd2FpdGlmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hd2FpdGlmeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogVGhlIHNhbWUgYXMgW2BlYWNoT2ZgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaE9mfSBidXQgcnVucyBhIG1heGltdW0gb2YgYGxpbWl0YCBhc3luYyBvcGVyYXRpb25zIGF0IGFcbiAqIHRpbWUuXG4gKlxuICogQG5hbWUgZWFjaE9mTGltaXRcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29sbGVjdGlvbnNcbiAqIEBtZXRob2RcbiAqIEBzZWUgW2FzeW5jLmVhY2hPZl17QGxpbmsgbW9kdWxlOkNvbGxlY3Rpb25zLmVhY2hPZn1cbiAqIEBhbGlhcyBmb3JFYWNoT2ZMaW1pdFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8SXRlcmFibGV8QXN5bmNJdGVyYWJsZXxPYmplY3R9IGNvbGwgLSBBIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtudW1iZXJ9IGxpbWl0IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGFzeW5jIG9wZXJhdGlvbnMgYXQgYSB0aW1lLlxuICogQHBhcmFtIHtBc3luY0Z1bmN0aW9ufSBpdGVyYXRlZSAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIGFwcGx5IHRvIGVhY2hcbiAqIGl0ZW0gaW4gYGNvbGxgLiBUaGUgYGtleWAgaXMgdGhlIGl0ZW0ncyBrZXksIG9yIGluZGV4IGluIHRoZSBjYXNlIG9mIGFuXG4gKiBhcnJheS5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwga2V5LCBjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQSBjYWxsYmFjayB3aGljaCBpcyBjYWxsZWQgd2hlbiBhbGxcbiAqIGBpdGVyYXRlZWAgZnVuY3Rpb25zIGhhdmUgZmluaXNoZWQsIG9yIGFuIGVycm9yIG9jY3Vycy4gSW52b2tlZCB3aXRoIChlcnIpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSwgaWYgYSBjYWxsYmFjayBpcyBvbWl0dGVkXG4gKi9cbmZ1bmN0aW9uIGVhY2hPZkxpbWl0KGNvbGwsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgcmV0dXJuICgwLCBfZWFjaE9mTGltaXQzLmRlZmF1bHQpKGxpbWl0KShjb2xsLCAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkoaXRlcmF0ZWUpLCBjYWxsYmFjayk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKGVhY2hPZkxpbWl0LCA0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9lYWNoTGltaXQgPSByZXF1aXJlKCcuL2VhY2hMaW1pdCcpO1xuXG52YXIgX2VhY2hMaW1pdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoTGltaXQpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeScpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBUaGUgc2FtZSBhcyBbYGVhY2hgXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH0gYnV0IHJ1bnMgb25seSBhIHNpbmdsZSBhc3luYyBvcGVyYXRpb24gYXQgYSB0aW1lLlxuICpcbiAqIE5vdGUsIHRoYXQgdW5saWtlIFtgZWFjaGBde0BsaW5rIG1vZHVsZTpDb2xsZWN0aW9ucy5lYWNofSwgdGhpcyBmdW5jdGlvbiBhcHBsaWVzIGl0ZXJhdGVlIHRvIGVhY2ggaXRlbVxuICogaW4gc2VyaWVzIGFuZCB0aGVyZWZvcmUgdGhlIGl0ZXJhdGVlIGZ1bmN0aW9ucyB3aWxsIGNvbXBsZXRlIGluIG9yZGVyLlxuXG4gKiBAbmFtZSBlYWNoU2VyaWVzXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAc2VlIFthc3luYy5lYWNoXXtAbGluayBtb2R1bGU6Q29sbGVjdGlvbnMuZWFjaH1cbiAqIEBhbGlhcyBmb3JFYWNoU2VyaWVzXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaFxuICogaXRlbSBpbiBgY29sbGAuXG4gKiBUaGUgYXJyYXkgaW5kZXggaXMgbm90IHBhc3NlZCB0byB0aGUgaXRlcmF0ZWUuXG4gKiBJZiB5b3UgbmVlZCB0aGUgaW5kZXgsIHVzZSBgZWFjaE9mU2VyaWVzYC5cbiAqIEludm9rZWQgd2l0aCAoaXRlbSwgY2FsbGJhY2spLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSAtIEEgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gYWxsXG4gKiBgaXRlcmF0ZWVgIGZ1bmN0aW9ucyBoYXZlIGZpbmlzaGVkLCBvciBhbiBlcnJvciBvY2N1cnMuIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuICovXG5mdW5jdGlvbiBlYWNoU2VyaWVzKGNvbGwsIGl0ZXJhdGVlLCBjYWxsYmFjaykge1xuICByZXR1cm4gKDAsIF9lYWNoTGltaXQyLmRlZmF1bHQpKGNvbGwsIDEsIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSAoMCwgX2F3YWl0aWZ5Mi5kZWZhdWx0KShlYWNoU2VyaWVzLCAzKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXN5bmNFYWNoT2ZMaW1pdDtcblxudmFyIF9icmVha0xvb3AgPSByZXF1aXJlKCcuL2JyZWFrTG9vcCcpO1xuXG52YXIgX2JyZWFrTG9vcDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9icmVha0xvb3ApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vLyBmb3IgYXN5bmMgZ2VuZXJhdG9yc1xuZnVuY3Rpb24gYXN5bmNFYWNoT2ZMaW1pdChnZW5lcmF0b3IsIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spIHtcbiAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgIGxldCBjYW5jZWxlZCA9IGZhbHNlO1xuICAgIGxldCBhd2FpdGluZyA9IGZhbHNlO1xuICAgIGxldCBydW5uaW5nID0gMDtcbiAgICBsZXQgaWR4ID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlcGxlbmlzaCgpIHtcbiAgICAgICAgLy9jb25zb2xlLmxvZygncmVwbGVuaXNoJylcbiAgICAgICAgaWYgKHJ1bm5pbmcgPj0gbGltaXQgfHwgYXdhaXRpbmcgfHwgZG9uZSkgcmV0dXJuO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdyZXBsZW5pc2ggYXdhaXRpbmcnKVxuICAgICAgICBhd2FpdGluZyA9IHRydWU7XG4gICAgICAgIGdlbmVyYXRvci5uZXh0KCkudGhlbigoeyB2YWx1ZSwgZG9uZTogaXRlckRvbmUgfSkgPT4ge1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZ290IHZhbHVlJywgdmFsdWUpXG4gICAgICAgICAgICBpZiAoY2FuY2VsZWQgfHwgZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICAgYXdhaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChpdGVyRG9uZSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnZG9uZSBuZXh0Q2InKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZysrO1xuICAgICAgICAgICAgaXRlcmF0ZWUodmFsdWUsIGlkeCwgaXRlcmF0ZWVDYWxsYmFjayk7XG4gICAgICAgICAgICBpZHgrKztcbiAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICB9KS5jYXRjaChoYW5kbGVFcnJvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXRlcmF0ZWVDYWxsYmFjayhlcnIsIHJlc3VsdCkge1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdpdGVyYXRlZUNhbGxiYWNrJylcbiAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICBpZiAoY2FuY2VsZWQpIHJldHVybjtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGhhbmRsZUVycm9yKGVycik7XG5cbiAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gX2JyZWFrTG9vcDIuZGVmYXVsdCB8fCBkb25lICYmIHJ1bm5pbmcgPD0gMCkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdkb25lIGl0ZXJDYicpXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICBhd2FpdGluZyA9IGZhbHNlO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG5cbiAgICByZXBsZW5pc2goKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gYXdhaXRpZnk7XG4vLyBjb25kaXRpb25hbGx5IHByb21pc2lmeSBhIGZ1bmN0aW9uLlxuLy8gb25seSByZXR1cm4gYSBwcm9taXNlIGlmIGEgY2FsbGJhY2sgaXMgb21pdHRlZFxuZnVuY3Rpb24gYXdhaXRpZnkoYXN5bmNGbiwgYXJpdHkgPSBhc3luY0ZuLmxlbmd0aCkge1xuICAgIGlmICghYXJpdHkpIHRocm93IG5ldyBFcnJvcignYXJpdHkgaXMgdW5kZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gYXdhaXRhYmxlKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzW2FyaXR5IC0gMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3luY0ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGFyZ3NbYXJpdHkgLSAxXSA9IChlcnIsIC4uLmNiQXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNiQXJncy5sZW5ndGggPiAxID8gY2JBcmdzIDogY2JBcmdzWzBdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhc3luY0ZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXdhaXRhYmxlLCAnbmFtZScsIHtcbiAgICAgICAgdmFsdWU6IGBhd2FpdGFibGUoJHthc3luY0ZuLm5hbWV9KWBcbiAgICB9KTtcblxuICAgIHJldHVybiBhd2FpdGFibGU7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbi8vIEEgdGVtcG9yYXJ5IHZhbHVlIHVzZWQgdG8gaWRlbnRpZnkgaWYgdGhlIGxvb3Agc2hvdWxkIGJlIGJyb2tlbi5cbi8vIFNlZSAjMTA2NCwgIzEyOTNcbmNvbnN0IGJyZWFrTG9vcCA9IHt9O1xuZXhwb3J0cy5kZWZhdWx0ID0gYnJlYWtMb29wO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9vbmNlID0gcmVxdWlyZSgnLi9vbmNlJyk7XG5cbnZhciBfb25jZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vbmNlKTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoJy4vaXRlcmF0b3InKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfb25seU9uY2UgPSByZXF1aXJlKCcuL29ubHlPbmNlJyk7XG5cbnZhciBfb25seU9uY2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb25seU9uY2UpO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vd3JhcEFzeW5jJyk7XG5cbnZhciBfYXN5bmNFYWNoT2ZMaW1pdCA9IHJlcXVpcmUoJy4vYXN5bmNFYWNoT2ZMaW1pdCcpO1xuXG52YXIgX2FzeW5jRWFjaE9mTGltaXQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNFYWNoT2ZMaW1pdCk7XG5cbnZhciBfYnJlYWtMb29wID0gcmVxdWlyZSgnLi9icmVha0xvb3AnKTtcblxudmFyIF9icmVha0xvb3AyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJlYWtMb29wKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbGltaXQgPT4ge1xuICAgIHJldHVybiAob2JqLCBpdGVyYXRlZSwgY2FsbGJhY2spID0+IHtcbiAgICAgICAgY2FsbGJhY2sgPSAoMCwgX29uY2UyLmRlZmF1bHQpKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGxpbWl0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdjb25jdXJyZW5jeSBsaW1pdCBjYW5ub3QgYmUgbGVzcyB0aGFuIDEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3dyYXBBc3luYy5pc0FzeW5jR2VuZXJhdG9yKShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9hc3luY0VhY2hPZkxpbWl0Mi5kZWZhdWx0KShvYmosIGxpbWl0LCBpdGVyYXRlZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoMCwgX3dyYXBBc3luYy5pc0FzeW5jSXRlcmFibGUpKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2FzeW5jRWFjaE9mTGltaXQyLmRlZmF1bHQpKG9ialtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSwgbGltaXQsIGl0ZXJhdGVlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5leHRFbGVtID0gKDAsIF9pdGVyYXRvcjIuZGVmYXVsdCkob2JqKTtcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdmFyIGNhbmNlbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBydW5uaW5nID0gMDtcbiAgICAgICAgdmFyIGxvb3BpbmcgPSBmYWxzZTtcblxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZUNhbGxiYWNrKGVyciwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgcnVubmluZyAtPSAxO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVyciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYW5jZWxlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBfYnJlYWtMb29wMi5kZWZhdWx0IHx8IGRvbmUgJiYgcnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghbG9vcGluZykge1xuICAgICAgICAgICAgICAgIHJlcGxlbmlzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGVuaXNoKCkge1xuICAgICAgICAgICAgbG9vcGluZyA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAocnVubmluZyA8IGxpbWl0ICYmICFkb25lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW0gPSBuZXh0RWxlbSgpO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmcgKz0gMTtcbiAgICAgICAgICAgICAgICBpdGVyYXRlZShlbGVtLnZhbHVlLCBlbGVtLmtleSwgKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkoaXRlcmF0ZWVDYWxsYmFjaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9vcGluZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVwbGVuaXNoKCk7XG4gICAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChjb2xsKSB7XG4gICAgcmV0dXJuIGNvbGxbU3ltYm9sLml0ZXJhdG9yXSAmJiBjb2xsW1N5bWJvbC5pdGVyYXRvcl0oKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzIC8qLCBjYWxsYmFjayovKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGFyZ3MsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IGlzQXJyYXlMaWtlO1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiYgdmFsdWUubGVuZ3RoID49IDAgJiYgdmFsdWUubGVuZ3RoICUgMSA9PT0gMDtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlSXRlcmF0b3I7XG5cbnZhciBfaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbnZhciBfaXNBcnJheUxpa2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNBcnJheUxpa2UpO1xuXG52YXIgX2dldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvcicpO1xuXG52YXIgX2dldEl0ZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKSB7XG4gICAgdmFyIGkgPSAtMTtcbiAgICB2YXIgbGVuID0gY29sbC5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHJldHVybiArK2kgPCBsZW4gPyB7IHZhbHVlOiBjb2xsW2ldLCBrZXk6IGkgfSA6IG51bGw7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRVMyMDE1SXRlcmF0b3IoaXRlcmF0b3IpIHtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKGl0ZW0uZG9uZSkgcmV0dXJuIG51bGw7XG4gICAgICAgIGkrKztcbiAgICAgICAgcmV0dXJuIHsgdmFsdWU6IGl0ZW0udmFsdWUsIGtleTogaSB9O1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdEl0ZXJhdG9yKG9iaikge1xuICAgIHZhciBva2V5cyA9IG9iaiA/IE9iamVjdC5rZXlzKG9iaikgOiBbXTtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBsZW4gPSBva2V5cy5sZW5ndGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgIHZhciBrZXkgPSBva2V5c1srK2ldO1xuICAgICAgICByZXR1cm4gaSA8IGxlbiA/IHsgdmFsdWU6IG9ialtrZXldLCBrZXkgfSA6IG51bGw7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3IoY29sbCkge1xuICAgIGlmICgoMCwgX2lzQXJyYXlMaWtlMi5kZWZhdWx0KShjb2xsKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlJdGVyYXRvcihjb2xsKTtcbiAgICB9XG5cbiAgICB2YXIgaXRlcmF0b3IgPSAoMCwgX2dldEl0ZXJhdG9yMi5kZWZhdWx0KShjb2xsKTtcbiAgICByZXR1cm4gaXRlcmF0b3IgPyBjcmVhdGVFUzIwMTVJdGVyYXRvcihpdGVyYXRvcikgOiBjcmVhdGVPYmplY3RJdGVyYXRvcihjb2xsKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2FzeW5jTWFwO1xuXG52YXIgX3dyYXBBc3luYyA9IHJlcXVpcmUoJy4vd3JhcEFzeW5jJyk7XG5cbnZhciBfd3JhcEFzeW5jMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dyYXBBc3luYyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9hc3luY01hcChlYWNoZm4sIGFyciwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gICAgYXJyID0gYXJyIHx8IFtdO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBfaXRlcmF0ZWUgPSAoMCwgX3dyYXBBc3luYzIuZGVmYXVsdCkoaXRlcmF0ZWUpO1xuXG4gICAgcmV0dXJuIGVhY2hmbihhcnIsICh2YWx1ZSwgXywgaXRlckNiKSA9PiB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgX2l0ZXJhdGVlKHZhbHVlLCAoZXJyLCB2KSA9PiB7XG4gICAgICAgICAgICByZXN1bHRzW2luZGV4XSA9IHY7XG4gICAgICAgICAgICBpdGVyQ2IoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSwgZXJyID0+IHtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHRzKTtcbiAgICB9KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBvbmNlO1xuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGZ1bmN0aW9uIHdyYXBwZXIoLi4uYXJncykge1xuICAgICAgICBpZiAoZm4gPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgdmFyIGNhbGxGbiA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbih3cmFwcGVyLCBmbik7XG4gICAgcmV0dXJuIHdyYXBwZXI7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBvbmx5T25jZTtcbmZ1bmN0aW9uIG9ubHlPbmNlKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGlmIChmbiA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2sgd2FzIGFscmVhZHkgY2FsbGVkLlwiKTtcbiAgICAgICAgdmFyIGNhbGxGbiA9IGZuO1xuICAgICAgICBmbiA9IG51bGw7XG4gICAgICAgIGNhbGxGbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9pc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxudmFyIF9pc0FycmF5TGlrZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0FycmF5TGlrZSk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxudmFyIF9hd2FpdGlmeSA9IHJlcXVpcmUoJy4vYXdhaXRpZnknKTtcblxudmFyIF9hd2FpdGlmeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hd2FpdGlmeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKChlYWNoZm4sIHRhc2tzLCBjYWxsYmFjaykgPT4ge1xuICAgIHZhciByZXN1bHRzID0gKDAsIF9pc0FycmF5TGlrZTIuZGVmYXVsdCkodGFza3MpID8gW10gOiB7fTtcblxuICAgIGVhY2hmbih0YXNrcywgKHRhc2ssIGtleSwgdGFza0NiKSA9PiB7XG4gICAgICAgICgwLCBfd3JhcEFzeW5jMi5kZWZhdWx0KSh0YXNrKSgoZXJyLCAuLi5yZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgICAgIFtyZXN1bHRdID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0c1trZXldID0gcmVzdWx0O1xuICAgICAgICAgICAgdGFza0NiKGVycik7XG4gICAgICAgIH0pO1xuICAgIH0sIGVyciA9PiBjYWxsYmFjayhlcnIsIHJlc3VsdHMpKTtcbn0sIDMpO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5jb25zdCBQUk9NSVNFX1NZTUJPTCA9IFN5bWJvbCgncHJvbWlzZUNhbGxiYWNrJyk7XG5cbmZ1bmN0aW9uIHByb21pc2VDYWxsYmFjaygpIHtcbiAgICBsZXQgcmVzb2x2ZSwgcmVqZWN0O1xuICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVyciwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgIHJlc29sdmUoYXJncy5sZW5ndGggPiAxID8gYXJncyA6IGFyZ3NbMF0pO1xuICAgIH1cblxuICAgIGNhbGxiYWNrW1BST01JU0VfU1lNQk9MXSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICByZXNvbHZlID0gcmVzLCByZWplY3QgPSByZWo7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmV4cG9ydHMucHJvbWlzZUNhbGxiYWNrID0gcHJvbWlzZUNhbGxiYWNrO1xuZXhwb3J0cy5QUk9NSVNFX1NZTUJPTCA9IFBST01JU0VfU1lNQk9MOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5mYWxsYmFjayA9IGZhbGxiYWNrO1xuZXhwb3J0cy53cmFwID0gd3JhcDtcbnZhciBoYXNTZXRJbW1lZGlhdGUgPSBleHBvcnRzLmhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgJiYgc2V0SW1tZWRpYXRlO1xudmFyIGhhc05leHRUaWNrID0gZXhwb3J0cy5oYXNOZXh0VGljayA9IHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy5uZXh0VGljayA9PT0gJ2Z1bmN0aW9uJztcblxuZnVuY3Rpb24gZmFsbGJhY2soZm4pIHtcbiAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxuZnVuY3Rpb24gd3JhcChkZWZlcikge1xuICAgIHJldHVybiAoZm4sIC4uLmFyZ3MpID0+IGRlZmVyKCgpID0+IGZuKC4uLmFyZ3MpKTtcbn1cblxudmFyIF9kZWZlcjtcblxuaWYgKGhhc1NldEltbWVkaWF0ZSkge1xuICAgIF9kZWZlciA9IHNldEltbWVkaWF0ZTtcbn0gZWxzZSBpZiAoaGFzTmV4dFRpY2spIHtcbiAgICBfZGVmZXIgPSBwcm9jZXNzLm5leHRUaWNrO1xufSBlbHNlIHtcbiAgICBfZGVmZXIgPSBmYWxsYmFjaztcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gd3JhcChfZGVmZXIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBfd2l0aG91dEluZGV4O1xuZnVuY3Rpb24gX3dpdGhvdXRJbmRleChpdGVyYXRlZSkge1xuICAgIHJldHVybiAodmFsdWUsIGluZGV4LCBjYWxsYmFjaykgPT4gaXRlcmF0ZWUodmFsdWUsIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1tcImRlZmF1bHRcIl07IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzQXN5bmNJdGVyYWJsZSA9IGV4cG9ydHMuaXNBc3luY0dlbmVyYXRvciA9IGV4cG9ydHMuaXNBc3luYyA9IHVuZGVmaW5lZDtcblxudmFyIF9hc3luY2lmeSA9IHJlcXVpcmUoJy4uL2FzeW5jaWZ5Jyk7XG5cbnZhciBfYXN5bmNpZnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXN5bmNpZnkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBpc0FzeW5jKGZuKSB7XG4gICAgcmV0dXJuIGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcihmbikge1xuICAgIHJldHVybiBmbltTeW1ib2wudG9TdHJpbmdUYWddID09PSAnQXN5bmNHZW5lcmF0b3InO1xufVxuXG5mdW5jdGlvbiBpc0FzeW5jSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiB3cmFwQXN5bmMoYXN5bmNGbikge1xuICAgIGlmICh0eXBlb2YgYXN5bmNGbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG4gICAgcmV0dXJuIGlzQXN5bmMoYXN5bmNGbikgPyAoMCwgX2FzeW5jaWZ5Mi5kZWZhdWx0KShhc3luY0ZuKSA6IGFzeW5jRm47XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHdyYXBBc3luYztcbmV4cG9ydHMuaXNBc3luYyA9IGlzQXN5bmM7XG5leHBvcnRzLmlzQXN5bmNHZW5lcmF0b3IgPSBpc0FzeW5jR2VuZXJhdG9yO1xuZXhwb3J0cy5pc0FzeW5jSXRlcmFibGUgPSBpc0FzeW5jSXRlcmFibGU7IiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX21hcDIgPSByZXF1aXJlKCcuL2ludGVybmFsL21hcCcpO1xuXG52YXIgX21hcDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9tYXAyKTtcblxudmFyIF9lYWNoT2YgPSByZXF1aXJlKCcuL2VhY2hPZicpO1xuXG52YXIgX2VhY2hPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2YpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeScpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBQcm9kdWNlcyBhIG5ldyBjb2xsZWN0aW9uIG9mIHZhbHVlcyBieSBtYXBwaW5nIGVhY2ggdmFsdWUgaW4gYGNvbGxgIHRocm91Z2hcbiAqIHRoZSBgaXRlcmF0ZWVgIGZ1bmN0aW9uLiBUaGUgYGl0ZXJhdGVlYCBpcyBjYWxsZWQgd2l0aCBhbiBpdGVtIGZyb20gYGNvbGxgXG4gKiBhbmQgYSBjYWxsYmFjayBmb3Igd2hlbiBpdCBoYXMgZmluaXNoZWQgcHJvY2Vzc2luZy4gRWFjaCBvZiB0aGVzZSBjYWxsYmFja1xuICogdGFrZXMgMiBhcmd1bWVudHM6IGFuIGBlcnJvcmAsIGFuZCB0aGUgdHJhbnNmb3JtZWQgaXRlbSBmcm9tIGBjb2xsYC4gSWZcbiAqIGBpdGVyYXRlZWAgcGFzc2VzIGFuIGVycm9yIHRvIGl0cyBjYWxsYmFjaywgdGhlIG1haW4gYGNhbGxiYWNrYCAoZm9yIHRoZVxuICogYG1hcGAgZnVuY3Rpb24pIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBOb3RlLCB0aGF0IHNpbmNlIHRoaXMgZnVuY3Rpb24gYXBwbGllcyB0aGUgYGl0ZXJhdGVlYCB0byBlYWNoIGl0ZW0gaW5cbiAqIHBhcmFsbGVsLCB0aGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCB0aGUgYGl0ZXJhdGVlYCBmdW5jdGlvbnMgd2lsbCBjb21wbGV0ZVxuICogaW4gb3JkZXIuIEhvd2V2ZXIsIHRoZSByZXN1bHRzIGFycmF5IHdpbGwgYmUgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4gKiBvcmlnaW5hbCBgY29sbGAuXG4gKlxuICogSWYgYG1hcGAgaXMgcGFzc2VkIGFuIE9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBhbiBBcnJheS4gIFRoZSByZXN1bHRzXG4gKiB3aWxsIHJvdWdobHkgYmUgaW4gdGhlIG9yZGVyIG9mIHRoZSBvcmlnaW5hbCBPYmplY3RzJyBrZXlzIChidXQgdGhpcyBjYW5cbiAqIHZhcnkgYWNyb3NzIEphdmFTY3JpcHQgZW5naW5lcykuXG4gKlxuICogQG5hbWUgbWFwXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbGxlY3Rpb25zXG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gY29sbCAtIEEgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0FzeW5jRnVuY3Rpb259IGl0ZXJhdGVlIC0gQW4gYXN5bmMgZnVuY3Rpb24gdG8gYXBwbHkgdG8gZWFjaCBpdGVtIGluXG4gKiBgY29sbGAuXG4gKiBUaGUgaXRlcmF0ZWUgc2hvdWxkIGNvbXBsZXRlIHdpdGggdGhlIHRyYW5zZm9ybWVkIGl0ZW0uXG4gKiBJbnZva2VkIHdpdGggKGl0ZW0sIGNhbGxiYWNrKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gLSBBIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIGFsbCBgaXRlcmF0ZWVgXG4gKiBmdW5jdGlvbnMgaGF2ZSBmaW5pc2hlZCwgb3IgYW4gZXJyb3Igb2NjdXJzLiBSZXN1bHRzIGlzIGFuIEFycmF5IG9mIHRoZVxuICogdHJhbnNmb3JtZWQgaXRlbXMgZnJvbSB0aGUgYGNvbGxgLiBJbnZva2VkIHdpdGggKGVyciwgcmVzdWx0cykuXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gYSBwcm9taXNlLCBpZiBubyBjYWxsYmFjayBpcyBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKlxuICogYXN5bmMubWFwKFsnZmlsZTEnLCdmaWxlMicsJ2ZpbGUzJ10sIGZzLnN0YXQsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGFuIGFycmF5IG9mIHN0YXRzIGZvciBlYWNoIGZpbGVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBtYXAoY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKSB7XG4gIHJldHVybiAoMCwgX21hcDMuZGVmYXVsdCkoX2VhY2hPZjIuZGVmYXVsdCwgY29sbCwgaXRlcmF0ZWUsIGNhbGxiYWNrKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfYXdhaXRpZnkyLmRlZmF1bHQpKG1hcCwgMyk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTsiLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBwYXJhbGxlbDtcblxudmFyIF9lYWNoT2YgPSByZXF1aXJlKCcuL2VhY2hPZicpO1xuXG52YXIgX2VhY2hPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9lYWNoT2YpO1xuXG52YXIgX3BhcmFsbGVsMiA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvcGFyYWxsZWwnKTtcblxudmFyIF9wYXJhbGxlbDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wYXJhbGxlbDIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG4vKipcbiAqIFJ1biB0aGUgYHRhc2tzYCBjb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyBpbiBwYXJhbGxlbCwgd2l0aG91dCB3YWl0aW5nIHVudGlsXG4gKiB0aGUgcHJldmlvdXMgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZC4gSWYgYW55IG9mIHRoZSBmdW5jdGlvbnMgcGFzcyBhbiBlcnJvciB0b1xuICogaXRzIGNhbGxiYWNrLCB0aGUgbWFpbiBgY2FsbGJhY2tgIGlzIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSB2YWx1ZSBvZiB0aGVcbiAqIGVycm9yLiBPbmNlIHRoZSBgdGFza3NgIGhhdmUgY29tcGxldGVkLCB0aGUgcmVzdWx0cyBhcmUgcGFzc2VkIHRvIHRoZSBmaW5hbFxuICogYGNhbGxiYWNrYCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogYHBhcmFsbGVsYCBpcyBhYm91dCBraWNraW5nLW9mZiBJL08gdGFza3MgaW4gcGFyYWxsZWwsIG5vdCBhYm91dFxuICogcGFyYWxsZWwgZXhlY3V0aW9uIG9mIGNvZGUuICBJZiB5b3VyIHRhc2tzIGRvIG5vdCB1c2UgYW55IHRpbWVycyBvciBwZXJmb3JtXG4gKiBhbnkgSS9PLCB0aGV5IHdpbGwgYWN0dWFsbHkgYmUgZXhlY3V0ZWQgaW4gc2VyaWVzLiAgQW55IHN5bmNocm9ub3VzIHNldHVwXG4gKiBzZWN0aW9ucyBmb3IgZWFjaCB0YXNrIHdpbGwgaGFwcGVuIG9uZSBhZnRlciB0aGUgb3RoZXIuICBKYXZhU2NyaXB0IHJlbWFpbnNcbiAqIHNpbmdsZS10aHJlYWRlZC5cbiAqXG4gKiAqKkhpbnQ6KiogVXNlIFtgcmVmbGVjdGBde0BsaW5rIG1vZHVsZTpVdGlscy5yZWZsZWN0fSB0byBjb250aW51ZSB0aGVcbiAqIGV4ZWN1dGlvbiBvZiBvdGhlciB0YXNrcyB3aGVuIGEgdGFzayBmYWlscy5cbiAqXG4gKiBJdCBpcyBhbHNvIHBvc3NpYmxlIHRvIHVzZSBhbiBvYmplY3QgaW5zdGVhZCBvZiBhbiBhcnJheS4gRWFjaCBwcm9wZXJ0eSB3aWxsXG4gKiBiZSBydW4gYXMgYSBmdW5jdGlvbiBhbmQgdGhlIHJlc3VsdHMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGZpbmFsIGBjYWxsYmFja2BcbiAqIGFzIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGFuIGFycmF5LiBUaGlzIGNhbiBiZSBhIG1vcmUgcmVhZGFibGUgd2F5IG9mIGhhbmRsaW5nXG4gKiByZXN1bHRzIGZyb20ge0BsaW5rIGFzeW5jLnBhcmFsbGVsfS5cbiAqXG4gKiBAbmFtZSBwYXJhbGxlbFxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIG1vZHVsZTpDb250cm9sRmxvd1xuICogQG1ldGhvZFxuICogQGNhdGVnb3J5IENvbnRyb2wgRmxvd1xuICogQHBhcmFtIHtBcnJheXxJdGVyYWJsZXxBc3luY0l0ZXJhYmxlfE9iamVjdH0gdGFza3MgLSBBIGNvbGxlY3Rpb24gb2ZcbiAqIFthc3luYyBmdW5jdGlvbnNde0BsaW5rIEFzeW5jRnVuY3Rpb259IHRvIHJ1bi5cbiAqIEVhY2ggYXN5bmMgZnVuY3Rpb24gY2FuIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBvcHRpb25hbCBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS4gVGhpcyBmdW5jdGlvbiBnZXRzIGEgcmVzdWx0cyBhcnJheVxuICogKG9yIG9iamVjdCkgY29udGFpbmluZyBhbGwgdGhlIHJlc3VsdCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSB0YXNrIGNhbGxiYWNrcy5cbiAqIEludm9rZWQgd2l0aCAoZXJyLCByZXN1bHRzKS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBhIHByb21pc2UsIGlmIGEgY2FsbGJhY2sgaXMgbm90IHBhc3NlZFxuICpcbiAqIEBleGFtcGxlXG4gKiBhc3luYy5wYXJhbGxlbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsICdvbmUnKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAndHdvJyk7XG4gKiAgICAgICAgIH0sIDEwMCk7XG4gKiAgICAgfVxuICogXSxcbiAqIC8vIG9wdGlvbmFsIGNhbGxiYWNrXG4gKiBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAqICAgICAvLyB0aGUgcmVzdWx0cyBhcnJheSB3aWxsIGVxdWFsIFsnb25lJywndHdvJ10gZXZlbiB0aG91Z2hcbiAqICAgICAvLyB0aGUgc2Vjb25kIGZ1bmN0aW9uIGhhZCBhIHNob3J0ZXIgdGltZW91dC5cbiAqIH0pO1xuICpcbiAqIC8vIGFuIGV4YW1wbGUgdXNpbmcgYW4gb2JqZWN0IGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqIGFzeW5jLnBhcmFsbGVsKHtcbiAqICAgICBvbmU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCAxKTtcbiAqICAgICAgICAgfSwgMjAwKTtcbiAqICAgICB9LFxuICogICAgIHR3bzogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIDIpO1xuICogICAgICAgICB9LCAxMDApO1xuICogICAgIH1cbiAqIH0sIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICogICAgIC8vIHJlc3VsdHMgaXMgbm93IGVxdWFscyB0bzoge29uZTogMSwgdHdvOiAyfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHBhcmFsbGVsKHRhc2tzLCBjYWxsYmFjaykge1xuICByZXR1cm4gKDAsIF9wYXJhbGxlbDMuZGVmYXVsdCkoX2VhY2hPZjIuZGVmYXVsdCwgdGFza3MsIGNhbGxiYWNrKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gcmV0cnk7XG5cbnZhciBfd3JhcEFzeW5jID0gcmVxdWlyZSgnLi9pbnRlcm5hbC93cmFwQXN5bmMnKTtcblxudmFyIF93cmFwQXN5bmMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd3JhcEFzeW5jKTtcblxudmFyIF9wcm9taXNlQ2FsbGJhY2sgPSByZXF1aXJlKCcuL2ludGVybmFsL3Byb21pc2VDYWxsYmFjaycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGdldCBhIHN1Y2Nlc3NmdWwgcmVzcG9uc2UgZnJvbSBgdGFza2Agbm8gbW9yZSB0aGFuIGB0aW1lc2AgdGltZXNcbiAqIGJlZm9yZSByZXR1cm5pbmcgYW4gZXJyb3IuIElmIHRoZSB0YXNrIGlzIHN1Y2Nlc3NmdWwsIHRoZSBgY2FsbGJhY2tgIHdpbGwgYmVcbiAqIHBhc3NlZCB0aGUgcmVzdWx0IG9mIHRoZSBzdWNjZXNzZnVsIHRhc2suIElmIGFsbCBhdHRlbXB0cyBmYWlsLCB0aGUgY2FsbGJhY2tcbiAqIHdpbGwgYmUgcGFzc2VkIHRoZSBlcnJvciBhbmQgcmVzdWx0IChpZiBhbnkpIG9mIHRoZSBmaW5hbCBhdHRlbXB0LlxuICpcbiAqIEBuYW1lIHJldHJ5XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgbW9kdWxlOkNvbnRyb2xGbG93XG4gKiBAbWV0aG9kXG4gKiBAY2F0ZWdvcnkgQ29udHJvbCBGbG93XG4gKiBAc2VlIFthc3luYy5yZXRyeWFibGVde0BsaW5rIG1vZHVsZTpDb250cm9sRmxvdy5yZXRyeWFibGV9XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ9IFtvcHRzID0ge3RpbWVzOiA1LCBpbnRlcnZhbDogMH18IDVdIC0gQ2FuIGJlIGVpdGhlciBhblxuICogb2JqZWN0IHdpdGggYHRpbWVzYCBhbmQgYGludGVydmFsYCBvciBhIG51bWJlci5cbiAqICogYHRpbWVzYCAtIFRoZSBudW1iZXIgb2YgYXR0ZW1wdHMgdG8gbWFrZSBiZWZvcmUgZ2l2aW5nIHVwLiAgVGhlIGRlZmF1bHRcbiAqICAgaXMgYDVgLlxuICogKiBgaW50ZXJ2YWxgIC0gVGhlIHRpbWUgdG8gd2FpdCBiZXR3ZWVuIHJldHJpZXMsIGluIG1pbGxpc2Vjb25kcy4gIFRoZVxuICogICBkZWZhdWx0IGlzIGAwYC4gVGhlIGludGVydmFsIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhcyBhIGZ1bmN0aW9uIG9mIHRoZVxuICogICByZXRyeSBjb3VudCAoc2VlIGV4YW1wbGUpLlxuICogKiBgZXJyb3JGaWx0ZXJgIC0gQW4gb3B0aW9uYWwgc3luY2hyb25vdXMgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkIG9uXG4gKiAgIGVycm9uZW91cyByZXN1bHQuIElmIGl0IHJldHVybnMgYHRydWVgIHRoZSByZXRyeSBhdHRlbXB0cyB3aWxsIGNvbnRpbnVlO1xuICogICBpZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgZmFsc2VgIHRoZSByZXRyeSBmbG93IGlzIGFib3J0ZWQgd2l0aCB0aGUgY3VycmVudFxuICogICBhdHRlbXB0J3MgZXJyb3IgYW5kIHJlc3VsdCBiZWluZyByZXR1cm5lZCB0byB0aGUgZmluYWwgY2FsbGJhY2suXG4gKiAgIEludm9rZWQgd2l0aCAoZXJyKS5cbiAqICogSWYgYG9wdHNgIGlzIGEgbnVtYmVyLCB0aGUgbnVtYmVyIHNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5LFxuICogICB3aXRoIHRoZSBkZWZhdWx0IGludGVydmFsIG9mIGAwYC5cbiAqIEBwYXJhbSB7QXN5bmNGdW5jdGlvbn0gdGFzayAtIEFuIGFzeW5jIGZ1bmN0aW9uIHRvIHJldHJ5LlxuICogSW52b2tlZCB3aXRoIChjYWxsYmFjaykuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIHdoZW4gdGhlXG4gKiB0YXNrIGhhcyBzdWNjZWVkZWQsIG9yIGFmdGVyIHRoZSBmaW5hbCBmYWlsZWQgYXR0ZW1wdC4gSXQgcmVjZWl2ZXMgdGhlIGBlcnJgXG4gKiBhbmQgYHJlc3VsdGAgYXJndW1lbnRzIG9mIHRoZSBsYXN0IGF0dGVtcHQgYXQgY29tcGxldGluZyB0aGUgYHRhc2tgLiBJbnZva2VkXG4gKiB3aXRoIChlcnIsIHJlc3VsdHMpLlxuICogQHJldHVybnMge1Byb21pc2V9IGEgcHJvbWlzZSBpZiBubyBjYWxsYmFjayBwcm92aWRlZFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogLy8gVGhlIGByZXRyeWAgZnVuY3Rpb24gY2FuIGJlIHVzZWQgYXMgYSBzdGFuZC1hbG9uZSBjb250cm9sIGZsb3cgYnkgcGFzc2luZ1xuICogLy8gYSBjYWxsYmFjaywgYXMgc2hvd24gYmVsb3c6XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDMgdGltZXNcbiAqIGFzeW5jLnJldHJ5KDMsIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0cnkgY2FsbGluZyBhcGlNZXRob2QgMyB0aW1lcywgd2FpdGluZyAyMDAgbXMgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeSh7dGltZXM6IDMsIGludGVydmFsOiAyMDB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIDEwIHRpbWVzIHdpdGggZXhwb25lbnRpYWwgYmFja29mZlxuICogLy8gKGkuZS4gaW50ZXJ2YWxzIG9mIDEwMCwgMjAwLCA0MDAsIDgwMCwgMTYwMCwgLi4uIG1pbGxpc2Vjb25kcylcbiAqIGFzeW5jLnJldHJ5KHtcbiAqICAgdGltZXM6IDEwLFxuICogICBpbnRlcnZhbDogZnVuY3Rpb24ocmV0cnlDb3VudCkge1xuICogICAgIHJldHVybiA1MCAqIE1hdGgucG93KDIsIHJldHJ5Q291bnQpO1xuICogICB9XG4gKiB9LCBhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIHRoZSBkZWZhdWx0IDUgdGltZXMgbm8gZGVsYXkgYmV0d2VlbiBlYWNoIHJldHJ5XG4gKiBhc3luYy5yZXRyeShhcGlNZXRob2QsIGZ1bmN0aW9uKGVyciwgcmVzdWx0KSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdFxuICogfSk7XG4gKlxuICogLy8gdHJ5IGNhbGxpbmcgYXBpTWV0aG9kIG9ubHkgd2hlbiBlcnJvciBjb25kaXRpb24gc2F0aXNmaWVzLCBhbGwgb3RoZXJcbiAqIC8vIGVycm9ycyB3aWxsIGFib3J0IHRoZSByZXRyeSBjb250cm9sIGZsb3cgYW5kIHJldHVybiB0byBmaW5hbCBjYWxsYmFja1xuICogYXN5bmMucmV0cnkoe1xuICogICBlcnJvckZpbHRlcjogZnVuY3Rpb24oZXJyKSB7XG4gKiAgICAgcmV0dXJuIGVyci5tZXNzYWdlID09PSAnVGVtcG9yYXJ5IGVycm9yJzsgLy8gb25seSByZXRyeSBvbiBhIHNwZWNpZmljIGVycm9yXG4gKiAgIH1cbiAqIH0sIGFwaU1ldGhvZCwgZnVuY3Rpb24oZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyBkbyBzb21ldGhpbmcgd2l0aCB0aGUgcmVzdWx0XG4gKiB9KTtcbiAqXG4gKiAvLyB0byByZXRyeSBpbmRpdmlkdWFsIG1ldGhvZHMgdGhhdCBhcmUgbm90IGFzIHJlbGlhYmxlIHdpdGhpbiBvdGhlclxuICogLy8gY29udHJvbCBmbG93IGZ1bmN0aW9ucywgdXNlIHRoZSBgcmV0cnlhYmxlYCB3cmFwcGVyOlxuICogYXN5bmMuYXV0byh7XG4gKiAgICAgdXNlcnM6IGFwaS5nZXRVc2Vycy5iaW5kKGFwaSksXG4gKiAgICAgcGF5bWVudHM6IGFzeW5jLnJldHJ5YWJsZSgzLCBhcGkuZ2V0UGF5bWVudHMuYmluZChhcGkpKVxuICogfSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gKiAgICAgLy8gZG8gc29tZXRoaW5nIHdpdGggdGhlIHJlc3VsdHNcbiAqIH0pO1xuICpcbiAqL1xuY29uc3QgREVGQVVMVF9USU1FUyA9IDU7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMDtcblxuZnVuY3Rpb24gcmV0cnkob3B0cywgdGFzaywgY2FsbGJhY2spIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgdGltZXM6IERFRkFVTFRfVElNRVMsXG4gICAgICAgIGludGVydmFsRnVuYzogY29uc3RhbnQoREVGQVVMVF9JTlRFUlZBTClcbiAgICB9O1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzICYmIHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdGFzayB8fCAoMCwgX3Byb21pc2VDYWxsYmFjay5wcm9taXNlQ2FsbGJhY2spKCk7XG4gICAgICAgIHRhc2sgPSBvcHRzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlVGltZXMob3B0aW9ucywgb3B0cyk7XG4gICAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgKDAsIF9wcm9taXNlQ2FsbGJhY2sucHJvbWlzZUNhbGxiYWNrKSgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdGFzayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50cyBmb3IgYXN5bmMucmV0cnlcIik7XG4gICAgfVxuXG4gICAgdmFyIF90YXNrID0gKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKHRhc2spO1xuXG4gICAgdmFyIGF0dGVtcHQgPSAxO1xuICAgIGZ1bmN0aW9uIHJldHJ5QXR0ZW1wdCgpIHtcbiAgICAgICAgX3Rhc2soKGVyciwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpIHJldHVybjtcbiAgICAgICAgICAgIGlmIChlcnIgJiYgYXR0ZW1wdCsrIDwgb3B0aW9ucy50aW1lcyAmJiAodHlwZW9mIG9wdGlvbnMuZXJyb3JGaWx0ZXIgIT0gJ2Z1bmN0aW9uJyB8fCBvcHRpb25zLmVycm9yRmlsdGVyKGVycikpKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChyZXRyeUF0dGVtcHQsIG9wdGlvbnMuaW50ZXJ2YWxGdW5jKGF0dGVtcHQgLSAxKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgLi4uYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHJ5QXR0ZW1wdCgpO1xuICAgIHJldHVybiBjYWxsYmFja1tfcHJvbWlzZUNhbGxiYWNrLlBST01JU0VfU1lNQk9MXTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUaW1lcyhhY2MsIHQpIHtcbiAgICBpZiAodHlwZW9mIHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFjYy50aW1lcyA9ICt0LnRpbWVzIHx8IERFRkFVTFRfVElNRVM7XG5cbiAgICAgICAgYWNjLmludGVydmFsRnVuYyA9IHR5cGVvZiB0LmludGVydmFsID09PSAnZnVuY3Rpb24nID8gdC5pbnRlcnZhbCA6IGNvbnN0YW50KCt0LmludGVydmFsIHx8IERFRkFVTFRfSU5URVJWQUwpO1xuXG4gICAgICAgIGFjYy5lcnJvckZpbHRlciA9IHQuZXJyb3JGaWx0ZXI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFjYy50aW1lcyA9ICt0IHx8IERFRkFVTFRfVElNRVM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudHMgZm9yIGFzeW5jLnJldHJ5XCIpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX29uY2UgPSByZXF1aXJlKCcuL2ludGVybmFsL29uY2UnKTtcblxudmFyIF9vbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29uY2UpO1xuXG52YXIgX29ubHlPbmNlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9vbmx5T25jZScpO1xuXG52YXIgX29ubHlPbmNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29ubHlPbmNlKTtcblxudmFyIF93cmFwQXN5bmMgPSByZXF1aXJlKCcuL2ludGVybmFsL3dyYXBBc3luYycpO1xuXG52YXIgX3dyYXBBc3luYzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93cmFwQXN5bmMpO1xuXG52YXIgX2F3YWl0aWZ5ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9hd2FpdGlmeScpO1xuXG52YXIgX2F3YWl0aWZ5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2F3YWl0aWZ5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBSdW5zIHRoZSBgdGFza3NgIGFycmF5IG9mIGZ1bmN0aW9ucyBpbiBzZXJpZXMsIGVhY2ggcGFzc2luZyB0aGVpciByZXN1bHRzIHRvXG4gKiB0aGUgbmV4dCBpbiB0aGUgYXJyYXkuIEhvd2V2ZXIsIGlmIGFueSBvZiB0aGUgYHRhc2tzYCBwYXNzIGFuIGVycm9yIHRvIHRoZWlyXG4gKiBvd24gY2FsbGJhY2ssIHRoZSBuZXh0IGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYW5kIHRoZSBtYWluIGBjYWxsYmFja2AgaXNcbiAqIGltbWVkaWF0ZWx5IGNhbGxlZCB3aXRoIHRoZSBlcnJvci5cbiAqXG4gKiBAbmFtZSB3YXRlcmZhbGxcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBtb2R1bGU6Q29udHJvbEZsb3dcbiAqIEBtZXRob2RcbiAqIEBjYXRlZ29yeSBDb250cm9sIEZsb3dcbiAqIEBwYXJhbSB7QXJyYXl9IHRhc2tzIC0gQW4gYXJyYXkgb2YgW2FzeW5jIGZ1bmN0aW9uc117QGxpbmsgQXN5bmNGdW5jdGlvbn1cbiAqIHRvIHJ1bi5cbiAqIEVhY2ggZnVuY3Rpb24gc2hvdWxkIGNvbXBsZXRlIHdpdGggYW55IG51bWJlciBvZiBgcmVzdWx0YCB2YWx1ZXMuXG4gKiBUaGUgYHJlc3VsdGAgdmFsdWVzIHdpbGwgYmUgcGFzc2VkIGFzIGFyZ3VtZW50cywgaW4gb3JkZXIsIHRvIHRoZSBuZXh0IHRhc2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gcnVuIG9uY2UgYWxsIHRoZVxuICogZnVuY3Rpb25zIGhhdmUgY29tcGxldGVkLiBUaGlzIHdpbGwgYmUgcGFzc2VkIHRoZSByZXN1bHRzIG9mIHRoZSBsYXN0IHRhc2snc1xuICogY2FsbGJhY2suIEludm9rZWQgd2l0aCAoZXJyLCBbcmVzdWx0c10pLlxuICogQHJldHVybnMgdW5kZWZpbmVkXG4gKiBAZXhhbXBsZVxuICpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqICAgICB9LFxuICogICAgIGZ1bmN0aW9uKGFyZzEsIGFyZzIsIGNhbGxiYWNrKSB7XG4gKiAgICAgICAgIC8vIGFyZzEgbm93IGVxdWFscyAnb25lJyBhbmQgYXJnMiBub3cgZXF1YWxzICd0d28nXG4gKiAgICAgICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogICAgIH0sXG4gKiAgICAgZnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAgICAgLy8gYXJnMSBub3cgZXF1YWxzICd0aHJlZSdcbiAqICAgICAgICAgY2FsbGJhY2sobnVsbCwgJ2RvbmUnKTtcbiAqICAgICB9XG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICpcbiAqIC8vIE9yLCB3aXRoIG5hbWVkIGZ1bmN0aW9uczpcbiAqIGFzeW5jLndhdGVyZmFsbChbXG4gKiAgICAgbXlGaXJzdEZ1bmN0aW9uLFxuICogICAgIG15U2Vjb25kRnVuY3Rpb24sXG4gKiAgICAgbXlMYXN0RnVuY3Rpb24sXG4gKiBdLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgICAvLyByZXN1bHQgbm93IGVxdWFscyAnZG9uZSdcbiAqIH0pO1xuICogZnVuY3Rpb24gbXlGaXJzdEZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gKiAgICAgY2FsbGJhY2sobnVsbCwgJ29uZScsICd0d28nKTtcbiAqIH1cbiAqIGZ1bmN0aW9uIG15U2Vjb25kRnVuY3Rpb24oYXJnMSwgYXJnMiwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ29uZScgYW5kIGFyZzIgbm93IGVxdWFscyAndHdvJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICd0aHJlZScpO1xuICogfVxuICogZnVuY3Rpb24gbXlMYXN0RnVuY3Rpb24oYXJnMSwgY2FsbGJhY2spIHtcbiAqICAgICAvLyBhcmcxIG5vdyBlcXVhbHMgJ3RocmVlJ1xuICogICAgIGNhbGxiYWNrKG51bGwsICdkb25lJyk7XG4gKiB9XG4gKi9cbmZ1bmN0aW9uIHdhdGVyZmFsbCh0YXNrcywgY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayA9ICgwLCBfb25jZTIuZGVmYXVsdCkoY2FsbGJhY2spO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXNrcykpIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIHdhdGVyZmFsbCBtdXN0IGJlIGFuIGFycmF5IG9mIGZ1bmN0aW9ucycpKTtcbiAgICBpZiAoIXRhc2tzLmxlbmd0aCkgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgdmFyIHRhc2tJbmRleCA9IDA7XG5cbiAgICBmdW5jdGlvbiBuZXh0VGFzayhhcmdzKSB7XG4gICAgICAgIHZhciB0YXNrID0gKDAsIF93cmFwQXN5bmMyLmRlZmF1bHQpKHRhc2tzW3Rhc2tJbmRleCsrXSk7XG4gICAgICAgIHRhc2soLi4uYXJncywgKDAsIF9vbmx5T25jZTIuZGVmYXVsdCkobmV4dCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5leHQoZXJyLCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChlcnIgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIGlmIChlcnIgfHwgdGFza0luZGV4ID09PSB0YXNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRUYXNrKGFyZ3MpO1xuICAgIH1cblxuICAgIG5leHRUYXNrKFtdKTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gKDAsIF9hd2FpdGlmeTIuZGVmYXVsdCkod2F0ZXJmYWxsKTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddOyIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0NyeXB0bywgRGVmYXVsdENyeXB0b30gZnJvbSAnLi9jcnlwdG9fdXRpbHMnO1xuaW1wb3J0IHtsb2d9IGZyb20gJy4vbG9nZ2VyJztcbmltcG9ydCB7U3RyaW5nTWFwfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEF1dGhvcml6YXRpb25SZXF1ZXN0IGFzIEpTT04uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aG9yaXphdGlvblJlcXVlc3RKc29uIHtcbiAgcmVzcG9uc2VfdHlwZTogc3RyaW5nO1xuICBjbGllbnRfaWQ6IHN0cmluZztcbiAgcmVkaXJlY3RfdXJpOiBzdHJpbmc7XG4gIHNjb3BlOiBzdHJpbmc7XG4gIHN0YXRlPzogc3RyaW5nO1xuICBleHRyYXM/OiBTdHJpbmdNYXA7XG4gIGludGVybmFsPzogU3RyaW5nTWFwO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSBuZXcgc3RhdGUuIFVzZWZ1bCBmb3IgQ1NSRiBwcm90ZWN0aW9uLlxuICovXG5jb25zdCBTSVpFID0gMTA7ICAvLyAxMCBieXRlc1xuY29uc3QgbmV3U3RhdGUgPSBmdW5jdGlvbihjcnlwdG86IENyeXB0byk6IHN0cmluZyB7XG4gIHJldHVybiBjcnlwdG8uZ2VuZXJhdGVSYW5kb20oU0laRSk7XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEF1dGhvcml6YXRpb25SZXF1ZXN0LlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gbG9vayBhdFxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi00LjEuMVxuICovXG5leHBvcnQgY2xhc3MgQXV0aG9yaXphdGlvblJlcXVlc3Qge1xuICBzdGF0aWMgUkVTUE9OU0VfVFlQRV9UT0tFTiA9ICd0b2tlbic7XG4gIHN0YXRpYyBSRVNQT05TRV9UWVBFX0NPREUgPSAnY29kZSc7XG5cbiAgLy8gTk9URTpcbiAgLy8gQm90aCByZWRpcmVjdF91cmkgYW5kIHN0YXRlIGFyZSBhY3R1YWxseSBvcHRpb25hbC5cbiAgLy8gSG93ZXZlciBBcHBBdXRoIGlzIG1vcmUgb3Bpb25pb25hdGVkLCBhbmQgcmVxdWlyZXMgeW91IHRvIHVzZSBib3RoLlxuXG4gIGNsaWVudElkOiBzdHJpbmc7XG4gIHJlZGlyZWN0VXJpOiBzdHJpbmc7XG4gIHNjb3BlOiBzdHJpbmc7XG4gIHJlc3BvbnNlVHlwZTogc3RyaW5nO1xuICBzdGF0ZTogc3RyaW5nO1xuICBleHRyYXM/OiBTdHJpbmdNYXA7XG4gIGludGVybmFsPzogU3RyaW5nTWFwO1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBBdXRob3JpemF0aW9uUmVxdWVzdC5cbiAgICogVXNlIGEgYHVuZGVmaW5lZGAgdmFsdWUgZm9yIHRoZSBgc3RhdGVgIHBhcmFtZXRlciwgdG8gZ2VuZXJhdGUgYSByYW5kb21cbiAgICogc3RhdGUgZm9yIENTUkYgcHJvdGVjdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgcmVxdWVzdDogQXV0aG9yaXphdGlvblJlcXVlc3RKc29uLFxuICAgICAgcHJpdmF0ZSBjcnlwdG86IENyeXB0byA9IG5ldyBEZWZhdWx0Q3J5cHRvKCksXG4gICAgICBwcml2YXRlIHVzZVBrY2U6IGJvb2xlYW4gPSB0cnVlKSB7XG4gICAgdGhpcy5jbGllbnRJZCA9IHJlcXVlc3QuY2xpZW50X2lkO1xuICAgIHRoaXMucmVkaXJlY3RVcmkgPSByZXF1ZXN0LnJlZGlyZWN0X3VyaTtcbiAgICB0aGlzLnNjb3BlID0gcmVxdWVzdC5zY29wZTtcbiAgICB0aGlzLnJlc3BvbnNlVHlwZSA9IHJlcXVlc3QucmVzcG9uc2VfdHlwZSB8fCBBdXRob3JpemF0aW9uUmVxdWVzdC5SRVNQT05TRV9UWVBFX0NPREU7XG4gICAgdGhpcy5zdGF0ZSA9IHJlcXVlc3Quc3RhdGUgfHwgbmV3U3RhdGUoY3J5cHRvKTtcbiAgICB0aGlzLmV4dHJhcyA9IHJlcXVlc3QuZXh0cmFzO1xuICAgIC8vIHJlYWQgaW50ZXJuYWwgcHJvcGVydGllcyBpZiBhdmFpbGFibGVcbiAgICB0aGlzLmludGVybmFsID0gcmVxdWVzdC5pbnRlcm5hbDtcbiAgfVxuXG4gIHNldHVwQ29kZVZlcmlmaWVyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy51c2VQa2NlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvZGVWZXJpZmllciA9IHRoaXMuY3J5cHRvLmdlbmVyYXRlUmFuZG9tKDEyOCk7XG4gICAgICBjb25zdCBjaGFsbGVuZ2U6IFByb21pc2U8c3RyaW5nfHVuZGVmaW5lZD4gPVxuICAgICAgICAgIHRoaXMuY3J5cHRvLmRlcml2ZUNoYWxsZW5nZShjb2RlVmVyaWZpZXIpLmNhdGNoKGVycm9yID0+IHtcbiAgICAgICAgICAgIGxvZygnVW5hYmxlIHRvIGdlbmVyYXRlIFBLQ0UgY2hhbGxlbmdlLiBOb3QgdXNpbmcgUEtDRScsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhbGxlbmdlLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGNvZGUgdXNlZC5cbiAgICAgICAgICB0aGlzLmludGVybmFsID0gdGhpcy5pbnRlcm5hbCB8fCB7fTtcbiAgICAgICAgICB0aGlzLmludGVybmFsWydjb2RlX3ZlcmlmaWVyJ10gPSBjb2RlVmVyaWZpZXI7XG4gICAgICAgICAgdGhpcy5leHRyYXMgPSB0aGlzLmV4dHJhcyB8fCB7fTtcbiAgICAgICAgICB0aGlzLmV4dHJhc1snY29kZV9jaGFsbGVuZ2UnXSA9IHJlc3VsdDtcbiAgICAgICAgICAvLyBXZSBhbHdheXMgdXNlIFMyNTYuIFBsYWluIGlzIG5vdCBnb29kIGVub3VnaC5cbiAgICAgICAgICB0aGlzLmV4dHJhc1snY29kZV9jaGFsbGVuZ2VfbWV0aG9kJ10gPSAnUzI1Nic7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIHRoZSBBdXRob3JpemF0aW9uUmVxdWVzdCB0byBhIEphdmFTY3JpcHQgT2JqZWN0LlxuICAgKi9cbiAgdG9Kc29uKCk6IFByb21pc2U8QXV0aG9yaXphdGlvblJlcXVlc3RKc29uPiB7XG4gICAgLy8gQWx3YXlzIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb2RlIHZlcmlmaWVyIGlzIHNldHVwIHdoZW4gdG9Kc29uKCkgaXMgY2FsbGVkLlxuICAgIHJldHVybiB0aGlzLnNldHVwQ29kZVZlcmlmaWVyKCkudGhlbigoKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXNwb25zZV90eXBlOiB0aGlzLnJlc3BvbnNlVHlwZSxcbiAgICAgICAgY2xpZW50X2lkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICByZWRpcmVjdF91cmk6IHRoaXMucmVkaXJlY3RVcmksXG4gICAgICAgIHNjb3BlOiB0aGlzLnNjb3BlLFxuICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZSxcbiAgICAgICAgZXh0cmFzOiB0aGlzLmV4dHJhcyxcbiAgICAgICAgaW50ZXJuYWw6IHRoaXMuaW50ZXJuYWxcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0F1dGhvcml6YXRpb25SZXF1ZXN0fSBmcm9tICcuL2F1dGhvcml6YXRpb25fcmVxdWVzdCc7XG5pbXBvcnQge0F1dGhvcml6YXRpb25FcnJvciwgQXV0aG9yaXphdGlvblJlc3BvbnNlfSBmcm9tICcuL2F1dGhvcml6YXRpb25fcmVzcG9uc2UnO1xuaW1wb3J0IHtBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb259IGZyb20gJy4vYXV0aG9yaXphdGlvbl9zZXJ2aWNlX2NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHtDcnlwdG99IGZyb20gJy4vY3J5cHRvX3V0aWxzJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge1F1ZXJ5U3RyaW5nVXRpbHN9IGZyb20gJy4vcXVlcnlfc3RyaW5nX3V0aWxzJztcbmltcG9ydCB7U3RyaW5nTWFwfSBmcm9tICcuL3R5cGVzJztcblxuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGEgbGFtYmRhIHRoYXQgY2FuIHRha2UgYW4gQXV0aG9yaXphdGlvblJlcXVlc3QsXG4gKiBhbmQgYW4gQXV0aG9yaXphdGlvblJlc3BvbnNlIGFzIGFyZ3VtZW50cy5cbiAqL1xuZXhwb3J0IHR5cGUgQXV0aG9yaXphdGlvbkxpc3RlbmVyID1cbiAgICAocmVxdWVzdDogQXV0aG9yaXphdGlvblJlcXVlc3QsXG4gICAgIHJlc3BvbnNlOiBBdXRob3JpemF0aW9uUmVzcG9uc2V8bnVsbCxcbiAgICAgZXJyb3I6IEF1dGhvcml6YXRpb25FcnJvcnxudWxsKSA9PiB2b2lkO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzdHJ1Y3R1cmFsIHR5cGUgaG9sZGluZyBib3RoIGF1dGhvcml6YXRpb24gcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aG9yaXphdGlvblJlcXVlc3RSZXNwb25zZSB7XG4gIHJlcXVlc3Q6IEF1dGhvcml6YXRpb25SZXF1ZXN0O1xuICByZXNwb25zZTogQXV0aG9yaXphdGlvblJlc3BvbnNlfG51bGw7XG4gIGVycm9yOiBBdXRob3JpemF0aW9uRXJyb3J8bnVsbDtcbn1cblxuLyoqXG4gKiBBdXRob3JpemF0aW9uIFNlcnZpY2Ugbm90aWZpZXIuXG4gKiBUaGlzIG1hbmFnZXMgdGhlIGNvbW11bmljYXRpb24gb2YgdGhlIEF1dGhvcml6YXRpb25SZXNwb25zZSB0byB0aGUgM3AgY2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgQXV0aG9yaXphdGlvbk5vdGlmaWVyIHtcbiAgcHJpdmF0ZSBsaXN0ZW5lcjogQXV0aG9yaXphdGlvbkxpc3RlbmVyfG51bGwgPSBudWxsO1xuXG4gIHNldEF1dGhvcml6YXRpb25MaXN0ZW5lcihsaXN0ZW5lcjogQXV0aG9yaXphdGlvbkxpc3RlbmVyKSB7XG4gICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhdXRob3JpemF0aW9uIGNvbXBsZXRlIGNhbGxiYWNrLlxuICAgKi9cbiAgb25BdXRob3JpemF0aW9uQ29tcGxldGUoXG4gICAgICByZXF1ZXN0OiBBdXRob3JpemF0aW9uUmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlOiBBdXRob3JpemF0aW9uUmVzcG9uc2V8bnVsbCxcbiAgICAgIGVycm9yOiBBdXRob3JpemF0aW9uRXJyb3J8bnVsbCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmxpc3RlbmVyKSB7XG4gICAgICAvLyBjb21wbGV0ZSBhdXRob3JpemF0aW9uIHJlcXVlc3RcbiAgICAgIHRoaXMubGlzdGVuZXIocmVxdWVzdCwgcmVzcG9uc2UsIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVE9ETyhyYWh1bHJhdkApOiBhZGQgbW9yZSBidWlsdCBpbiBwYXJhbWV0ZXJzLlxuLyogYnVpbHQgaW4gcGFyYW1ldGVycy4gKi9cbmV4cG9ydCBjb25zdCBCVUlMVF9JTl9QQVJBTUVURVJTID0gWydyZWRpcmVjdF91cmknLCAnY2xpZW50X2lkJywgJ3Jlc3BvbnNlX3R5cGUnLCAnc3RhdGUnLCAnc2NvcGUnXTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBpbnRlcmZhY2Ugd2hpY2ggaXMgY2FwYWJsZSBvZiBoYW5kbGluZyBhbiBhdXRob3JpemF0aW9uIHJlcXVlc3RcbiAqIHVzaW5nIHZhcmlvdXMgbWV0aG9kcyAoaWZyYW1lIC8gcG9wdXAgLyBkaWZmZXJlbnQgcHJvY2VzcyBldGMuKS5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEF1dGhvcml6YXRpb25SZXF1ZXN0SGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyB1dGlsczogUXVlcnlTdHJpbmdVdGlscywgcHJvdGVjdGVkIGNyeXB0bzogQ3J5cHRvKSB7fVxuXG4gIC8vIG5vdGlmaWVyIHNlbmQgdGhlIHJlc3BvbnNlIGJhY2sgdG8gdGhlIGNsaWVudC5cbiAgcHJvdGVjdGVkIG5vdGlmaWVyOiBBdXRob3JpemF0aW9uTm90aWZpZXJ8bnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIEEgdXRpbGl0eSBtZXRob2QgdG8gYmUgYWJsZSB0byBidWlsZCB0aGUgYXV0aG9yaXphdGlvbiByZXF1ZXN0IFVSTC5cbiAgICovXG4gIHByb3RlY3RlZCBidWlsZFJlcXVlc3RVcmwoXG4gICAgICBjb25maWd1cmF0aW9uOiBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sXG4gICAgICByZXF1ZXN0OiBBdXRob3JpemF0aW9uUmVxdWVzdCkge1xuICAgIC8vIGJ1aWxkIHRoZSBxdWVyeSBzdHJpbmdcbiAgICAvLyBjb2VyY2UgdG8gYW55IHR5cGUgZm9yIGNvbnZlbmllbmNlXG4gICAgbGV0IHJlcXVlc3RNYXA6IFN0cmluZ01hcCA9IHtcbiAgICAgICdyZWRpcmVjdF91cmknOiByZXF1ZXN0LnJlZGlyZWN0VXJpLFxuICAgICAgJ2NsaWVudF9pZCc6IHJlcXVlc3QuY2xpZW50SWQsXG4gICAgICAncmVzcG9uc2VfdHlwZSc6IHJlcXVlc3QucmVzcG9uc2VUeXBlLFxuICAgICAgJ3N0YXRlJzogcmVxdWVzdC5zdGF0ZSxcbiAgICAgICdzY29wZSc6IHJlcXVlc3Quc2NvcGVcbiAgICB9O1xuXG4gICAgLy8gY29weSBvdmVyIGV4dHJhc1xuICAgIGlmIChyZXF1ZXN0LmV4dHJhcykge1xuICAgICAgZm9yIChsZXQgZXh0cmEgaW4gcmVxdWVzdC5leHRyYXMpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QuZXh0cmFzLmhhc093blByb3BlcnR5KGV4dHJhKSkge1xuICAgICAgICAgIC8vIGNoZWNrIGJlZm9yZSBpbnNlcnRpbmcgdG8gcmVxdWVzdE1hcFxuICAgICAgICAgIGlmIChCVUlMVF9JTl9QQVJBTUVURVJTLmluZGV4T2YoZXh0cmEpIDwgMCkge1xuICAgICAgICAgICAgcmVxdWVzdE1hcFtleHRyYV0gPSByZXF1ZXN0LmV4dHJhc1tleHRyYV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHF1ZXJ5ID0gdGhpcy51dGlscy5zdHJpbmdpZnkocmVxdWVzdE1hcCk7XG4gICAgbGV0IGJhc2VVcmwgPSBjb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25FbmRwb2ludDtcbiAgICBsZXQgdXJsID0gYCR7YmFzZVVybH0/JHtxdWVyeX1gO1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGxldGVzIHRoZSBhdXRob3JpemF0aW9uIHJlcXVlc3QgaWYgbmVjZXNzYXJ5ICYgd2hlbiBwb3NzaWJsZS5cbiAgICovXG4gIGNvbXBsZXRlQXV0aG9yaXphdGlvblJlcXVlc3RJZlBvc3NpYmxlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIGNhbGwgY29tcGxldGUgYXV0aG9yaXphdGlvbiBpZiBwb3NzaWJsZSB0byBzZWUgdGhlcmUgbWlnaHRcbiAgICAvLyBiZSBhIHJlc3BvbnNlIHRoYXQgbmVlZHMgdG8gYmUgZGVsaXZlcmVkLlxuICAgIGxvZyhgQ2hlY2tpbmcgdG8gc2VlIGlmIHRoZXJlIGlzIGFuIGF1dGhvcml6YXRpb24gcmVzcG9uc2UgdG8gYmUgZGVsaXZlcmVkLmApO1xuICAgIGlmICghdGhpcy5ub3RpZmllcikge1xuICAgICAgbG9nKGBOb3RpZmllciBpcyBub3QgcHJlc2VudCBvbiBBdXRob3JpemF0aW9uUmVxdWVzdCBoYW5kbGVyLlxuICAgICAgICAgIE5vIGRlbGl2ZXJ5IG9mIHJlc3VsdCB3aWxsIGJlIHBvc3NpYmxlYClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGxldGVBdXRob3JpemF0aW9uUmVxdWVzdCgpLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGxvZyhgTm8gcmVzdWx0IGlzIGF2YWlsYWJsZSB5ZXQuYCk7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0ICYmIHRoaXMubm90aWZpZXIpIHtcbiAgICAgICAgdGhpcy5ub3RpZmllci5vbkF1dGhvcml6YXRpb25Db21wbGV0ZShyZXN1bHQucmVxdWVzdCwgcmVzdWx0LnJlc3BvbnNlLCByZXN1bHQuZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRlZmF1bHQgQXV0aG9yaXphdGlvbiBTZXJ2aWNlIG5vdGlmaWVyLlxuICAgKi9cbiAgc2V0QXV0aG9yaXphdGlvbk5vdGlmaWVyKG5vdGlmaWVyOiBBdXRob3JpemF0aW9uTm90aWZpZXIpOiBBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIge1xuICAgIHRoaXMubm90aWZpZXIgPSBub3RpZmllcjtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogTWFrZXMgYW4gYXV0aG9yaXphdGlvbiByZXF1ZXN0LlxuICAgKi9cbiAgYWJzdHJhY3QgcGVyZm9ybUF1dGhvcml6YXRpb25SZXF1ZXN0KFxuICAgICAgY29uZmlndXJhdGlvbjogQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uLFxuICAgICAgcmVxdWVzdDogQXV0aG9yaXphdGlvblJlcXVlc3QpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYW4gYXV0aG9yaXphdGlvbiBmbG93IGNhbiBiZSBjb21wbGV0ZWQsIGFuZCBjb21wbGV0ZXMgaXQuXG4gICAqIFRoZSBoYW5kbGVyIHJldHVybnMgYSBgUHJvbWlzZTxBdXRob3JpemF0aW9uUmVxdWVzdFJlc3BvbnNlPmAgaWYgcmVhZHksIG9yIGEgYFByb21pc2U8bnVsbD5gXG4gICAqIGlmIG5vdCByZWFkeS5cbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBjb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0KCk6IFByb21pc2U8QXV0aG9yaXphdGlvblJlcXVlc3RSZXNwb25zZXxudWxsPjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEF1dGhvcml6YXRpb25SZXNwb25zZSBhcyBhIEpTT04gb2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhvcml6YXRpb25SZXNwb25zZUpzb24ge1xuICBjb2RlOiBzdHJpbmc7XG4gIHN0YXRlOiBzdHJpbmc7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgQXV0aG9yaXphdGlvbkVycm9yIGFzIGEgSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQXV0aG9yaXphdGlvbkVycm9ySnNvbiB7XG4gIGVycm9yOiBzdHJpbmc7XG4gIGVycm9yX2Rlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBlcnJvcl91cmk/OiBzdHJpbmc7XG4gIHN0YXRlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIEF1dGhvcml6YXRpb24gUmVzcG9uc2UgdHlwZS5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGxvb2sgYXRcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tNC4xLjJcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dGhvcml6YXRpb25SZXNwb25zZSB7XG4gIGNvZGU6IHN0cmluZztcbiAgc3RhdGU6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihyZXNwb25zZTogQXV0aG9yaXphdGlvblJlc3BvbnNlSnNvbikge1xuICAgIHRoaXMuY29kZSA9IHJlc3BvbnNlLmNvZGU7XG4gICAgdGhpcy5zdGF0ZSA9IHJlc3BvbnNlLnN0YXRlO1xuICB9XG5cbiAgdG9Kc29uKCk6IEF1dGhvcml6YXRpb25SZXNwb25zZUpzb24ge1xuICAgIHJldHVybiB7Y29kZTogdGhpcy5jb2RlLCBzdGF0ZTogdGhpcy5zdGF0ZX07XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBBdXRob3JpemF0aW9uIGVycm9yIHJlc3BvbnNlLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gbG9vayBhdDpcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tNC4xLjIuMVxuICovXG5leHBvcnQgY2xhc3MgQXV0aG9yaXphdGlvbkVycm9yIHtcbiAgZXJyb3I6IHN0cmluZztcbiAgZXJyb3JEZXNjcmlwdGlvbj86IHN0cmluZztcbiAgZXJyb3JVcmk/OiBzdHJpbmc7XG4gIHN0YXRlPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGVycm9yOiBBdXRob3JpemF0aW9uRXJyb3JKc29uKSB7XG4gICAgdGhpcy5lcnJvciA9IGVycm9yLmVycm9yO1xuICAgIHRoaXMuZXJyb3JEZXNjcmlwdGlvbiA9IGVycm9yLmVycm9yX2Rlc2NyaXB0aW9uO1xuICAgIHRoaXMuZXJyb3JVcmkgPSBlcnJvci5lcnJvcl91cmk7XG4gICAgdGhpcy5zdGF0ZSA9IGVycm9yLnN0YXRlO1xuICB9XG5cbiAgdG9Kc29uKCk6IEF1dGhvcml6YXRpb25FcnJvckpzb24ge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogdGhpcy5lcnJvcixcbiAgICAgIGVycm9yX2Rlc2NyaXB0aW9uOiB0aGlzLmVycm9yRGVzY3JpcHRpb24sXG4gICAgICBlcnJvcl91cmk6IHRoaXMuZXJyb3JVcmksXG4gICAgICBzdGF0ZTogdGhpcy5zdGF0ZVxuICAgIH07XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0pRdWVyeVJlcXVlc3RvciwgUmVxdWVzdG9yfSBmcm9tICcuL3hocic7XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbiBhcyBhIEpTT04gb2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbkpzb24ge1xuICBhdXRob3JpemF0aW9uX2VuZHBvaW50OiBzdHJpbmc7XG4gIHRva2VuX2VuZHBvaW50OiBzdHJpbmc7XG4gIHJldm9jYXRpb25fZW5kcG9pbnQ6IHN0cmluZztcbiAgZW5kX3Nlc3Npb25fZW5kcG9pbnQ/OiBzdHJpbmc7XG4gIHVzZXJpbmZvX2VuZHBvaW50Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFRoZSBzdGFuZGFyZCBiYXNlIHBhdGggZm9yIHdlbGwta25vd24gcmVzb3VyY2VzIG9uIGRvbWFpbnMuXG4gKiBTZWUgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzU3ODUgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKi9cbmNvbnN0IFdFTExfS05PV05fUEFUSCA9ICcud2VsbC1rbm93bic7XG5cbi8qKlxuICogVGhlIHN0YW5kYXJkIHJlc291cmNlIHVuZGVyIHRoZSB3ZWxsIGtub3duIHBhdGggYXQgd2hpY2ggYW4gT3BlbklEIENvbm5lY3RcbiAqIGRpc2NvdmVyeSBkb2N1bWVudCBjYW4gYmUgZm91bmQgdW5kZXIgYW4gaXNzdWVyJ3MgYmFzZSBVUkkuXG4gKi9cbmNvbnN0IE9QRU5JRF9DT05GSUdVUkFUSU9OID0gJ29wZW5pZC1jb25maWd1cmF0aW9uJztcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGRldGFpbHMgcmVxdWlyZWQgdG8gaW50ZXJhY3Qgd2l0aCBhbiBhdXRob3JpemF0aW9uIHNlcnZpY2UuXG4gKlxuICogTW9yZSBpbmZvcm1hdGlvbiBhdCBodHRwczovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtZGlzY292ZXJ5LTFfMC0xNy5odG1sXG4gKi9cbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24ge1xuICBhdXRob3JpemF0aW9uRW5kcG9pbnQ6IHN0cmluZztcbiAgdG9rZW5FbmRwb2ludDogc3RyaW5nO1xuICByZXZvY2F0aW9uRW5kcG9pbnQ6IHN0cmluZztcbiAgdXNlckluZm9FbmRwb2ludD86IHN0cmluZztcbiAgZW5kU2Vzc2lvbkVuZHBvaW50Pzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHJlcXVlc3Q6IEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbkpzb24pIHtcbiAgICB0aGlzLmF1dGhvcml6YXRpb25FbmRwb2ludCA9IHJlcXVlc3QuYXV0aG9yaXphdGlvbl9lbmRwb2ludDtcbiAgICB0aGlzLnRva2VuRW5kcG9pbnQgPSByZXF1ZXN0LnRva2VuX2VuZHBvaW50O1xuICAgIHRoaXMucmV2b2NhdGlvbkVuZHBvaW50ID0gcmVxdWVzdC5yZXZvY2F0aW9uX2VuZHBvaW50O1xuICAgIHRoaXMudXNlckluZm9FbmRwb2ludCA9IHJlcXVlc3QudXNlcmluZm9fZW5kcG9pbnQ7XG4gICAgdGhpcy5lbmRTZXNzaW9uRW5kcG9pbnQgPSByZXF1ZXN0LmVuZF9zZXNzaW9uX2VuZHBvaW50O1xuICB9XG5cbiAgdG9Kc29uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhdXRob3JpemF0aW9uX2VuZHBvaW50OiB0aGlzLmF1dGhvcml6YXRpb25FbmRwb2ludCxcbiAgICAgIHRva2VuX2VuZHBvaW50OiB0aGlzLnRva2VuRW5kcG9pbnQsXG4gICAgICByZXZvY2F0aW9uX2VuZHBvaW50OiB0aGlzLnJldm9jYXRpb25FbmRwb2ludCxcbiAgICAgIGVuZF9zZXNzaW9uX2VuZHBvaW50OiB0aGlzLmVuZFNlc3Npb25FbmRwb2ludCxcbiAgICAgIHVzZXJpbmZvX2VuZHBvaW50OiB0aGlzLnVzZXJJbmZvRW5kcG9pbnRcbiAgICB9O1xuICB9XG5cbiAgc3RhdGljIGZldGNoRnJvbUlzc3VlcihvcGVuSWRJc3N1ZXJVcmw6IHN0cmluZywgcmVxdWVzdG9yPzogUmVxdWVzdG9yKTpcbiAgICAgIFByb21pc2U8QXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uPiB7XG4gICAgY29uc3QgZnVsbFVybCA9IGAke29wZW5JZElzc3VlclVybH0vJHtXRUxMX0tOT1dOX1BBVEh9LyR7T1BFTklEX0NPTkZJR1VSQVRJT059YDtcblxuICAgIGNvbnN0IHJlcXVlc3RvclRvVXNlID0gcmVxdWVzdG9yIHx8IG5ldyBKUXVlcnlSZXF1ZXN0b3IoKTtcblxuICAgIHJldHVybiByZXF1ZXN0b3JUb1VzZVxuICAgICAgICAueGhyPEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbkpzb24+KHt1cmw6IGZ1bGxVcmwsIGRhdGFUeXBlOiAnanNvbicsIG1ldGhvZDogJ0dFVCd9KVxuICAgICAgICAudGhlbihqc29uID0+IG5ldyBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24oanNvbikpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0ICogYXMgYmFzZTY0IGZyb20gJ2Jhc2U2NC1qcyc7XG5cbmltcG9ydCB7QXBwQXV0aEVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5cbmNvbnN0IEhBU19DUllQVE8gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhISh3aW5kb3cuY3J5cHRvIGFzIGFueSk7XG5jb25zdCBIQVNfU1VCVExFX0NSWVBUTyA9IEhBU19DUllQVE8gJiYgISEod2luZG93LmNyeXB0by5zdWJ0bGUgYXMgYW55KTtcbmNvbnN0IENIQVJTRVQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODknO1xuXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyOiBVaW50OEFycmF5KSB7XG4gIGxldCBzdGF0ZSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlci5ieXRlTGVuZ3RoOyBpICs9IDEpIHtcbiAgICBsZXQgaW5kZXggPSBidWZmZXJbaV0gJSBDSEFSU0VULmxlbmd0aDtcbiAgICBzdGF0ZS5wdXNoKENIQVJTRVRbaW5kZXhdKTtcbiAgfVxuICByZXR1cm4gc3RhdGUuam9pbignJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmxTYWZlKGJ1ZmZlcjogVWludDhBcnJheSk6IHN0cmluZyB7XG4gIGNvbnN0IGVuY29kZWQgPSBiYXNlNjQuZnJvbUJ5dGVBcnJheShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgcmV0dXJuIGVuY29kZWQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJykucmVwbGFjZSgvPS9nLCAnJyk7XG59XG5cbi8vIGFkYXB0ZWQgZnJvbSBzb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExMDU4ODU4XG4vLyB0aGlzIGlzIHVzZWQgaW4gcGxhY2Ugb2YgVGV4dEVuY29kZSBhcyB0aGUgYXBpIGlzIG5vdCB5ZXRcbi8vIHdlbGwgc3VwcG9ydGVkOiBodHRwczovL2Nhbml1c2UuY29tLyNzZWFyY2g9VGV4dEVuY29kZXJcbmV4cG9ydCBmdW5jdGlvbiB0ZXh0RW5jb2RlTGl0ZShzdHI6IHN0cmluZykge1xuICBjb25zdCBidWYgPSBuZXcgQXJyYXlCdWZmZXIoc3RyLmxlbmd0aCk7XG4gIGNvbnN0IGJ1ZlZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmVmlld1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBidWZWaWV3O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyeXB0byB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBzdHJpbmdcbiAgICovXG4gIGdlbmVyYXRlUmFuZG9tKHNpemU6IG51bWJlcik6IHN0cmluZztcbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIFNIQTI1NiBvZiBhIGdpdmVuIGNvZGUuXG4gICAqIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgUEtDRS5cbiAgICovXG4gIGRlcml2ZUNoYWxsZW5nZShjb2RlOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz47XG59XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGBDcnlwdG9gIGludGVyZmFjZS5cbiAqIFRoaXMgdXNlcyB0aGUgY2FwYWJpbGl0aWVzIG9mIHRoZSBicm93c2VyLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdENyeXB0byBpbXBsZW1lbnRzIENyeXB0byB7XG4gIGdlbmVyYXRlUmFuZG9tKHNpemU6IG51bWJlcikge1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIGlmIChIQVNfQ1JZUFRPKSB7XG4gICAgICB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhidWZmZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb20oKSBpZiBub3RoaW5nIGVsc2UgaXMgYXZhaWxhYmxlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgICAgICBidWZmZXJbaV0gPSAoTWF0aC5yYW5kb20oKSAqIENIQVJTRVQubGVuZ3RoKSB8IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXJUb1N0cmluZyhidWZmZXIpO1xuICB9XG5cbiAgZGVyaXZlQ2hhbGxlbmdlKGNvZGU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG4gICAgaWYgKGNvZGUubGVuZ3RoIDwgNDMgfHwgY29kZS5sZW5ndGggPiAxMjgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQXBwQXV0aEVycm9yKCdJbnZhbGlkIGNvZGUgbGVuZ3RoLicpKTtcbiAgICB9XG4gICAgaWYgKCFIQVNfU1VCVExFX0NSWVBUTykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBBcHBBdXRoRXJyb3IoJ3dpbmRvdy5jcnlwdG8uc3VidGxlIGlzIHVuYXZhaWxhYmxlLicpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY3J5cHRvLnN1YnRsZS5kaWdlc3QoJ1NIQS0yNTYnLCB0ZXh0RW5jb2RlTGl0ZShjb2RlKSkudGhlbihidWZmZXIgPT4ge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh1cmxTYWZlKG5ldyBVaW50OEFycmF5KGJ1ZmZlcikpKTtcbiAgICAgIH0sIGVycm9yID0+IHJlamVjdChlcnJvcikpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBBcHBBdXRoRXJyb3IgdHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEFwcEF1dGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHB1YmxpYyBtZXNzYWdlOiBzdHJpbmcsIHB1YmxpYyBleHRyYXM/OiBhbnkpIHt9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogR2xvYmFsIGZsYWdzIHRoYXQgY29udHJvbCB0aGUgYmVoYXZpb3Igb2YgQXBwIEF1dGggSlMuICovXG5cbi8qIExvZ2dpbmcgdHVybmVkIG9uID8gKi9cbmV4cG9ydCBjb25zdCBJU19MT0cgPSB0cnVlO1xuXG4vKiBQcm9maWxpbmcgdHVybmVkIG9uID8gKi9cbmV4cG9ydCBjb25zdCBJU19QUk9GSUxFID0gZmFsc2U7XG4iLCJleHBvcnQgKiBmcm9tICcuL2F1dGhvcml6YXRpb25fcmVxdWVzdCc7XG5leHBvcnQgKiBmcm9tICcuL2F1dGhvcml6YXRpb25fcmVxdWVzdF9oYW5kbGVyJztcbmV4cG9ydCAqIGZyb20gJy4vYXV0aG9yaXphdGlvbl9yZXNwb25zZSc7XG5leHBvcnQgKiBmcm9tICcuL2F1dGhvcml6YXRpb25fc2VydmljZV9jb25maWd1cmF0aW9uJztcbmV4cG9ydCAqIGZyb20gJy4vY3J5cHRvX3V0aWxzJztcbmV4cG9ydCAqIGZyb20gJy4vZXJyb3JzJztcbmV4cG9ydCAqIGZyb20gJy4vZmxhZ3MnO1xuZXhwb3J0ICogZnJvbSAnLi9sb2dnZXInO1xuZXhwb3J0ICogZnJvbSAnLi9xdWVyeV9zdHJpbmdfdXRpbHMnO1xuZXhwb3J0ICogZnJvbSAnLi9yZWRpcmVjdF9iYXNlZF9oYW5kbGVyJztcbmV4cG9ydCAqIGZyb20gJy4vcmV2b2tlX3Rva2VuX3JlcXVlc3QnO1xuZXhwb3J0ICogZnJvbSAnLi9zdG9yYWdlJztcbmV4cG9ydCAqIGZyb20gJy4vdG9rZW5fcmVxdWVzdCc7XG5leHBvcnQgKiBmcm9tICcuL3Rva2VuX3JlcXVlc3RfaGFuZGxlcic7XG5leHBvcnQgKiBmcm9tICcuL3Rva2VuX3Jlc3BvbnNlJztcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0ICogZnJvbSAnLi94aHInO1xuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7SVNfTE9HLCBJU19QUk9GSUxFfSBmcm9tICcuL2ZsYWdzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGxvZyhtZXNzYWdlOiBzdHJpbmcsIC4uLmFyZ3M6IGFueVtdKSB7XG4gIGlmIChJU19MT0cpIHtcbiAgICBsZXQgbGVuZ3RoID0gYXJncyA/IGFyZ3MubGVuZ3RoIDogMDtcbiAgICBpZiAobGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2cobWVzc2FnZSwgLi4uYXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gY2hlY2sgdG8gc2VlIGlmIG5hdGl2ZSBzdXBwb3J0IGZvciBwcm9maWxpbmcgaXMgYXZhaWxhYmxlLlxuY29uc3QgTkFUSVZFX1BST0ZJTEVfU1VQUE9SVCA9XG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgISF3aW5kb3cucGVyZm9ybWFuY2UgJiYgISFjb25zb2xlLnByb2ZpbGU7XG5cbi8qKlxuICogQSBkZWNvcmF0b3IgdGhhdCBjYW4gcHJvZmlsZSBhIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvZmlsZSh0YXJnZXQ6IGFueSwgcHJvcGVydHlLZXk6IHN0cmluZywgZGVzY3JpcHRvcjogUHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gIGlmIChJU19QUk9GSUxFKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1Qcm9maWxlKHRhcmdldCwgcHJvcGVydHlLZXksIGRlc2NyaXB0b3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJldHVybiBhcy1pc1xuICAgIHJldHVybiBkZXNjcmlwdG9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Qcm9maWxlKFxuICAgIHRhcmdldDogYW55LCBwcm9wZXJ0eUtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpOiBQcm9wZXJ0eURlc2NyaXB0b3Ige1xuICBsZXQgb3JpZ2luYWxDYWxsYWJsZSA9IGRlc2NyaXB0b3IudmFsdWU7XG4gIC8vIG5hbWUgbXVzdCBleGlzdFxuICBsZXQgbmFtZSA9IG9yaWdpbmFsQ2FsbGFibGUubmFtZTtcbiAgaWYgKCFuYW1lKSB7XG4gICAgbmFtZSA9ICdhbm9ueW1vdXMgZnVuY3Rpb24nO1xuICB9XG4gIGlmIChOQVRJVkVfUFJPRklMRV9TVVBQT1JUKSB7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uKGFyZ3M6IGFueVtdKSB7XG4gICAgICBjb25zb2xlLnByb2ZpbGUobmFtZSk7XG4gICAgICBsZXQgc3RhcnRUaW1lID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsQ2FsbGFibGUuY2FsbCh0aGlzIHx8IHdpbmRvdywgLi4uYXJncyk7XG4gICAgICBsZXQgZHVyYXRpb24gPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgICBjb25zb2xlLmxvZyhgJHtuYW1lfSB0b29rICR7ZHVyYXRpb259IG1zYCk7XG4gICAgICBjb25zb2xlLnByb2ZpbGVFbmQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oYXJnczogYW55W10pIHtcbiAgICAgIGxvZyhgUHJvZmlsZSBzdGFydCAke25hbWV9YCk7XG4gICAgICBsZXQgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgbGV0IHJlc3VsdCA9IG9yaWdpbmFsQ2FsbGFibGUuY2FsbCh0aGlzIHx8IHdpbmRvdywgLi4uYXJncyk7XG4gICAgICBsZXQgZHVyYXRpb24gPSBEYXRlLm5vdygpIC0gc3RhcnQ7XG4gICAgICBsb2coYFByb2ZpbGUgZW5kICR7bmFtZX0gdG9vayAke2R1cmF0aW9ufSBtcy5gKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZGVzY3JpcHRvcjtcbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0xvY2F0aW9uTGlrZSwgU3RyaW5nTWFwfSBmcm9tICcuL3R5cGVzJztcblxuXG4vKipcbiAqIFF1ZXJ5IFN0cmluZyBVdGlsaXRpZXMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUXVlcnlTdHJpbmdVdGlscyB7XG4gIHN0cmluZ2lmeShpbnB1dDogU3RyaW5nTWFwKTogc3RyaW5nO1xuICBwYXJzZShxdWVyeTogTG9jYXRpb25MaWtlLCB1c2VIYXNoPzogYm9vbGVhbik6IFN0cmluZ01hcDtcbiAgcGFyc2VRdWVyeVN0cmluZyhxdWVyeTogc3RyaW5nKTogU3RyaW5nTWFwO1xufVxuXG5leHBvcnQgY2xhc3MgQmFzaWNRdWVyeVN0cmluZ1V0aWxzIGltcGxlbWVudHMgUXVlcnlTdHJpbmdVdGlscyB7XG4gIHBhcnNlKGlucHV0OiBMb2NhdGlvbkxpa2UsIHVzZUhhc2g/OiBib29sZWFuKSB7XG4gICAgaWYgKHVzZUhhc2gpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUXVlcnlTdHJpbmcoaW5wdXQuaGFzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUXVlcnlTdHJpbmcoaW5wdXQuc2VhcmNoKTtcbiAgICB9XG4gIH1cblxuICBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5OiBzdHJpbmcpOiBTdHJpbmdNYXAge1xuICAgIGxldCByZXN1bHQ6IFN0cmluZ01hcCA9IHt9O1xuICAgIC8vIGlmIGFueXRoaW5nIHN0YXJ0cyB3aXRoID8sICMgb3IgJiByZW1vdmUgaXRcbiAgICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuICAgIGxldCBwYXJhbXMgPSBxdWVyeS5zcGxpdCgnJicpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBsZXQgcGFyYW0gPSBwYXJhbXNbaV07ICAvLyBsb29rcyBzb21ldGhpbmcgbGlrZSBhPWJcbiAgICAgIGxldCBwYXJ0cyA9IHBhcmFtLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgbGV0IGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChwYXJ0cy5zaGlmdCgpISk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyBwYXJ0cy5qb2luKCc9JykgOiBudWxsO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0cmluZ2lmeShpbnB1dDogU3RyaW5nTWFwKSB7XG4gICAgbGV0IGVuY29kZWQ6IHN0cmluZ1tdID0gW107XG4gICAgZm9yIChsZXQga2V5IGluIGlucHV0KSB7XG4gICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpbnB1dFtrZXldKSB7XG4gICAgICAgIGVuY29kZWQucHVzaChgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09JHtlbmNvZGVVUklDb21wb25lbnQoaW5wdXRba2V5XSl9YClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWQuam9pbignJicpO1xuICB9XG59XG4iLCIvKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdFxuICogaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZVxuICogTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXJcbiAqIGV4cHJlc3Mgb3IgaW1wbGllZC4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtBdXRob3JpemF0aW9uUmVxdWVzdH0gZnJvbSAnLi9hdXRob3JpemF0aW9uX3JlcXVlc3QnO1xuaW1wb3J0IHtBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIsIEF1dGhvcml6YXRpb25SZXF1ZXN0UmVzcG9uc2V9IGZyb20gJy4vYXV0aG9yaXphdGlvbl9yZXF1ZXN0X2hhbmRsZXInO1xuaW1wb3J0IHtBdXRob3JpemF0aW9uRXJyb3IsIEF1dGhvcml6YXRpb25SZXNwb25zZX0gZnJvbSAnLi9hdXRob3JpemF0aW9uX3Jlc3BvbnNlJ1xuaW1wb3J0IHtBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb259IGZyb20gJy4vYXV0aG9yaXphdGlvbl9zZXJ2aWNlX2NvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHtDcnlwdG8sIERlZmF1bHRDcnlwdG99IGZyb20gJy4vY3J5cHRvX3V0aWxzJztcbmltcG9ydCB7bG9nfSBmcm9tICcuL2xvZ2dlcic7XG5pbXBvcnQge0Jhc2ljUXVlcnlTdHJpbmdVdGlsc30gZnJvbSAnLi9xdWVyeV9zdHJpbmdfdXRpbHMnO1xuaW1wb3J0IHtMb2NhbFN0b3JhZ2VCYWNrZW5kLCBTdG9yYWdlQmFja2VuZH0gZnJvbSAnLi9zdG9yYWdlJztcbmltcG9ydCB7TG9jYXRpb25MaWtlfSBmcm9tICcuL3R5cGVzJztcblxuXG4vKioga2V5IGZvciBhdXRob3JpemF0aW9uIHJlcXVlc3QuICovXG5jb25zdCBhdXRob3JpemF0aW9uUmVxdWVzdEtleSA9XG4gICAgKGhhbmRsZTogc3RyaW5nKSA9PiB7XG4gICAgICByZXR1cm4gYCR7aGFuZGxlfV9hcHBhdXRoX2F1dGhvcml6YXRpb25fcmVxdWVzdGA7XG4gICAgfVxuXG4vKioga2V5IGZvciBhdXRob3JpemF0aW9uIHNlcnZpY2UgY29uZmlndXJhdGlvbiAqL1xuY29uc3QgYXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uS2V5ID1cbiAgICAoaGFuZGxlOiBzdHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBgJHtoYW5kbGV9X2FwcGF1dGhfYXV0aG9yaXphdGlvbl9zZXJ2aWNlX2NvbmZpZ3VyYXRpb25gO1xuICAgIH1cblxuLyoqIGtleSBpbiBsb2NhbCBzdG9yYWdlIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgYXV0aG9yaXphdGlvbiByZXF1ZXN0LiAqL1xuY29uc3QgQVVUSE9SSVpBVElPTl9SRVFVRVNUX0hBTkRMRV9LRVkgPSAnYXBwYXV0aF9jdXJyZW50X2F1dGhvcml6YXRpb25fcmVxdWVzdCc7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiBBdXRob3JpemF0aW9uUmVxdWVzdEhhbmRsZXIgd2hpY2ggdXNlcyBhIHN0YW5kYXJkXG4gKiByZWRpcmVjdCBiYXNlZCBjb2RlIGZsb3cuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWRpcmVjdFJlcXVlc3RIYW5kbGVyIGV4dGVuZHMgQXV0aG9yaXphdGlvblJlcXVlc3RIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IoXG4gICAgICAvLyB1c2UgdGhlIHByb3ZpZGVkIHN0b3JhZ2UgYmFja2VuZFxuICAgICAgLy8gb3IgaW5pdGlhbGl6ZSBsb2NhbCBzdG9yYWdlIHdpdGggdGhlIGRlZmF1bHQgc3RvcmFnZSBiYWNrZW5kIHdoaWNoXG4gICAgICAvLyB1c2VzIHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICAgIHB1YmxpYyBzdG9yYWdlQmFja2VuZDogU3RvcmFnZUJhY2tlbmQgPSBuZXcgTG9jYWxTdG9yYWdlQmFja2VuZCgpLFxuICAgICAgdXRpbHMgPSBuZXcgQmFzaWNRdWVyeVN0cmluZ1V0aWxzKCksXG4gICAgICBwdWJsaWMgbG9jYXRpb25MaWtlOiBMb2NhdGlvbkxpa2UgPSB3aW5kb3cubG9jYXRpb24sXG4gICAgICBjcnlwdG86IENyeXB0byA9IG5ldyBEZWZhdWx0Q3J5cHRvKCkpIHtcbiAgICBzdXBlcih1dGlscywgY3J5cHRvKTtcbiAgfVxuXG4gIHBlcmZvcm1BdXRob3JpemF0aW9uUmVxdWVzdChcbiAgICAgIGNvbmZpZ3VyYXRpb246IEF1dGhvcml6YXRpb25TZXJ2aWNlQ29uZmlndXJhdGlvbixcbiAgICAgIHJlcXVlc3Q6IEF1dGhvcml6YXRpb25SZXF1ZXN0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gdGhpcy5jcnlwdG8uZ2VuZXJhdGVSYW5kb20oMTApO1xuXG4gICAgLy8gYmVmb3JlIHlvdSBtYWtlIHJlcXVlc3QsIHBlcnNpc3QgYWxsIHJlcXVlc3QgcmVsYXRlZCBkYXRhIGluIGxvY2FsIHN0b3JhZ2UuXG4gICAgY29uc3QgcGVyc2lzdGVkID0gUHJvbWlzZS5hbGwoW1xuICAgICAgdGhpcy5zdG9yYWdlQmFja2VuZC5zZXRJdGVtKEFVVEhPUklaQVRJT05fUkVRVUVTVF9IQU5ETEVfS0VZLCBoYW5kbGUpLFxuICAgICAgLy8gQ2FsbGluZyB0b0pzb24oKSBhZGRzIGluIHRoZSBjb2RlICYgY2hhbGxlbmdlIHdoZW4gcG9zc2libGVcbiAgICAgIHJlcXVlc3QudG9Kc29uKCkudGhlbihcbiAgICAgICAgICByZXN1bHQgPT5cbiAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlQmFja2VuZC5zZXRJdGVtKGF1dGhvcml6YXRpb25SZXF1ZXN0S2V5KGhhbmRsZSksIEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpKSxcbiAgICAgIHRoaXMuc3RvcmFnZUJhY2tlbmQuc2V0SXRlbShcbiAgICAgICAgICBhdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb25LZXkoaGFuZGxlKSwgSlNPTi5zdHJpbmdpZnkoY29uZmlndXJhdGlvbi50b0pzb24oKSkpLFxuICAgIF0pO1xuXG4gICAgcGVyc2lzdGVkLnRoZW4oKCkgPT4ge1xuICAgICAgLy8gbWFrZSB0aGUgcmVkaXJlY3QgcmVxdWVzdFxuICAgICAgbGV0IHVybCA9IHRoaXMuYnVpbGRSZXF1ZXN0VXJsKGNvbmZpZ3VyYXRpb24sIHJlcXVlc3QpO1xuICAgICAgbG9nKCdNYWtpbmcgYSByZXF1ZXN0IHRvICcsIHJlcXVlc3QsIHVybCk7XG4gICAgICB0aGlzLmxvY2F0aW9uTGlrZS5hc3NpZ24odXJsKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBpbnRyb3NwZWN0IHRoZSBjb250ZW50cyBvZiBzdG9yYWdlIGJhY2tlbmQgYW5kIGNvbXBsZXRlcyB0aGVcbiAgICogcmVxdWVzdC5cbiAgICovXG4gIHByb3RlY3RlZCBjb21wbGV0ZUF1dGhvcml6YXRpb25SZXF1ZXN0KCk6IFByb21pc2U8QXV0aG9yaXphdGlvblJlcXVlc3RSZXNwb25zZXxudWxsPiB7XG4gICAgLy8gVE9ETyhyYWh1bHJhdkApOiBoYW5kbGUgYXV0aG9yaXphdGlvbiBlcnJvcnMuXG4gICAgcmV0dXJuIHRoaXMuc3RvcmFnZUJhY2tlbmQuZ2V0SXRlbShBVVRIT1JJWkFUSU9OX1JFUVVFU1RfSEFORExFX0tFWSkudGhlbihoYW5kbGUgPT4ge1xuICAgICAgaWYgKGhhbmRsZSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcGVuZGluZyByZXF1ZXN0LlxuICAgICAgICAvLyBmZXRjaCBhdXRob3JpemF0aW9uIHJlcXVlc3QsIGFuZCBjaGVjayBzdGF0ZVxuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlQmFja2VuZFxuICAgICAgICAgICAgLmdldEl0ZW0oYXV0aG9yaXphdGlvblJlcXVlc3RLZXkoaGFuZGxlKSlcbiAgICAgICAgICAgIC8vIHJlcXVpcmVzIGEgY29ycmVzcG9uZGluZyBpbnN0YW5jZSBvZiByZXN1bHRcbiAgICAgICAgICAgIC8vIFRPRE8ocmFodWxyYXZAKTogY2hlY2sgZm9yIGluY29uc2l0ZW50IHN0YXRlIGhlcmVcbiAgICAgICAgICAgIC50aGVuKHJlc3VsdCA9PiBKU09OLnBhcnNlKHJlc3VsdCEpKVxuICAgICAgICAgICAgLnRoZW4oanNvbiA9PiBuZXcgQXV0aG9yaXphdGlvblJlcXVlc3QoanNvbikpXG4gICAgICAgICAgICAudGhlbihyZXF1ZXN0ID0+IHtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgcmVkaXJlY3RfdXJpIGFuZCBzdGF0ZVxuICAgICAgICAgICAgICBsZXQgY3VycmVudFVyaSA9IGAke3RoaXMubG9jYXRpb25MaWtlLm9yaWdpbn0ke3RoaXMubG9jYXRpb25MaWtlLnBhdGhuYW1lfWA7XG4gICAgICAgICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHRoaXMudXRpbHMucGFyc2UodGhpcy5sb2NhdGlvbkxpa2UsIHRydWUgLyogdXNlIGhhc2ggKi8pO1xuICAgICAgICAgICAgICBsZXQgc3RhdGU6IHN0cmluZ3x1bmRlZmluZWQgPSBxdWVyeVBhcmFtc1snc3RhdGUnXTtcbiAgICAgICAgICAgICAgbGV0IGNvZGU6IHN0cmluZ3x1bmRlZmluZWQgPSBxdWVyeVBhcmFtc1snY29kZSddO1xuICAgICAgICAgICAgICBsZXQgZXJyb3I6IHN0cmluZ3x1bmRlZmluZWQgPSBxdWVyeVBhcmFtc1snZXJyb3InXTtcbiAgICAgICAgICAgICAgbG9nKCdQb3RlbnRpYWwgYXV0aG9yaXphdGlvbiByZXF1ZXN0ICcsIGN1cnJlbnRVcmksIHF1ZXJ5UGFyYW1zLCBzdGF0ZSwgY29kZSwgZXJyb3IpO1xuICAgICAgICAgICAgICBsZXQgc2hvdWxkTm90aWZ5ID0gc3RhdGUgPT09IHJlcXVlc3Quc3RhdGU7XG4gICAgICAgICAgICAgIGxldCBhdXRob3JpemF0aW9uUmVzcG9uc2U6IEF1dGhvcml6YXRpb25SZXNwb25zZXxudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgbGV0IGF1dGhvcml6YXRpb25FcnJvcjogQXV0aG9yaXphdGlvbkVycm9yfG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBnZXQgYWRkaXRpb25hbCBvcHRpb25hbCBpbmZvLlxuICAgICAgICAgICAgICAgICAgbGV0IGVycm9yVXJpID0gcXVlcnlQYXJhbXNbJ2Vycm9yX3VyaSddO1xuICAgICAgICAgICAgICAgICAgbGV0IGVycm9yRGVzY3JpcHRpb24gPSBxdWVyeVBhcmFtc1snZXJyb3JfZGVzY3JpcHRpb24nXTtcbiAgICAgICAgICAgICAgICAgIGF1dGhvcml6YXRpb25FcnJvciA9IG5ldyBBdXRob3JpemF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yX2Rlc2NyaXB0aW9uOiBlcnJvckRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcl91cmk6IGVycm9yVXJpLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBhdXRob3JpemF0aW9uUmVzcG9uc2UgPSBuZXcgQXV0aG9yaXphdGlvblJlc3BvbnNlKHtjb2RlOiBjb2RlLCBzdGF0ZTogc3RhdGV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gY2xlYW51cCBzdGF0ZVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlXG4gICAgICAgICAgICAgICAgICAgIC5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZUJhY2tlbmQucmVtb3ZlSXRlbShBVVRIT1JJWkFUSU9OX1JFUVVFU1RfSEFORExFX0tFWSksXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlQmFja2VuZC5yZW1vdmVJdGVtKGF1dGhvcml6YXRpb25SZXF1ZXN0S2V5KGhhbmRsZSkpLFxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcmFnZUJhY2tlbmQucmVtb3ZlSXRlbShhdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb25LZXkoaGFuZGxlKSlcbiAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGxvZygnRGVsaXZlcmluZyBhdXRob3JpemF0aW9uIHJlc3BvbnNlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogYXV0aG9yaXphdGlvblJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGF1dGhvcml6YXRpb25FcnJvclxuICAgICAgICAgICAgICAgICAgICAgIH0gYXMgQXV0aG9yaXphdGlvblJlcXVlc3RSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nKCdNaXNtYXRjaGVkIHJlcXVlc3QgKHN0YXRlIGFuZCByZXF1ZXN0X3VyaSkgZG9udCBtYXRjaC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG4iLCJpbXBvcnQge1N0cmluZ01hcH0gZnJvbSAnLi90eXBlcyc7XG5cbi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFN1cHBvcnRlZCB0b2tlbiB0eXBlc1xuICovXG5leHBvcnQgdHlwZSBUb2tlblR5cGVIaW50ID0gJ3JlZnJlc2hfdG9rZW4nfCdhY2Nlc3NfdG9rZW4nO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFRva2VuIFJlcXVlc3QgYXMgSlNPTi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXZva2VUb2tlblJlcXVlc3RKc29uIHtcbiAgdG9rZW46IHN0cmluZztcbiAgdG9rZW5fdHlwZV9oaW50PzogVG9rZW5UeXBlSGludDtcbiAgY2xpZW50X2lkPzogc3RyaW5nO1xuICBjbGllbnRfc2VjcmV0Pzogc3RyaW5nO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSByZXZva2UgdG9rZW4gcmVxdWVzdC5cbiAqIEZvciBtb3JlIGluZm9ybWF0aW9uIGxvb2sgYXQ6XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzAwOSNzZWN0aW9uLTIuMVxuICovXG5leHBvcnQgY2xhc3MgUmV2b2tlVG9rZW5SZXF1ZXN0IHtcbiAgdG9rZW46IHN0cmluZztcbiAgdG9rZW5UeXBlSGludDogVG9rZW5UeXBlSGludHx1bmRlZmluZWQ7XG4gIGNsaWVudElkOiBzdHJpbmd8dW5kZWZpbmVkO1xuICBjbGllbnRTZWNyZXQ6IHN0cmluZ3x1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IocmVxdWVzdDogUmV2b2tlVG9rZW5SZXF1ZXN0SnNvbikge1xuICAgIHRoaXMudG9rZW4gPSByZXF1ZXN0LnRva2VuO1xuICAgIHRoaXMudG9rZW5UeXBlSGludCA9IHJlcXVlc3QudG9rZW5fdHlwZV9oaW50O1xuICAgIHRoaXMuY2xpZW50SWQgPSByZXF1ZXN0LmNsaWVudF9pZDtcbiAgICB0aGlzLmNsaWVudFNlY3JldCA9IHJlcXVlc3QuY2xpZW50X3NlY3JldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgVG9rZW5SZXF1ZXN0IHRvIGEgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAqL1xuICB0b0pzb24oKTogUmV2b2tlVG9rZW5SZXF1ZXN0SnNvbiB7XG4gICAgbGV0IGpzb246IFJldm9rZVRva2VuUmVxdWVzdEpzb24gPSB7dG9rZW46IHRoaXMudG9rZW59O1xuICAgIGlmICh0aGlzLnRva2VuVHlwZUhpbnQpIHtcbiAgICAgIGpzb25bJ3Rva2VuX3R5cGVfaGludCddID0gdGhpcy50b2tlblR5cGVIaW50O1xuICAgIH1cbiAgICBpZiAodGhpcy5jbGllbnRJZCkge1xuICAgICAganNvblsnY2xpZW50X2lkJ10gPSB0aGlzLmNsaWVudElkO1xuICAgIH1cbiAgICBpZiAodGhpcy5jbGllbnRTZWNyZXQpIHtcbiAgICAgIGpzb25bJ2NsaWVudF9zZWNyZXQnXSA9IHRoaXMuY2xpZW50U2VjcmV0O1xuICAgIH1cbiAgICByZXR1cm4ganNvbjtcbiAgfVxuXG4gIHRvU3RyaW5nTWFwKCk6IFN0cmluZ01hcCB7XG4gICAgbGV0IGpzb24gPSB0aGlzLnRvSnNvbigpO1xuICAgIC8vIDooXG4gICAgcmV0dXJuIChqc29uIGFzIGFueSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEEgc3Vic2V0IG9mIHRoZSBgU3RvcmFnZWAgaW50ZXJmYWNlIHdoaWNoIHdlIG5lZWQgZm9yIHRoZSBiYWNrZW5kcyB0byB3b3JrLlxuICpcbiAqIEVzc2VudGlhbGx5IHJlbW92ZXMgdGhlIGluZGV4YWJsZSBwcm9wZXJ0aWVzIGFuZCByZWFkb25seSBwcm9wZXJ0aWVzIGZyb21cbiAqIGBTdG9yYWdlYCBpbiBsaWIuZG9tLmQudHMuIFRoaXMgaXMgc28gdGhhdCBhIGN1c3RvbSB0eXBlIGNhbiBleHRlbmQgaXQgZm9yXG4gKiB0ZXN0aW5nLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVuZGVybHlpbmdTdG9yYWdlIHtcbiAgcmVhZG9ubHkgbGVuZ3RoOiBudW1iZXI7XG4gIGNsZWFyKCk6IHZvaWQ7XG4gIGdldEl0ZW0oa2V5OiBzdHJpbmcpOiBzdHJpbmd8bnVsbDtcbiAgcmVtb3ZlSXRlbShrZXk6IHN0cmluZyk6IHZvaWQ7XG4gIHNldEl0ZW0oa2V5OiBzdHJpbmcsIGRhdGE6IHN0cmluZyk6IHZvaWQ7XG59XG5cbi8qKlxuICogQXN5bmNocm9ub3VzIHN0b3JhZ2UgQVBJcy4gQWxsIG1ldGhvZHMgcmV0dXJuIGEgYFByb21pc2VgLlxuICogQWxsIG1ldGhvZHMgdGFrZSB0aGUgYERPTVN0cmluZ2BcbiAqIElETCB0eXBlIChhcyBpdCBpcyB0aGUgbG93ZXN0IGNvbW1vbiBkZW5vbWluYXRvcikuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTdG9yYWdlQmFja2VuZCB7XG4gIC8qKlxuICAgKiBXaGVuIHBhc3NlZCBhIGtleSBgbmFtZWAsIHdpbGwgcmV0dXJuIHRoYXQga2V5J3MgdmFsdWUuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3QgZ2V0SXRlbShuYW1lOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZ3xudWxsPjtcblxuICAvKipcbiAgICogV2hlbiBwYXNzZWQgYSBrZXkgYG5hbWVgLCB3aWxsIHJlbW92ZSB0aGF0IGtleSBmcm9tIHRoZSBzdG9yYWdlLlxuICAgKi9cbiAgcHVibGljIGFic3RyYWN0IHJlbW92ZUl0ZW0obmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPjtcblxuICAvKipcbiAgICogV2hlbiBpbnZva2VkLCB3aWxsIGVtcHR5IGFsbCBrZXlzIG91dCBvZiB0aGUgc3RvcmFnZS5cbiAgICovXG4gIHB1YmxpYyBhYnN0cmFjdCBjbGVhcigpOiBQcm9taXNlPHZvaWQ+O1xuXG4gIC8qKlxuICAgKiBUaGUgc2V0SXRlbSgpIG1ldGhvZCBvZiB0aGUgYFN0b3JhZ2VCYWNrZW5kYCBpbnRlcmZhY2UsXG4gICAqIHdoZW4gcGFzc2VkIGEga2V5IG5hbWUgYW5kIHZhbHVlLCB3aWxsIGFkZCB0aGF0IGtleSB0byB0aGUgc3RvcmFnZSxcbiAgICogb3IgdXBkYXRlIHRoYXQga2V5J3MgdmFsdWUgaWYgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAqL1xuICBwdWJsaWMgYWJzdHJhY3Qgc2V0SXRlbShuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+O1xufVxuXG4vKipcbiAqIEEgYFN0b3JhZ2VCYWNrZW5kYCBiYWNrZWQgYnkgYGxvY2Fsc3RvcmFnZWAuXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2NhbFN0b3JhZ2VCYWNrZW5kIGV4dGVuZHMgU3RvcmFnZUJhY2tlbmQge1xuICBwcml2YXRlIHN0b3JhZ2U6IFVuZGVybHlpbmdTdG9yYWdlO1xuICBjb25zdHJ1Y3RvcihzdG9yYWdlPzogVW5kZXJseWluZ1N0b3JhZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3RvcmFnZSA9IHN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfVxuXG4gIHB1YmxpYyBnZXRJdGVtKG5hbWU6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nfG51bGw+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nfG51bGw+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5zdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZUl0ZW0obmFtZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUpO1xuICAgICAgcmVzb2x2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGNsZWFyKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnN0b3JhZ2UuY2xlYXIoKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzZXRJdGVtKG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICByZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0XG4gKiBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlXG4gKiBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlclxuICogZXhwcmVzcyBvciBpbXBsaWVkLiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1N0cmluZ01hcH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBjb25zdCBHUkFOVF9UWVBFX0FVVEhPUklaQVRJT05fQ09ERSA9ICdhdXRob3JpemF0aW9uX2NvZGUnO1xuZXhwb3J0IGNvbnN0IEdSQU5UX1RZUEVfUkVGUkVTSF9UT0tFTiA9ICdyZWZyZXNoX3Rva2VuJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBUb2tlbiBSZXF1ZXN0IGFzIEpTT04uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5SZXF1ZXN0SnNvbiB7XG4gIGdyYW50X3R5cGU6IHN0cmluZztcbiAgY29kZT86IHN0cmluZztcbiAgcmVmcmVzaF90b2tlbj86IHN0cmluZywgcmVkaXJlY3RfdXJpOiBzdHJpbmc7XG4gIGNsaWVudF9pZDogc3RyaW5nO1xuICBleHRyYXM/OiBTdHJpbmdNYXA7XG59XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIEFjY2VzcyBUb2tlbiByZXF1ZXN0LlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gbG9vayBhdDpcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tNC4xLjNcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuUmVxdWVzdCB7XG4gIGNsaWVudElkOiBzdHJpbmc7XG4gIHJlZGlyZWN0VXJpOiBzdHJpbmc7XG4gIGdyYW50VHlwZTogc3RyaW5nO1xuICBjb2RlOiBzdHJpbmd8dW5kZWZpbmVkO1xuICByZWZyZXNoVG9rZW46IHN0cmluZ3x1bmRlZmluZWQ7XG4gIGV4dHJhczogU3RyaW5nTWFwfHVuZGVmaW5lZFxuXG4gIGNvbnN0cnVjdG9yKHJlcXVlc3Q6IFRva2VuUmVxdWVzdEpzb24pIHtcbiAgICB0aGlzLmNsaWVudElkID0gcmVxdWVzdC5jbGllbnRfaWQ7XG4gICAgdGhpcy5yZWRpcmVjdFVyaSA9IHJlcXVlc3QucmVkaXJlY3RfdXJpO1xuICAgIHRoaXMuZ3JhbnRUeXBlID0gcmVxdWVzdC5ncmFudF90eXBlO1xuICAgIHRoaXMuY29kZSA9IHJlcXVlc3QuY29kZTtcbiAgICB0aGlzLnJlZnJlc2hUb2tlbiA9IHJlcXVlc3QucmVmcmVzaF90b2tlbjtcbiAgICB0aGlzLmV4dHJhcyA9IHJlcXVlc3QuZXh0cmFzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZXMgYSBUb2tlblJlcXVlc3QgdG8gYSBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICovXG4gIHRvSnNvbigpOiBUb2tlblJlcXVlc3RKc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ3JhbnRfdHlwZTogdGhpcy5ncmFudFR5cGUsXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICByZWZyZXNoX3Rva2VuOiB0aGlzLnJlZnJlc2hUb2tlbixcbiAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVyaSxcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIGV4dHJhczogdGhpcy5leHRyYXNcbiAgICB9O1xuICB9XG5cbiAgdG9TdHJpbmdNYXAoKTogU3RyaW5nTWFwIHtcbiAgICBsZXQgbWFwOiBTdHJpbmdNYXAgPSB7XG4gICAgICBncmFudF90eXBlOiB0aGlzLmdyYW50VHlwZSxcbiAgICAgIGNsaWVudF9pZDogdGhpcy5jbGllbnRJZCxcbiAgICAgIHJlZGlyZWN0X3VyaTogdGhpcy5yZWRpcmVjdFVyaVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5jb2RlKSB7XG4gICAgICBtYXBbJ2NvZGUnXSA9IHRoaXMuY29kZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWZyZXNoVG9rZW4pIHtcbiAgICAgIG1hcFsncmVmcmVzaF90b2tlbiddID0gdGhpcy5yZWZyZXNoVG9rZW47XG4gICAgfVxuXG4gICAgLy8gY29weSBvdmVyIGV4dHJhc1xuICAgIGlmICh0aGlzLmV4dHJhcykge1xuICAgICAgZm9yIChsZXQgZXh0cmEgaW4gdGhpcy5leHRyYXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFzLmhhc093blByb3BlcnR5KGV4dHJhKSAmJiAhbWFwLmhhc093blByb3BlcnR5KGV4dHJhKSkge1xuICAgICAgICAgIC8vIGNoZWNrIGJlZm9yZSBpbnNlcnRpbmcgdG8gcmVxdWVzdE1hcFxuICAgICAgICAgIG1hcFtleHRyYV0gPSB0aGlzLmV4dHJhc1tleHRyYV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7QXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9ufSBmcm9tICcuL2F1dGhvcml6YXRpb25fc2VydmljZV9jb25maWd1cmF0aW9uJztcbmltcG9ydCB7QXBwQXV0aEVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge0Jhc2ljUXVlcnlTdHJpbmdVdGlscywgUXVlcnlTdHJpbmdVdGlsc30gZnJvbSAnLi9xdWVyeV9zdHJpbmdfdXRpbHMnO1xuaW1wb3J0IHtSZXZva2VUb2tlblJlcXVlc3R9IGZyb20gJy4vcmV2b2tlX3Rva2VuX3JlcXVlc3QnO1xuaW1wb3J0IHtUb2tlblJlcXVlc3R9IGZyb20gJy4vdG9rZW5fcmVxdWVzdCc7XG5pbXBvcnQge1Rva2VuRXJyb3IsIFRva2VuRXJyb3JKc29uLCBUb2tlblJlc3BvbnNlLCBUb2tlblJlc3BvbnNlSnNvbn0gZnJvbSAnLi90b2tlbl9yZXNwb25zZSc7XG5pbXBvcnQge0pRdWVyeVJlcXVlc3RvciwgUmVxdWVzdG9yfSBmcm9tICcuL3hocic7XG5cblxuLyoqXG4gKiBSZXByZXNlbnRzIGFuIGludGVyZmFjZSB3aGljaCBjYW4gbWFrZSBhIHRva2VuIHJlcXVlc3QuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9rZW5SZXF1ZXN0SGFuZGxlciB7XG4gIC8qKlxuICAgKiBQZXJmb3JtcyB0aGUgdG9rZW4gcmVxdWVzdCwgZ2l2ZW4gdGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbi5cbiAgICovXG4gIHBlcmZvcm1Ub2tlblJlcXVlc3QoY29uZmlndXJhdGlvbjogQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uLCByZXF1ZXN0OiBUb2tlblJlcXVlc3QpOlxuICAgICAgUHJvbWlzZTxUb2tlblJlc3BvbnNlPjtcblxuICBwZXJmb3JtUmV2b2tlVG9rZW5SZXF1ZXN0KFxuICAgICAgY29uZmlndXJhdGlvbjogQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uLFxuICAgICAgcmVxdWVzdDogUmV2b2tlVG9rZW5SZXF1ZXN0KTogUHJvbWlzZTxib29sZWFuPjtcbn1cblxuLyoqXG4gKiBUaGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGhhbmRsZXIuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlVG9rZW5SZXF1ZXN0SGFuZGxlciBpbXBsZW1lbnRzIFRva2VuUmVxdWVzdEhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcihcbiAgICAgIHB1YmxpYyByZWFkb25seSByZXF1ZXN0b3I6IFJlcXVlc3RvciA9IG5ldyBKUXVlcnlSZXF1ZXN0b3IoKSxcbiAgICAgIHB1YmxpYyByZWFkb25seSB1dGlsczogUXVlcnlTdHJpbmdVdGlscyA9IG5ldyBCYXNpY1F1ZXJ5U3RyaW5nVXRpbHMoKSkge31cblxuICBwcml2YXRlIGlzVG9rZW5SZXNwb25zZShyZXNwb25zZTogVG9rZW5SZXNwb25zZUpzb258XG4gICAgICAgICAgICAgICAgICAgICAgICAgIFRva2VuRXJyb3JKc29uKTogcmVzcG9uc2UgaXMgVG9rZW5SZXNwb25zZUpzb24ge1xuICAgIHJldHVybiAocmVzcG9uc2UgYXMgVG9rZW5FcnJvckpzb24pLmVycm9yID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICBwZXJmb3JtUmV2b2tlVG9rZW5SZXF1ZXN0KFxuICAgICAgY29uZmlndXJhdGlvbjogQXV0aG9yaXphdGlvblNlcnZpY2VDb25maWd1cmF0aW9uLFxuICAgICAgcmVxdWVzdDogUmV2b2tlVG9rZW5SZXF1ZXN0KTogUHJvbWlzZTxib29sZWFuPiB7XG4gICAgbGV0IHJldm9rZVRva2VuUmVzcG9uc2UgPSB0aGlzLnJlcXVlc3Rvci54aHI8Ym9vbGVhbj4oe1xuICAgICAgdXJsOiBjb25maWd1cmF0aW9uLnJldm9jYXRpb25FbmRwb2ludCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogeydDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ30sXG4gICAgICBkYXRhOiB0aGlzLnV0aWxzLnN0cmluZ2lmeShyZXF1ZXN0LnRvU3RyaW5nTWFwKCkpXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV2b2tlVG9rZW5SZXNwb25zZS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgcGVyZm9ybVRva2VuUmVxdWVzdChjb25maWd1cmF0aW9uOiBBdXRob3JpemF0aW9uU2VydmljZUNvbmZpZ3VyYXRpb24sIHJlcXVlc3Q6IFRva2VuUmVxdWVzdCk6XG4gICAgICBQcm9taXNlPFRva2VuUmVzcG9uc2U+IHtcbiAgICBsZXQgdG9rZW5SZXNwb25zZSA9IHRoaXMucmVxdWVzdG9yLnhocjxUb2tlblJlc3BvbnNlSnNvbnxUb2tlbkVycm9ySnNvbj4oe1xuICAgICAgdXJsOiBjb25maWd1cmF0aW9uLnRva2VuRW5kcG9pbnQsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsICAvLyBhZGRpbmcgaW1wbGljaXQgZGF0YVR5cGVcbiAgICAgIGhlYWRlcnM6IHsnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCd9LFxuICAgICAgZGF0YTogdGhpcy51dGlscy5zdHJpbmdpZnkocmVxdWVzdC50b1N0cmluZ01hcCgpKVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRva2VuUmVzcG9uc2UudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAodGhpcy5pc1Rva2VuUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgIHJldHVybiBuZXcgVG9rZW5SZXNwb25zZShyZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3Q8VG9rZW5SZXNwb25zZT4oXG4gICAgICAgICAgICBuZXcgQXBwQXV0aEVycm9yKHJlc3BvbnNlLmVycm9yLCBuZXcgVG9rZW5FcnJvcihyZXNwb25zZSkpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgYWNjZXNzIHRva2VuIHR5cGVzLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gc2VlOlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi03LjFcbiAqL1xuZXhwb3J0IHR5cGUgVG9rZW5UeXBlID0gJ2JlYXJlcid8J21hYyc7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgVG9rZW5SZXNwb25zZSBhcyBhIEpTT04gT2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuUmVzcG9uc2VKc29uIHtcbiAgYWNjZXNzX3Rva2VuOiBzdHJpbmc7XG4gIHRva2VuX3R5cGU/OiBUb2tlblR5cGU7IC8qIHRyZWF0aW5nIHRva2VuIHR5cGUgYXMgb3B0aW9uYWwsIGFzIGl0cyBnb2luZyB0byBiZSBpbmZlcnJlZC4gKi9cbiAgZXhwaXJlc19pbj86IG51bWJlcjsgICAgLyogbGlmZXRpbWUgaW4gc2Vjb25kcy4gKi9cbiAgcmVmcmVzaF90b2tlbj86IHN0cmluZztcbiAgc2NvcGU/OiBzdHJpbmc7XG4gIGlkX3Rva2VuPzogc3RyaW5nOyAgLyogaHR0cHM6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWNvcmUtMV8wLmh0bWwjVG9rZW5SZXNwb25zZSAqL1xuICBpc3N1ZWRfYXQ/OiBudW1iZXI7IC8qIHdoZW4gd2FzIGl0IGlzc3VlZCA/ICovXG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgcG9zc2libGUgZXJyb3IgY29kZXMgZnJvbSB0aGUgdG9rZW4gZW5kcG9pbnQuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0OlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi01LjJcbiAqL1xuZXhwb3J0IHR5cGUgRXJyb3JUeXBlID0gJ2ludmFsaWRfcmVxdWVzdCd8J2ludmFsaWRfY2xpZW50J3wnaW52YWxpZF9ncmFudCd8J3VuYXV0aG9yaXplZF9jbGllbnQnfFxuICAgICd1bnN1cHBvcnRlZF9ncmFudF90eXBlJ3wnaW52YWxpZF9zY29wZSc7XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgVG9rZW5FcnJvciBhcyBhIEpTT04gT2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRva2VuRXJyb3JKc29uIHtcbiAgZXJyb3I6IEVycm9yVHlwZTtcbiAgZXJyb3JfZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIGVycm9yX3VyaT86IHN0cmluZztcbn1cblxuLy8gY29uc3RhbnRzXG5jb25zdCBBVVRIX0VYUElSWV9CVUZGRVIgPSAxMCAqIDYwICogLTE7ICAvLyAxMCBtaW5zIGluIHNlY29uZHNcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnN0YW50IG9mIHRpbWUgaW4gc2Vjb25kcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vd0luU2Vjb25kcyA9ICgpID0+IE1hdGgucm91bmQobmV3IERhdGUoKS5nZXRUaW1lKCkgLyAxMDAwKTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIHRoZSBUb2tlbiBSZXNwb25zZSB0eXBlLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24gbG9vayBhdDpcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NzQ5I3NlY3Rpb24tNS4xXG4gKi9cbmV4cG9ydCBjbGFzcyBUb2tlblJlc3BvbnNlIHtcbiAgYWNjZXNzVG9rZW46IHN0cmluZztcbiAgdG9rZW5UeXBlOiBUb2tlblR5cGU7XG4gIGV4cGlyZXNJbjogbnVtYmVyfHVuZGVmaW5lZDtcbiAgcmVmcmVzaFRva2VuOiBzdHJpbmd8dW5kZWZpbmVkO1xuICBzY29wZTogc3RyaW5nfHVuZGVmaW5lZDtcbiAgaWRUb2tlbjogc3RyaW5nfHVuZGVmaW5lZDtcbiAgaXNzdWVkQXQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihyZXNwb25zZTogVG9rZW5SZXNwb25zZUpzb24pIHtcbiAgICB0aGlzLmFjY2Vzc1Rva2VuID0gcmVzcG9uc2UuYWNjZXNzX3Rva2VuO1xuICAgIHRoaXMudG9rZW5UeXBlID0gcmVzcG9uc2UudG9rZW5fdHlwZSB8fCAnYmVhcmVyJztcbiAgICB0aGlzLmV4cGlyZXNJbiA9IHJlc3BvbnNlLmV4cGlyZXNfaW47XG4gICAgdGhpcy5yZWZyZXNoVG9rZW4gPSByZXNwb25zZS5yZWZyZXNoX3Rva2VuO1xuICAgIHRoaXMuc2NvcGUgPSByZXNwb25zZS5zY29wZTtcbiAgICB0aGlzLmlkVG9rZW4gPSByZXNwb25zZS5pZF90b2tlbjtcbiAgICB0aGlzLmlzc3VlZEF0ID0gcmVzcG9uc2UuaXNzdWVkX2F0IHx8IG5vd0luU2Vjb25kcygpO1xuICB9XG5cbiAgdG9Kc29uKCk6IFRva2VuUmVzcG9uc2VKc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLmFjY2Vzc1Rva2VuLFxuICAgICAgaWRfdG9rZW46IHRoaXMuaWRUb2tlbixcbiAgICAgIHJlZnJlc2hfdG9rZW46IHRoaXMucmVmcmVzaFRva2VuLFxuICAgICAgc2NvcGU6IHRoaXMuc2NvcGUsXG4gICAgICB0b2tlbl90eXBlOiB0aGlzLnRva2VuVHlwZSxcbiAgICAgIGlzc3VlZF9hdDogdGhpcy5pc3N1ZWRBdCxcbiAgICAgIGV4cGlyZXNfaW46IHRoaXMuZXhwaXJlc0luXG4gICAgfTtcbiAgfVxuXG4gIGlzVmFsaWQoYnVmZmVyOiBudW1iZXIgPSBBVVRIX0VYUElSWV9CVUZGRVIpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5leHBpcmVzSW4pIHtcbiAgICAgIGxldCBub3cgPSBub3dJblNlY29uZHMoKTtcbiAgICAgIHJldHVybiBub3cgPCB0aGlzLmlzc3VlZEF0ICsgdGhpcy5leHBpcmVzSW4gKyBidWZmZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgdGhlIFRva2VuIEVycm9yIHR5cGUuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiBsb29rIGF0OlxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDkjc2VjdGlvbi01LjJcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuRXJyb3Ige1xuICBlcnJvcjogRXJyb3JUeXBlO1xuICBlcnJvckRlc2NyaXB0aW9uOiBzdHJpbmd8dW5kZWZpbmVkO1xuICBlcnJvclVyaTogc3RyaW5nfHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcih0b2tlbkVycm9yOiBUb2tlbkVycm9ySnNvbikge1xuICAgIHRoaXMuZXJyb3IgPSB0b2tlbkVycm9yLmVycm9yO1xuICAgIHRoaXMuZXJyb3JEZXNjcmlwdGlvbiA9IHRva2VuRXJyb3IuZXJyb3JfZGVzY3JpcHRpb247XG4gICAgdGhpcy5lcnJvclVyaSA9IHRva2VuRXJyb3IuZXJyb3JfdXJpO1xuICB9XG5cbiAgdG9Kc29uKCk6IFRva2VuRXJyb3JKc29uIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyb3I6IHRoaXMuZXJyb3IsIGVycm9yX2Rlc2NyaXB0aW9uOiB0aGlzLmVycm9yRGVzY3JpcHRpb24sIGVycm9yX3VyaTogdGhpcy5lcnJvclVyaVxuICAgIH1cbiAgfVxufVxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHRcbiAqIGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGVcbiAqIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyXG4gKiBleHByZXNzIG9yIGltcGxpZWQuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7QXBwQXV0aEVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5cbi8qKlxuICogQW4gY2xhc3MgdGhhdCBhYnN0cmFjdHMgYXdheSB0aGUgYWJpbGl0eSB0byBtYWtlIGFuIFhNTEh0dHBSZXF1ZXN0LlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUmVxdWVzdG9yIHtcbiAgYWJzdHJhY3QgeGhyPFQ+KHNldHRpbmdzOiBKUXVlcnlBamF4U2V0dGluZ3MpOiBQcm9taXNlPFQ+O1xufVxuXG4vKipcbiAqIFVzZXMgJC5hamF4IHRvIG1ha2VzIHRoZSBBamF4IHJlcXVlc3RzLlxuICovXG5leHBvcnQgY2xhc3MgSlF1ZXJ5UmVxdWVzdG9yIGV4dGVuZHMgUmVxdWVzdG9yIHtcbiAgeGhyPFQ+KHNldHRpbmdzOiBKUXVlcnlBamF4U2V0dGluZ3MpOiBQcm9taXNlPFQ+IHtcbiAgICAvLyBOT1RFOiB1c2luZyBqcXVlcnkgdG8gbWFrZSBYSFIncyBhcyB3aGF0d2ctZmV0Y2ggcmVxdWlyZXNcbiAgICAvLyB0aGF0IEkgdGFyZ2V0IEVTNi5cbiAgICBjb25zdCB4aHIgPSAkLmFqYXgoc2V0dGluZ3MpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB4aHIudGhlbihcbiAgICAgICAgICAoZGF0YSwgdGV4dFN0YXR1cywganFYaHIpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YSBhcyBUKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIChqcVhociwgdGV4dFN0YXR1cywgZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQXBwQXV0aEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cblxuXG4vKipcbiAqIFVzZXMgZmV0Y2ggQVBJIHRvIG1ha2UgQWpheCByZXF1ZXN0c1xuICovXG5leHBvcnQgY2xhc3MgRmV0Y2hSZXF1ZXN0b3IgZXh0ZW5kcyBSZXF1ZXN0b3Ige1xuICB4aHI8VD4oc2V0dGluZ3M6IEpRdWVyeUFqYXhTZXR0aW5ncyk6IFByb21pc2U8VD4ge1xuICAgIGlmICghc2V0dGluZ3MudXJsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFwcEF1dGhFcnJvcignQSBVUkwgbXVzdCBiZSBwcm92aWRlZC4nKSk7XG4gICAgfVxuICAgIGxldCB1cmw6IFVSTCA9IG5ldyBVUkwoPHN0cmluZz5zZXR0aW5ncy51cmwpO1xuICAgIGxldCByZXF1ZXN0SW5pdDogUmVxdWVzdEluaXQgPSB7fTtcbiAgICByZXF1ZXN0SW5pdC5tZXRob2QgPSBzZXR0aW5ncy5tZXRob2Q7XG4gICAgcmVxdWVzdEluaXQubW9kZSA9ICdjb3JzJztcblxuICAgIGlmIChzZXR0aW5ncy5kYXRhKSB7XG4gICAgICBpZiAoc2V0dGluZ3MubWV0aG9kICYmIHNldHRpbmdzLm1ldGhvZC50b1VwcGVyQ2FzZSgpID09PSAnUE9TVCcpIHtcbiAgICAgICAgcmVxdWVzdEluaXQuYm9keSA9IDxzdHJpbmc+c2V0dGluZ3MuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHNldHRpbmdzLmRhdGEpO1xuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT7CoHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0ge307XG4gICAgaWYgKHNldHRpbmdzLmhlYWRlcnMpIHtcbiAgICAgIGZvciAobGV0IGkgaW4gc2V0dGluZ3MuaGVhZGVycykge1xuICAgICAgICBpZiAoc2V0dGluZ3MuaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgIHJlcXVlc3RJbml0LmhlYWRlcnNbaV0gPSA8c3RyaW5nPnNldHRpbmdzLmhlYWRlcnNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc0pzb25EYXRhVHlwZSA9IHNldHRpbmdzLmRhdGFUeXBlICYmIHNldHRpbmdzLmRhdGFUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICdqc29uJztcblxuICAgIC8vIFNldCAnQWNjZXB0JyBoZWFkZXIgdmFsdWUgZm9yIGpzb24gcmVxdWVzdHMgKFRha2VuIGZyb21cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iL2UwZDk0MTE1NjkwMGE2YmZmN2MwOThjOGVhNzI5MDUyOGU0NjhjZjgvc3JjL2FqYXguanMjTDY0NFxuICAgIC8vIClcbiAgICBpZiAoaXNKc29uRGF0YVR5cGUpIHtcbiAgICAgIHJlcXVlc3RJbml0LmhlYWRlcnNbJ0FjY2VwdCddID0gJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdCwgKi8qOyBxPTAuMDEnO1xuICAgIH1cblxuICAgIHJldHVybiBmZXRjaCh1cmwudG9TdHJpbmcoKSwgcmVxdWVzdEluaXQpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpO1xuICAgICAgICBpZiAoaXNKc29uRGF0YVR5cGUgfHwgKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSAhPT0gLTEpKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEFwcEF1dGhFcnJvcihyZXNwb25zZS5zdGF0dXMudG9TdHJpbmcoKSwgcmVzcG9uc2Uuc3RhdHVzVGV4dCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiB0ZXN0aW5nLiBKdXN0IHVzZXMgdGhlIHVuZGVybHlpbmdcbiAqIFByb21pc2UgdG8gbW9jayB0aGUgYmVoYXZpb3Igb2YgdGhlIFJlcXVlc3Rvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlc3RSZXF1ZXN0b3IgZXh0ZW5kcyBSZXF1ZXN0b3Ige1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgcHJvbWlzZTogUHJvbWlzZTxhbnk+KSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuICB4aHI8VD4oc2V0dGluZ3M6IEpRdWVyeUFqYXhTZXR0aW5ncyk6IFByb21pc2U8VD4ge1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7ICAvLyB1bnNhZmUgY2FzdFxuICB9XG59XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgfVxuXG4gIEJOLmlzQk4gPSBmdW5jdGlvbiBpc0JOIChudW0pIHtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG51bS5jb25zdHJ1Y3Rvci53b3JkU2l6ZSA9PT0gQk4ud29yZFNpemUgJiYgQXJyYXkuaXNBcnJheShudW0ud29yZHMpO1xuICB9O1xuXG4gIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpID4gMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLm1pbiA9IGZ1bmN0aW9uIG1pbiAobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdC5jbXAocmlnaHQpIDwgMCkgcmV0dXJuIGxlZnQ7XG4gICAgcmV0dXJuIHJpZ2h0O1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdEFycmF5KG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIGJhc2UgPSAxNjtcbiAgICB9XG4gICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG4gICAgbnVtYmVyID0gbnVtYmVyLnRvU3RyaW5nKCkucmVwbGFjZSgvXFxzKy9nLCAnJyk7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcbiAgICAgIHN0YXJ0Kys7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgIH1cblxuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXggKHN0ciwgc3RhcnQsIGVuZCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByIDw8PSA0O1xuXG4gICAgICAvLyAnYScgLSAnZidcbiAgICAgIGlmIChjID49IDQ5ICYmIGMgPD0gNTQpIHtcbiAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cbiAgICAgIC8vICdBJyAtICdGJ1xuICAgICAgfSBlbHNlIGlmIChjID49IDE3ICYmIGMgPD0gMjIpIHtcbiAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciB8PSBjICYgMHhmO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQpIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICAvLyBTY2FuIDI0LWJpdCBjaHVua3MgYW5kIGFkZCB0aGVtIHRvIHRoZSBudW1iZXJcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuICAgICAgdyA9IHBhcnNlSGV4KG51bWJlciwgaSwgaSArIDYpO1xuICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcbiAgICAgIHRoaXMud29yZHNbaiArIDFdIHw9IHcgPj4+ICgyNiAtIG9mZikgJiAweDNmZmZmZjtcbiAgICAgIG9mZiArPSAyNDtcbiAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpICsgNiAhPT0gc3RhcnQpIHtcbiAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG4gICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ogKyAxXSB8PSB3ID4+PiAoMjYgLSBvZmYpICYgMHgzZmZmZmY7XG4gICAgfVxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBlbmQpO1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQ29kZUF0KGkpIC0gNDg7XG5cbiAgICAgIHIgKj0gbXVsO1xuXG4gICAgICAvLyAnYSdcbiAgICAgIGlmIChjID49IDQ5KSB7XG4gICAgICAgIHIgKz0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICByICs9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByICs9IGM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoZGVzdCkge1xuICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVzdC53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgfVxuICAgIGRlc3QubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG4gICAgdGhpcy5jb3B5KHIpO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24gX2V4cGFuZCAoc2l6ZSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IHNpemUpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBSZW1vdmUgbGVhZGluZyBgMGAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH07XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kbihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQnVmZmVyID0gZnVuY3Rpb24gdG9CdWZmZXIgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShCdWZmZXIsIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHZhciBieXRlTGVuZ3RoID0gdGhpcy5ieXRlTGVuZ3RoKCk7XG4gICAgdmFyIHJlcUxlbmd0aCA9IGxlbmd0aCB8fCBNYXRoLm1heCgxLCBieXRlTGVuZ3RoKTtcbiAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG4gICAgYXNzZXJ0KHJlcUxlbmd0aCA+IDAsICdSZXF1ZXN0ZWQgYXJyYXkgbGVuZ3RoIDw9IDAnKTtcblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuICAgIHZhciByZXMgPSBuZXcgQXJyYXlUeXBlKHJlcUxlbmd0aCk7XG5cbiAgICB2YXIgYiwgaTtcbiAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgLy8gQXNzdW1lIGJpZy1lbmRpYW5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcbiAgICAgICAgcS5pdXNocm4oOCk7XG5cbiAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tpXSA9IGI7XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBpIDwgcmVxTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdWFuZChudW0pO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gYW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVhbmQobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVhbmQodGhpcyk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXhvciA9IGZ1bmN0aW9uIGl1eG9yIChudW0pIHtcbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGE7XG4gICAgdmFyIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXSBeIGIud29yZHNbaV07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMgIT09IGEpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuICAgIHZhciByO1xuXG4gICAgLy8gbmVnYXRpdmUgKyBwb3NpdGl2ZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblxuICAgIC8vIHBvc2l0aXZlICsgbmVnYXRpdmVcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aF0gPSBjYXJyeTtcbiAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcbiAgICB9IGVsc2UgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuICAgIHZhciByZXM7XG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gdGhpcy5zdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9IGVsc2UgaWYgKG51bS5uZWdhdGl2ZSA9PT0gMCAmJiB0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkKG51bSk7XG5cbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaWFkZCh0aGlzKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKG51bSkge1xuICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG4gICAgaWYgKG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cbiAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcbiAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZVxuICAgIHZhciBjbXAgPSB0aGlzLmNtcChudW0pO1xuXG4gICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBhID4gYlxuICAgIHZhciBhLCBiO1xuICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIGlmIChjYXJyeSA9PT0gMCAmJiBpIDwgYS5sZW5ndGggJiYgYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG4gICAgaWYgKGEgIT09IHRoaXMpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGZmdG0gPSBuZXcgRkZUTSgpO1xuICAgIHJldHVybiBmZnRtLm11bHAoc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBgdGhpc2AgYnkgYG51bWBcbiAgQk4ucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcy5tdWxUbyhudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgZW1wbG95aW5nIEZGVFxuICBCTi5wcm90b3R5cGUubXVsZiA9IGZ1bmN0aW9uIG11bGYgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIEluLXBsYWNlIE11bHRpcGxpY2F0aW9uXG4gIEJOLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbXVsbiA9IGZ1bmN0aW9uIGltdWxuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tdWxuID0gZnVuY3Rpb24gbXVsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbXVsbihudW0pO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bCh0aGlzLmNsb25lKCkpO1xuICB9O1xuXG4gIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG4gIEJOLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKG51bSkge1xuICAgIHZhciB3ID0gdG9CaXRBcnJheShudW0pO1xuICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXNcbiAgICB2YXIgcmVzID0gdGhpcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuICAgICAgaWYgKHdbaV0gIT09IDApIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuICAgICAgZm9yICh2YXIgcSA9IHJlcy5zcXIoKTsgaSA8IHcubGVuZ3RoOyBpKyssIHEgPSBxLnNxcigpKSB7XG4gICAgICAgIGlmICh3W2ldID09PSAwKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuICAgIHZhciBjYXJyeU1hc2sgPSAoMHgzZmZmZmZmID4+PiAoMjYgLSByKSkgPDwgKDI2IC0gcik7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcbiAgICAgICAgdmFyIGMgPSAoKHRoaXMud29yZHNbaV0gfCAwKSAtIG5ld0NhcnJ5KSA8PCByO1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYyB8IGNhcnJ5O1xuICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhcnJ5KSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocyAhPT0gMCkge1xuICAgICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoICs9IHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXJcbiAgQk4ucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24gbWFza24gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcbiAgfTtcblxuICAvLyBBZGQgcGxhaW4gbnVtYmVyIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cbiAgICAvLyBQb3NzaWJsZSBzaWduIGNoYW5nZVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cbiAgICAvLyBTdWJ0cmFjdGlvbiBvdmVyZmxvd1xuICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuICAgIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuc3RyaXAoKTtcbiAgICB9XG4gICAgYS5zdHJpcCgpO1xuXG4gICAgLy8gRGVub3JtYWxpemVcbiAgICBpZiAobW9kZSAhPT0gJ2RpdicgJiYgc2hpZnQgIT09IDApIHtcbiAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGl2OiBxIHx8IG51bGwsXG4gICAgICBtb2Q6IGFcbiAgICB9O1xuICB9O1xuXG4gIC8vIE5PVEU6IDEpIGBtb2RlYCBjYW4gYmUgc2V0IHRvIGBtb2RgIHRvIHJlcXVlc3QgbW9kIG9ubHksXG4gIC8vICAgICAgIHRvIGBkaXZgIHRvIHJlcXVlc3QgZGl2IG9ubHksIG9yIGJlIGFic2VudCB0b1xuICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG4gIC8vICAgICAgIDIpIGBwb3NpdGl2ZWAgaXMgdHJ1ZSBpZiB1bnNpZ25lZCBtb2QgaXMgcmVxdWVzdGVkXG4gIEJOLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbiBkaXZtb2QgKG51bSwgbW9kZSwgcG9zaXRpdmUpIHtcbiAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cbiAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogbmV3IEJOKDApXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBkaXYsIG1vZCwgcmVzO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlhZGQobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogcmVzLm1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoKHRoaXMubmVnYXRpdmUgJiBudW0ubmVnYXRpdmUpICE9PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0ubmVnKCksIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiByZXMuZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCb3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlIGF0IHRoaXMgcG9pbnRcblxuICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuICAgIGlmIChudW0ubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAobnVtKSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IHRoaXNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gVmVyeSBzaG9ydCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgICBtb2Q6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGl2OiBudWxsLFxuICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgcjIgPT09IDEgJiYgY21wID09PSAwKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSAtbnVtO1xuICAgICAgfVxuXG4gICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1swXSB8IDA7XG4gICAgICByZXMgPSB3ID09PSBudW0gPyAwIDogdyA8IG51bSA/IC0xIDogMTtcbiAgICB9XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIENvbXBhcmUgdHdvIG51bWJlcnMgYW5kIHJldHVybjpcbiAgLy8gMSAtIGlmIGB0aGlzYCA+IGBudW1gXG4gIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcbiAgLy8gLTEgLSBpZiBgdGhpc2AgPCBgbnVtYFxuICBCTi5wcm90b3R5cGUuY21wID0gZnVuY3Rpb24gY21wIChudW0pIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHJldHVybiAxO1xuXG4gICAgdmFyIHJlcyA9IHRoaXMudWNtcChudW0pO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG4gIEJOLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24gdWNtcCAobnVtKSB7XG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgaGF2ZSB0aGUgc2FtZSBzaWduXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgaWYgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkgcmV0dXJuIC0xO1xuXG4gICAgdmFyIHJlcyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBhID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB2YXIgYiA9IG51bS53b3Jkc1tpXSB8IDA7XG5cbiAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcbiAgICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXMgPSAtMTtcbiAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICAgICAgcmVzID0gMTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndG4gPSBmdW5jdGlvbiBndG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbiBndGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlID0gZnVuY3Rpb24gZ3RlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbiBsdG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ID0gZnVuY3Rpb24gbHQgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlbiA9IGZ1bmN0aW9uIGx0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiBsdGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxbiA9IGZ1bmN0aW9uIGVxbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIGVxIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMDtcbiAgfTtcblxuICAvL1xuICAvLyBBIHJlZHVjZSBjb250ZXh0LCBjb3VsZCBiZSB1c2luZyBtb250Z29tZXJ5IG9yIHNvbWV0aGluZyBiZXR0ZXIsIGRlcGVuZGluZ1xuICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cbiAgLy9cbiAgQk4ucmVkID0gZnVuY3Rpb24gcmVkIChudW0pIHtcbiAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uIHRvUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICByZXR1cm4gY3R4LmNvbnZlcnRUbyh0aGlzKS5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uIGZyb21SZWQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ2Zyb21SZWQgd29ya3Mgb25seSB3aXRoIG51bWJlcnMgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uIF9mb3JjZVJlZCAoY3R4KSB7XG4gICAgdGhpcy5yZWQgPSBjdHg7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEFkZCA9IGZ1bmN0aW9uIHJlZEFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSUFkZCA9IGZ1bmN0aW9uIHJlZElBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlhZGQodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24gcmVkSVN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTaGwgPSBmdW5jdGlvbiByZWRTaGwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc2hsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJTXVsID0gZnVuY3Rpb24gcmVkSU11bCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkyKHRoaXMsIG51bSk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmltdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU3FyID0gZnVuY3Rpb24gcmVkU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTcXIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG4gIH07XG5cbiAgLy8gU3F1YXJlIHJvb3Qgb3ZlciBwXG4gIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FydCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSW52bSA9IGZ1bmN0aW9uIHJlZEludm0gKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmludm0odGhpcyk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYCAlIGByZWQgbW9kdWxvYFxuICBCTi5wcm90b3R5cGUucmVkTmVnID0gZnVuY3Rpb24gcmVkTmVnICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLm5lZyh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24gcmVkUG93IChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQgJiYgIW51bS5yZWQsICdyZWRQb3cobm9ybWFsTnVtKScpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5wb3codGhpcywgbnVtKTtcbiAgfTtcblxuICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuICB2YXIgcHJpbWVzID0ge1xuICAgIGsyNTY6IG51bGwsXG4gICAgcDIyNDogbnVsbCxcbiAgICBwMTkyOiBudWxsLFxuICAgIHAyNTUxOTogbnVsbFxuICB9O1xuXG4gIC8vIFBzZXVkby1NZXJzZW5uZSBwcmltZVxuICBmdW5jdGlvbiBNUHJpbWUgKG5hbWUsIHApIHtcbiAgICAvLyBQID0gMiBeIE4gLSBLXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnAgPSBuZXcgQk4ocCwgMTYpO1xuICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcbiAgICB0aGlzLmsgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApO1xuXG4gICAgdGhpcy50bXAgPSB0aGlzLl90bXAoKTtcbiAgfVxuXG4gIE1QcmltZS5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uIF90bXAgKCkge1xuICAgIHZhciB0bXAgPSBuZXcgQk4obnVsbCk7XG4gICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuICAgIHJldHVybiB0bXA7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG4gICAgLy8gQXNzdW1lcyB0aGF0IGBudW1gIGlzIGxlc3MgdGhhbiBgUF4yYFxuICAgIC8vIG51bSA9IEhJICogKDIgXiBOIC0gSykgKyBISSAqIEsgKyBMTyA9IEhJICogSyArIExPIChtb2QgUClcbiAgICB2YXIgciA9IG51bTtcbiAgICB2YXIgcmxlbjtcblxuICAgIGRvIHtcbiAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuICAgICAgciA9IHRoaXMuaW11bEsocik7XG4gICAgICByID0gci5pYWRkKHRoaXMudG1wKTtcbiAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuICAgIH0gd2hpbGUgKHJsZW4gPiB0aGlzLm4pO1xuXG4gICAgdmFyIGNtcCA9IHJsZW4gPCB0aGlzLm4gPyAtMSA6IHIudWNtcCh0aGlzLnApO1xuICAgIGlmIChjbXAgPT09IDApIHtcbiAgICAgIHIud29yZHNbMF0gPSAwO1xuICAgICAgci5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuICAgICAgci5pc3ViKHRoaXMucCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIuc3RyaXAoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgICByZXR1cm4gYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiBhLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubS5zdWIoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaWFkZChiKTtcbiAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuaXN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc2hsID0gZnVuY3Rpb24gc2hsIChhLCBudW0pIHtcbiAgICB0aGlzLl92ZXJpZnkxKGEpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS51c2hsbihudW0pKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEuaW11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKGEpIHtcbiAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIG1vZDMgPSB0aGlzLm0uYW5kbG4oMyk7XG4gICAgYXNzZXJ0KG1vZDMgJSAyID09PSAxKTtcblxuICAgIC8vIEZhc3QgY2FzZVxuICAgIGlmIChtb2QzID09PSAzKSB7XG4gICAgICB2YXIgcG93ID0gdGhpcy5tLmFkZChuZXcgQk4oMSkpLml1c2hybigyKTtcbiAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuICAgIH1cblxuICAgIC8vIFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobSAoVG90YWxseSB1bm9wdGltaXplZCBhbmQgc2xvdylcbiAgICAvL1xuICAgIC8vIEZpbmQgUSBhbmQgUywgdGhhdCBRICogMiBeIFMgPSAoUCAtIDEpXG4gICAgdmFyIHEgPSB0aGlzLm0uc3VibigxKTtcbiAgICB2YXIgcyA9IDA7XG4gICAgd2hpbGUgKCFxLmlzWmVybygpICYmIHEuYW5kbG4oMSkgPT09IDApIHtcbiAgICAgIHMrKztcbiAgICAgIHEuaXVzaHJuKDEpO1xuICAgIH1cbiAgICBhc3NlcnQoIXEuaXNaZXJvKCkpO1xuXG4gICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB2YXIgbk9uZSA9IG9uZS5yZWROZWcoKTtcblxuICAgIC8vIEZpbmQgcXVhZHJhdGljIG5vbi1yZXNpZHVlXG4gICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG4gICAgdmFyIGxwb3cgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSk7XG4gICAgdmFyIHogPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG4gICAgd2hpbGUgKHRoaXMucG93KHosIGxwb3cpLmNtcChuT25lKSAhPT0gMCkge1xuICAgICAgei5yZWRJQWRkKG5PbmUpO1xuICAgIH1cblxuICAgIHZhciBjID0gdGhpcy5wb3coeiwgcSk7XG4gICAgdmFyIHIgPSB0aGlzLnBvdyhhLCBxLmFkZG4oMSkuaXVzaHJuKDEpKTtcbiAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuICAgIHZhciBtID0gcztcbiAgICB3aGlsZSAodC5jbXAob25lKSAhPT0gMCkge1xuICAgICAgdmFyIHRtcCA9IHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgdG1wLmNtcChvbmUpICE9PSAwOyBpKyspIHtcbiAgICAgICAgdG1wID0gdG1wLnJlZFNxcigpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGkgPCBtKTtcbiAgICAgIHZhciBiID0gdGhpcy5wb3coYywgbmV3IEJOKDEpLml1c2hsbihtIC0gaSAtIDEpKTtcblxuICAgICAgciA9IHIucmVkTXVsKGIpO1xuICAgICAgYyA9IGIucmVkU3FyKCk7XG4gICAgICB0ID0gdC5yZWRNdWwoYyk7XG4gICAgICBtID0gaTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgdmFyIGludiA9IGEuX2ludm1wKHRoaXMubSk7XG4gICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaW52Lm5lZ2F0aXZlID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KS5yZWROZWcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpO1xuICAgIH1cbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAoYSwgbnVtKSB7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgd2luZG93U2l6ZSA9IDQ7XG4gICAgdmFyIHduZCA9IG5ldyBBcnJheSgxIDw8IHdpbmRvd1NpemUpO1xuICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcbiAgICB3bmRbMV0gPSBhO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgd25kLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gd25kWzBdO1xuICAgIHZhciBjdXJyZW50ID0gMDtcbiAgICB2YXIgY3VycmVudExlbiA9IDA7XG4gICAgdmFyIHN0YXJ0ID0gbnVtLmJpdExlbmd0aCgpICUgMjY7XG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSBudW0ud29yZHNbaV07XG4gICAgICBmb3IgKHZhciBqID0gc3RhcnQgLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuICAgICAgICBpZiAocmVzICE9PSB3bmRbMF0pIHtcbiAgICAgICAgICByZXMgPSB0aGlzLnNxcihyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJpdCA9PT0gMCAmJiBjdXJyZW50ID09PSAwKSB7XG4gICAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyZW50IDw8PSAxO1xuICAgICAgICBjdXJyZW50IHw9IGJpdDtcbiAgICAgICAgY3VycmVudExlbisrO1xuICAgICAgICBpZiAoY3VycmVudExlbiAhPT0gd2luZG93U2l6ZSAmJiAoaSAhPT0gMCB8fCBqICE9PSAwKSkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgY3VycmVudCA9IDA7XG4gICAgICB9XG4gICAgICBzdGFydCA9IDI2O1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuICAgIHJldHVybiByID09PSBudW0gPyByLmNsb25lKCkgOiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHJlcyA9IG51bS5jbG9uZSgpO1xuICAgIHJlcy5yZWQgPSBudWxsO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy9cbiAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG4gIC8vXG5cbiAgQk4ubW9udCA9IGZ1bmN0aW9uIG1vbnQgKG51bSkge1xuICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIE1vbnQgKG0pIHtcbiAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuICAgIHRoaXMuc2hpZnQgPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgaWYgKHRoaXMuc2hpZnQgJSAyNiAhPT0gMCkge1xuICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuICAgIH1cblxuICAgIHRoaXMuciA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5zaGlmdCk7XG4gICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuICAgIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKTtcblxuICAgIHRoaXMubWludiA9IHRoaXMucmludi5tdWwodGhpcy5yKS5pc3VibigxKS5kaXYodGhpcy5tKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuICAgIHRoaXMubWludiA9IHRoaXMuci5zdWIodGhpcy5taW52KTtcbiAgfVxuICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChudW0udXNobG4odGhpcy5zaGlmdCkpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByID0gdGhpcy5pbW9kKG51bS5tdWwodGhpcy5yaW52KSk7XG4gICAgci5yZWQgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkge1xuICAgICAgYS53b3Jkc1swXSA9IDA7XG4gICAgICBhLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICB2YXIgdCA9IGEuaW11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcblxuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICB2YXIgdCA9IGEubXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuICAgIGlmICh1LmNtcCh0aGlzLm0pID49IDApIHtcbiAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzID0gdS5pYWRkKHRoaXMubSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICAvLyAoQVIpXi0xICogUl4yID0gKEFeLTEgKiBSXi0xKSAqIFJeMiA9IEFeLTEgKiBSXG4gICAgdmFyIHJlcyA9IHRoaXMuaW1vZChhLl9pbnZtcCh0aGlzLm0pLm11bCh0aGlzLnIyKSk7XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG59KSh0eXBlb2YgbW9kdWxlID09PSAndW5kZWZpbmVkJyB8fCBtb2R1bGUsIHRoaXMpO1xuIiwiIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IG9iamVjdENyZWF0ZVBvbHlmaWxsXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IG9iamVjdEtleXNQb2x5ZmlsbFxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBmdW5jdGlvbkJpbmRQb2x5ZmlsbFxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcywgJ19ldmVudHMnKSkge1xuICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG52YXIgaGFzRGVmaW5lUHJvcGVydHk7XG50cnkge1xuICB2YXIgbyA9IHt9O1xuICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgJ3gnLCB7IHZhbHVlOiAwIH0pO1xuICBoYXNEZWZpbmVQcm9wZXJ0eSA9IG8ueCA9PT0gMDtcbn0gY2F0Y2ggKGVycikgeyBoYXNEZWZpbmVQcm9wZXJ0eSA9IGZhbHNlIH1cbmlmIChoYXNEZWZpbmVQcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBpbnB1dCBpcyBhIHBvc2l0aXZlIG51bWJlciAod2hvc2UgdmFsdWUgaXMgemVybyBvclxuICAgICAgLy8gZ3JlYXRlciBhbmQgbm90IGEgTmFOKS5cbiAgICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IGFyZyAhPT0gYXJnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG59XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJuXCIgYXJndW1lbnQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uICRnZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuICRnZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG4vLyBUaGVzZSBzdGFuZGFsb25lIGVtaXQqIGZ1bmN0aW9ucyBhcmUgdXNlZCB0byBvcHRpbWl6ZSBjYWxsaW5nIG9mIGV2ZW50XG4vLyBoYW5kbGVycyBmb3IgZmFzdCBjYXNlcyBiZWNhdXNlIGVtaXQoKSBpdHNlbGYgb2Z0ZW4gaGFzIGEgdmFyaWFibGUgbnVtYmVyIG9mXG4vLyBhcmd1bWVudHMgYW5kIGNhbiBiZSBkZW9wdGltaXplZCBiZWNhdXNlIG9mIHRoYXQuIFRoZXNlIGZ1bmN0aW9ucyBhbHdheXMgaGF2ZVxuLy8gdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyBhbmQgdGh1cyBkbyBub3QgZ2V0IGRlb3B0aW1pemVkLCBzbyB0aGUgY29kZVxuLy8gaW5zaWRlIHRoZW0gY2FuIGV4ZWN1dGUgZmFzdGVyLlxuZnVuY3Rpb24gZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgc2VsZikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCBzZWxmLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZ3MpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5hcHBseShzZWxmLCBhcmdzKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGV2ZW50cztcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT0gbnVsbCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKCFoYW5kbGVyKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgaXNGbiA9IHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nO1xuICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICBzd2l0Y2ggKGxlbikge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgIGNhc2UgMTpcbiAgICAgIGVtaXROb25lKGhhbmRsZXIsIGlzRm4sIHRoaXMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgZW1pdE9uZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAzOlxuICAgICAgZW1pdFR3byhoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICBlbWl0VGhyZWUoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG4gICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgIGRlZmF1bHQ6XG4gICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGVtaXRNYW55KGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoIWV2ZW50cykge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKCFleGlzdGluZykge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgICBpZiAocHJlcGVuZCkge1xuICAgICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgaWYgKCFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIG0gPSAkZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgICBpZiAobSAmJiBtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtKSB7XG4gICAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyBcIicgKyBTdHJpbmcodHlwZSkgKyAnXCIgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdC4nKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLndhcm4pIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJyVzOiAlcycsIHcubmFtZSwgdy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdKTtcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCwgYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgICAgY2FzZSAzOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSxcbiAgICAgICAgICAgIGFyZ3VtZW50c1syXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBiaW5kLmNhbGwob25jZVdyYXBwZXIsIHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3QpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoIWV2ZW50cylcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmICghZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0pIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IG9iamVjdENyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gb2JqZWN0S2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmICghZXZlbnRzKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKCFldmxpc3RlbmVyKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3Qub3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG4vLyBBYm91dCAxLjV4IGZhc3RlciB0aGFuIHRoZSB0d28tYXJnIHZlcnNpb24gb2YgQXJyYXkjc3BsaWNlKCkuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IGluZGV4LCBrID0gaSArIDEsIG4gPSBsaXN0Lmxlbmd0aDsgayA8IG47IGkgKz0gMSwgayArPSAxKVxuICAgIGxpc3RbaV0gPSBsaXN0W2tdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9iamVjdENyZWF0ZVBvbHlmaWxsKHByb3RvKSB7XG4gIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcbiAgRi5wcm90b3R5cGUgPSBwcm90bztcbiAgcmV0dXJuIG5ldyBGO1xufVxuZnVuY3Rpb24gb2JqZWN0S2V5c1BvbHlmaWxsKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrIGluIG9iaikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGspKSB7XG4gICAga2V5cy5wdXNoKGspO1xuICB9XG4gIHJldHVybiBrO1xufVxuZnVuY3Rpb24gZnVuY3Rpb25CaW5kUG9seWZpbGwoY29udGV4dCkge1xuICB2YXIgZm4gPSB0aGlzO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICB9O1xufVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiIsInZhciBjbG9uZSA9IChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luc3RhbmNlb2Yob2JqLCB0eXBlKSB7XG4gIHJldHVybiB0eXBlICE9IG51bGwgJiYgb2JqIGluc3RhbmNlb2YgdHlwZTtcbn1cblxudmFyIG5hdGl2ZU1hcDtcbnRyeSB7XG4gIG5hdGl2ZU1hcCA9IE1hcDtcbn0gY2F0Y2goXykge1xuICAvLyBtYXliZSBhIHJlZmVyZW5jZSBlcnJvciBiZWNhdXNlIG5vIGBNYXBgLiBHaXZlIGl0IGEgZHVtbXkgdmFsdWUgdGhhdCBub1xuICAvLyB2YWx1ZSB3aWxsIGV2ZXIgYmUgYW4gaW5zdGFuY2VvZi5cbiAgbmF0aXZlTWFwID0gZnVuY3Rpb24oKSB7fTtcbn1cblxudmFyIG5hdGl2ZVNldDtcbnRyeSB7XG4gIG5hdGl2ZVNldCA9IFNldDtcbn0gY2F0Y2goXykge1xuICBuYXRpdmVTZXQgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlUHJvbWlzZTtcbnRyeSB7XG4gIG5hdGl2ZVByb21pc2UgPSBQcm9taXNlO1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVByb21pc2UgPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vKipcbiAqIENsb25lcyAoY29waWVzKSBhbiBPYmplY3QgdXNpbmcgZGVlcCBjb3B5aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gc3VwcG9ydHMgY2lyY3VsYXIgcmVmZXJlbmNlcyBieSBkZWZhdWx0LCBidXQgaWYgeW91IGFyZSBjZXJ0YWluXG4gKiB0aGVyZSBhcmUgbm8gY2lyY3VsYXIgcmVmZXJlbmNlcyBpbiB5b3VyIG9iamVjdCwgeW91IGNhbiBzYXZlIHNvbWUgQ1BVIHRpbWVcbiAqIGJ5IGNhbGxpbmcgY2xvbmUob2JqLCBmYWxzZSkuXG4gKlxuICogQ2F1dGlvbjogaWYgYGNpcmN1bGFyYCBpcyBmYWxzZSBhbmQgYHBhcmVudGAgY29udGFpbnMgY2lyY3VsYXIgcmVmZXJlbmNlcyxcbiAqIHlvdXIgcHJvZ3JhbSBtYXkgZW50ZXIgYW4gaW5maW5pdGUgbG9vcCBhbmQgY3Jhc2guXG4gKlxuICogQHBhcmFtIGBwYXJlbnRgIC0gdGhlIG9iamVjdCB0byBiZSBjbG9uZWRcbiAqIEBwYXJhbSBgY2lyY3VsYXJgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG9iamVjdCB0byBiZSBjbG9uZWQgbWF5IGNvbnRhaW5cbiAqICAgIGNpcmN1bGFyIHJlZmVyZW5jZXMuIChvcHRpb25hbCAtIHRydWUgYnkgZGVmYXVsdClcbiAqIEBwYXJhbSBgZGVwdGhgIC0gc2V0IHRvIGEgbnVtYmVyIGlmIHRoZSBvYmplY3QgaXMgb25seSB0byBiZSBjbG9uZWQgdG9cbiAqICAgIGEgcGFydGljdWxhciBkZXB0aC4gKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gSW5maW5pdHkpXG4gKiBAcGFyYW0gYHByb3RvdHlwZWAgLSBzZXRzIHRoZSBwcm90b3R5cGUgdG8gYmUgdXNlZCB3aGVuIGNsb25pbmcgYW4gb2JqZWN0LlxuICogICAgKG9wdGlvbmFsIC0gZGVmYXVsdHMgdG8gcGFyZW50IHByb3RvdHlwZSkuXG4gKiBAcGFyYW0gYGluY2x1ZGVOb25FbnVtZXJhYmxlYCAtIHNldCB0byB0cnVlIGlmIHRoZSBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzXG4gKiAgICBzaG91bGQgYmUgY2xvbmVkIGFzIHdlbGwuIE5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgb24gdGhlIHByb3RvdHlwZVxuICogICAgY2hhaW4gd2lsbCBiZSBpZ25vcmVkLiAob3B0aW9uYWwgLSBmYWxzZSBieSBkZWZhdWx0KVxuKi9cbmZ1bmN0aW9uIGNsb25lKHBhcmVudCwgY2lyY3VsYXIsIGRlcHRoLCBwcm90b3R5cGUsIGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT09ICdvYmplY3QnKSB7XG4gICAgZGVwdGggPSBjaXJjdWxhci5kZXB0aDtcbiAgICBwcm90b3R5cGUgPSBjaXJjdWxhci5wcm90b3R5cGU7XG4gICAgaW5jbHVkZU5vbkVudW1lcmFibGUgPSBjaXJjdWxhci5pbmNsdWRlTm9uRW51bWVyYWJsZTtcbiAgICBjaXJjdWxhciA9IGNpcmN1bGFyLmNpcmN1bGFyO1xuICB9XG4gIC8vIG1haW50YWluIHR3byBhcnJheXMgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMsIHdoZXJlIGNvcnJlc3BvbmRpbmcgcGFyZW50c1xuICAvLyBhbmQgY2hpbGRyZW4gaGF2ZSB0aGUgc2FtZSBpbmRleFxuICB2YXIgYWxsUGFyZW50cyA9IFtdO1xuICB2YXIgYWxsQ2hpbGRyZW4gPSBbXTtcblxuICB2YXIgdXNlQnVmZmVyID0gdHlwZW9mIEJ1ZmZlciAhPSAndW5kZWZpbmVkJztcblxuICBpZiAodHlwZW9mIGNpcmN1bGFyID09ICd1bmRlZmluZWQnKVxuICAgIGNpcmN1bGFyID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGRlcHRoID09ICd1bmRlZmluZWQnKVxuICAgIGRlcHRoID0gSW5maW5pdHk7XG5cbiAgLy8gcmVjdXJzZSB0aGlzIGZ1bmN0aW9uIHNvIHdlIGRvbid0IHJlc2V0IGFsbFBhcmVudHMgYW5kIGFsbENoaWxkcmVuXG4gIGZ1bmN0aW9uIF9jbG9uZShwYXJlbnQsIGRlcHRoKSB7XG4gICAgLy8gY2xvbmluZyBudWxsIGFsd2F5cyByZXR1cm5zIG51bGxcbiAgICBpZiAocGFyZW50ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoZGVwdGggPT09IDApXG4gICAgICByZXR1cm4gcGFyZW50O1xuXG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBwcm90bztcbiAgICBpZiAodHlwZW9mIHBhcmVudCAhPSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVNYXAoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgY2hpbGQgPSBuZXcgbmF0aXZlU2V0KCk7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVByb21pc2UpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGFyZW50LnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXNvbHZlKF9jbG9uZSh2YWx1ZSwgZGVwdGggLSAxKSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIHJlamVjdChfY2xvbmUoZXJyLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNsb25lLl9faXNBcnJheShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IFtdO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc1JlZ0V4cChwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBSZWdFeHAocGFyZW50LnNvdXJjZSwgX19nZXRSZWdFeHBGbGFncyhwYXJlbnQpKTtcbiAgICAgIGlmIChwYXJlbnQubGFzdEluZGV4KSBjaGlsZC5sYXN0SW5kZXggPSBwYXJlbnQubGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0RhdGUocGFyZW50KSkge1xuICAgICAgY2hpbGQgPSBuZXcgRGF0ZShwYXJlbnQuZ2V0VGltZSgpKTtcbiAgICB9IGVsc2UgaWYgKHVzZUJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIocGFyZW50KSkge1xuICAgICAgaWYgKEJ1ZmZlci5hbGxvY1Vuc2FmZSkge1xuICAgICAgICAvLyBOb2RlLmpzID49IDQuNS4wXG4gICAgICAgIGNoaWxkID0gQnVmZmVyLmFsbG9jVW5zYWZlKHBhcmVudC5sZW5ndGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT2xkZXIgTm9kZS5qcyB2ZXJzaW9uc1xuICAgICAgICBjaGlsZCA9IG5ldyBCdWZmZXIocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQuY29weShjaGlsZCk7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfSBlbHNlIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIEVycm9yKSkge1xuICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG90eXBlID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHBhcmVudCk7XG4gICAgICAgIGNoaWxkID0gT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICAgIHByb3RvID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgdmFyIGluZGV4ID0gYWxsUGFyZW50cy5pbmRleE9mKHBhcmVudCk7XG5cbiAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICByZXR1cm4gYWxsQ2hpbGRyZW5baW5kZXhdO1xuICAgICAgfVxuICAgICAgYWxsUGFyZW50cy5wdXNoKHBhcmVudCk7XG4gICAgICBhbGxDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVNYXApKSB7XG4gICAgICBwYXJlbnQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHZhciBrZXlDaGlsZCA9IF9jbG9uZShrZXksIGRlcHRoIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5zZXQoa2V5Q2hpbGQsIHZhbHVlQ2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZVNldCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBlbnRyeUNoaWxkID0gX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpO1xuICAgICAgICBjaGlsZC5hZGQoZW50cnlDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHBhcmVudCkge1xuICAgICAgdmFyIGF0dHJzO1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIGF0dHJzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgaSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhdHRycyAmJiBhdHRycy5zZXQgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNoaWxkW2ldID0gX2Nsb25lKHBhcmVudFtpXSwgZGVwdGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRG9uJ3QgbmVlZCB0byB3b3JyeSBhYm91dCBjbG9uaW5nIGEgc3ltYm9sIGJlY2F1c2UgaXQgaXMgYSBwcmltaXRpdmUsXG4gICAgICAgIC8vIGxpa2UgYSBudW1iZXIgb3Igc3RyaW5nLlxuICAgICAgICB2YXIgc3ltYm9sID0gc3ltYm9sc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgc3ltYm9sKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3IuZW51bWVyYWJsZSAmJiAhaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZFtzeW1ib2xdID0gX2Nsb25lKHBhcmVudFtzeW1ib2xdLCBkZXB0aCAtIDEpO1xuICAgICAgICBpZiAoIWRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgc3ltYm9sLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluY2x1ZGVOb25FbnVtZXJhYmxlKSB7XG4gICAgICB2YXIgYWxsUHJvcGVydHlOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHBhcmVudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbFByb3BlcnR5TmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3BlcnR5TmFtZSA9IGFsbFByb3BlcnR5TmFtZXNbaV07XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwYXJlbnQsIHByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3Byb3BlcnR5TmFtZV0gPSBfY2xvbmUocGFyZW50W3Byb3BlcnR5TmFtZV0sIGRlcHRoIC0gMSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaGlsZCwgcHJvcGVydHlOYW1lLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIF9jbG9uZShwYXJlbnQsIGRlcHRoKTtcbn1cblxuLyoqXG4gKiBTaW1wbGUgZmxhdCBjbG9uZSB1c2luZyBwcm90b3R5cGUsIGFjY2VwdHMgb25seSBvYmplY3RzLCB1c2VmdWxsIGZvciBwcm9wZXJ0eVxuICogb3ZlcnJpZGUgb24gRkxBVCBjb25maWd1cmF0aW9uIG9iamVjdCAobm8gbmVzdGVkIHByb3BzKS5cbiAqXG4gKiBVU0UgV0lUSCBDQVVUSU9OISBUaGlzIG1heSBub3QgYmVoYXZlIGFzIHlvdSB3aXNoIGlmIHlvdSBkbyBub3Qga25vdyBob3cgdGhpc1xuICogd29ya3MuXG4gKi9cbmNsb25lLmNsb25lUHJvdG90eXBlID0gZnVuY3Rpb24gY2xvbmVQcm90b3R5cGUocGFyZW50KSB7XG4gIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgYy5wcm90b3R5cGUgPSBwYXJlbnQ7XG4gIHJldHVybiBuZXcgYygpO1xufTtcblxuLy8gcHJpdmF0ZSB1dGlsaXR5IGZ1bmN0aW9uc1xuXG5mdW5jdGlvbiBfX29ialRvU3RyKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbmNsb25lLl9fb2JqVG9TdHIgPSBfX29ialRvU3RyO1xuXG5mdW5jdGlvbiBfX2lzRGF0ZShvKSB7XG4gIHJldHVybiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgX19vYmpUb1N0cihvKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuY2xvbmUuX19pc0RhdGUgPSBfX2lzRGF0ZTtcblxuZnVuY3Rpb24gX19pc0FycmF5KG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuY2xvbmUuX19pc0FycmF5ID0gX19pc0FycmF5O1xuXG5mdW5jdGlvbiBfX2lzUmVnRXhwKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmNsb25lLl9faXNSZWdFeHAgPSBfX2lzUmVnRXhwO1xuXG5mdW5jdGlvbiBfX2dldFJlZ0V4cEZsYWdzKHJlKSB7XG4gIHZhciBmbGFncyA9ICcnO1xuICBpZiAocmUuZ2xvYmFsKSBmbGFncyArPSAnZyc7XG4gIGlmIChyZS5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZS5tdWx0aWxpbmUpIGZsYWdzICs9ICdtJztcbiAgcmV0dXJuIGZsYWdzO1xufVxuY2xvbmUuX19nZXRSZWdFeHBGbGFncyA9IF9fZ2V0UmVnRXhwRmxhZ3M7XG5cbnJldHVybiBjbG9uZTtcbn0pKCk7XG5cbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xufVxuIiwidmFyIF9fcm9vdF9fID0gKGZ1bmN0aW9uIChyb290KSB7XG5mdW5jdGlvbiBGKCkgeyB0aGlzLmZldGNoID0gZmFsc2U7IH1cbkYucHJvdG90eXBlID0gcm9vdDtcbnJldHVybiBuZXcgRigpO1xufSkodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHRoaXMpO1xuKGZ1bmN0aW9uKHNlbGYpIHtcblxuKGZ1bmN0aW9uKHNlbGYpIHtcblxuICBpZiAoc2VsZi5mZXRjaCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBzZWxmLFxuICAgIGl0ZXJhYmxlOiAnU3ltYm9sJyBpbiBzZWxmICYmICdpdGVyYXRvcicgaW4gU3ltYm9sLFxuICAgIGJsb2I6ICdGaWxlUmVhZGVyJyBpbiBzZWxmICYmICdCbG9iJyBpbiBzZWxmICYmIChmdW5jdGlvbigpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfSkoKSxcbiAgICBmb3JtRGF0YTogJ0Zvcm1EYXRhJyBpbiBzZWxmLFxuICAgIGFycmF5QnVmZmVyOiAnQXJyYXlCdWZmZXInIGluIHNlbGZcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlcikge1xuICAgIHZhciB2aWV3Q2xhc3NlcyA9IFtcbiAgICAgICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgICAnW29iamVjdCBGbG9hdDY0QXJyYXldJ1xuICAgIF07XG5cbiAgICB2YXIgaXNEYXRhVmlldyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiBEYXRhVmlldy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihvYmopXG4gICAgfTtcblxuICAgIHZhciBpc0FycmF5QnVmZmVyVmlldyA9IEFycmF5QnVmZmVyLmlzVmlldyB8fCBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBub3JtYWxpemVOYW1lKG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgIH1cbiAgICBpZiAoL1teYS16MC05XFwtIyQlJicqKy5cXF5fYHx+XS9pLnRlc3QobmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyIGluIGhlYWRlciBmaWVsZCBuYW1lJylcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8vIEJ1aWxkIGEgZGVzdHJ1Y3RpdmUgaXRlcmF0b3IgZm9yIHRoZSB2YWx1ZSBsaXN0XG4gIGZ1bmN0aW9uIGl0ZXJhdG9yRm9yKGl0ZW1zKSB7XG4gICAgdmFyIGl0ZXJhdG9yID0ge1xuICAgICAgbmV4dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiB7ZG9uZTogdmFsdWUgPT09IHVuZGVmaW5lZCwgdmFsdWU6IHZhbHVlfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgICAgaXRlcmF0b3JbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGl0ZXJhdG9yXG4gIH1cblxuICBmdW5jdGlvbiBIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgaWYgKGhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5hcHBlbmQobmFtZSwgdmFsdWUpO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcnMpKSB7XG4gICAgICBoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKGhlYWRlclswXSwgaGVhZGVyWzFdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycykge1xuICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIGhlYWRlcnNbbmFtZV0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICBuYW1lID0gbm9ybWFsaXplTmFtZShuYW1lKTtcbiAgICB2YWx1ZSA9IG5vcm1hbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLm1hcFtuYW1lXTtcbiAgICB0aGlzLm1hcFtuYW1lXSA9IG9sZFZhbHVlID8gb2xkVmFsdWUrJywnK3ZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2gobmFtZSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHsgaXRlbXMucHVzaCh2YWx1ZSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7IGl0ZW1zLnB1c2goW25hbWUsIHZhbHVlXSk7IH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgdGhpcy5fYm9keUluaXQgPSBib2R5O1xuICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYmxvYiAmJiBCbG9iLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlCbG9iID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5mb3JtRGF0YSAmJiBGb3JtRGF0YS5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5Rm9ybURhdGEgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSBib2R5LnRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIgJiYgc3VwcG9ydC5ibG9iICYmIGlzRGF0YVZpZXcoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keS5idWZmZXIpO1xuICAgICAgICAvLyBJRSAxMC0xMSBjYW4ndCBoYW5kbGUgYSBEYXRhVmlldyBib2R5LlxuICAgICAgICB0aGlzLl9ib2R5SW5pdCA9IG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiAoQXJyYXlCdWZmZXIucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkgfHwgaXNBcnJheUJ1ZmZlclZpZXcoYm9keSkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlBcnJheUJ1ZmZlciA9IGJ1ZmZlckNsb25lKGJvZHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnN1cHBvcnRlZCBCb2R5SW5pdCB0eXBlJylcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlCbG9iICYmIHRoaXMuX2JvZHlCbG9iLnR5cGUpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCB0aGlzLl9ib2R5QmxvYi50eXBlKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LnNlYXJjaFBhcmFtcyAmJiBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgICB0aGlzLmhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICB0aGlzLmJsb2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgIGlmIChyZWplY3RlZCkge1xuICAgICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2JvZHlCbG9iKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QmxvYilcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFt0aGlzLl9ib2R5QXJyYXlCdWZmZXJdKSlcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkIG5vdCByZWFkIEZvcm1EYXRhIGJvZHkgYXMgYmxvYicpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keVRleHRdKSlcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdGhpcy5hcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbnN1bWVkKHRoaXMpIHx8IFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYmxvYigpLnRoZW4ocmVhZEJsb2JBc0FycmF5QnVmZmVyKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIHRoaXMudGV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlamVjdGVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGVkXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICByZXR1cm4gcmVhZEJsb2JBc1RleHQodGhpcy5fYm9keUJsb2IpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlYWRBcnJheUJ1ZmZlckFzVGV4dCh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5Rm9ybURhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIHRleHQnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5VGV4dClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuZm9ybURhdGEpIHtcbiAgICAgIHRoaXMuZm9ybURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dCgpLnRoZW4oZGVjb2RlKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLmpzb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKEpTT04ucGFyc2UpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBIVFRQIG1ldGhvZHMgd2hvc2UgY2FwaXRhbGl6YXRpb24gc2hvdWxkIGJlIG5vcm1hbGl6ZWRcbiAgdmFyIG1ldGhvZHMgPSBbJ0RFTEVURScsICdHRVQnLCAnSEVBRCcsICdPUFRJT05TJywgJ1BPU1QnLCAnUFVUJ107XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplTWV0aG9kKG1ldGhvZCkge1xuICAgIHZhciB1cGNhc2VkID0gbWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIChtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSkgPyB1cGNhc2VkIDogbWV0aG9kXG4gIH1cblxuICBmdW5jdGlvbiBSZXF1ZXN0KGlucHV0LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHk7XG5cbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0KSB7XG4gICAgICBpZiAoaW5wdXQuYm9keVVzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJylcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gaW5wdXQudXJsO1xuICAgICAgdGhpcy5jcmVkZW50aWFscyA9IGlucHV0LmNyZWRlbnRpYWxzO1xuICAgICAgaWYgKCFvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5wdXQuaGVhZGVycyk7XG4gICAgICB9XG4gICAgICB0aGlzLm1ldGhvZCA9IGlucHV0Lm1ldGhvZDtcbiAgICAgIHRoaXMubW9kZSA9IGlucHV0Lm1vZGU7XG4gICAgICBpZiAoIWJvZHkgJiYgaW5wdXQuX2JvZHlJbml0ICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IGlucHV0Ll9ib2R5SW5pdDtcbiAgICAgICAgaW5wdXQuYm9keVVzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVybCA9IFN0cmluZyhpbnB1dCk7XG4gICAgfVxuXG4gICAgdGhpcy5jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwgdGhpcy5jcmVkZW50aWFscyB8fCAnb21pdCc7XG4gICAgaWYgKG9wdGlvbnMuaGVhZGVycyB8fCAhdGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cbiAgICB0aGlzLm1ldGhvZCA9IG5vcm1hbGl6ZU1ldGhvZChvcHRpb25zLm1ldGhvZCB8fCB0aGlzLm1ldGhvZCB8fCAnR0VUJyk7XG4gICAgdGhpcy5tb2RlID0gb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZSB8fCBudWxsO1xuICAgIHRoaXMucmVmZXJyZXIgPSBudWxsO1xuXG4gICAgaWYgKCh0aGlzLm1ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5tZXRob2QgPT09ICdIRUFEJykgJiYgYm9keSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9keSBub3QgYWxsb3dlZCBmb3IgR0VUIG9yIEhFQUQgcmVxdWVzdHMnKVxuICAgIH1cbiAgICB0aGlzLl9pbml0Qm9keShib2R5KTtcbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHsgYm9keTogdGhpcy5fYm9keUluaXQgfSlcbiAgfTtcblxuICBmdW5jdGlvbiBkZWNvZGUoYm9keSkge1xuICAgIHZhciBmb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgYm9keS50cmltKCkuc3BsaXQoJyYnKS5mb3JFYWNoKGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gYnl0ZXMuc3BsaXQoJz0nKTtcbiAgICAgICAgdmFyIG5hbWUgPSBzcGxpdC5zaGlmdCgpLnJlcGxhY2UoL1xcKy9nLCAnICcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgIGZvcm0uYXBwZW5kKGRlY29kZVVSSUNvbXBvbmVudChuYW1lKSwgZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIHByZVByb2Nlc3NlZEhlYWRlcnMuc3BsaXQoL1xccj9cXG4vKS5mb3JFYWNoKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBwYXJ0cyA9IGxpbmUuc3BsaXQoJzonKTtcbiAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcGFydHMuam9pbignOicpLnRyaW0oKTtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlcnNcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbiAgZnVuY3Rpb24gUmVzcG9uc2UoYm9keUluaXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSAnc3RhdHVzVGV4dCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc3RhdHVzVGV4dCA6ICdPSyc7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBzZWxmLkhlYWRlcnMgPSBIZWFkZXJzO1xuICBzZWxmLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICBzZWxmLlJlc3BvbnNlID0gUmVzcG9uc2U7XG5cbiAgc2VsZi5mZXRjaCA9IGZ1bmN0aW9uKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG4gICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICByZXNvbHZlKG5ldyBSZXNwb25zZShib2R5LCBvcHRpb25zKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKSk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub3BlbihyZXF1ZXN0Lm1ldGhvZCwgcmVxdWVzdC51cmwsIHRydWUpO1xuXG4gICAgICBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ2luY2x1ZGUnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmNyZWRlbnRpYWxzID09PSAnb21pdCcpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoJ3Jlc3BvbnNlVHlwZScgaW4geGhyICYmIHN1cHBvcnQuYmxvYikge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2Jsb2InO1xuICAgICAgfVxuXG4gICAgICByZXF1ZXN0LmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihuYW1lLCB2YWx1ZSk7XG4gICAgICB9KTtcblxuICAgICAgeGhyLnNlbmQodHlwZW9mIHJlcXVlc3QuX2JvZHlJbml0ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiByZXF1ZXN0Ll9ib2R5SW5pdCk7XG4gICAgfSlcbiAgfTtcbiAgc2VsZi5mZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG59KSh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDogdGhpcyk7XG59KS5jYWxsKF9fcm9vdF9fLCB2b2lkKDApKTtcbnZhciBmZXRjaCA9IF9fcm9vdF9fLmZldGNoO1xudmFyIFJlc3BvbnNlID0gZmV0Y2guUmVzcG9uc2UgPSBfX3Jvb3RfXy5SZXNwb25zZTtcbnZhciBSZXF1ZXN0ID0gZmV0Y2guUmVxdWVzdCA9IF9fcm9vdF9fLlJlcXVlc3Q7XG52YXIgSGVhZGVycyA9IGZldGNoLkhlYWRlcnMgPSBfX3Jvb3RfXy5IZWFkZXJzO1xuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5tb2R1bGUuZXhwb3J0cyA9IGZldGNoO1xuLy8gTmVlZGVkIGZvciBUeXBlU2NyaXB0IGNvbnN1bWVycyB3aXRob3V0IGVzTW9kdWxlSW50ZXJvcC5cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmZXRjaDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJvY2Vzc0ZuID0gKGZuLCBvcHRzKSA9PiBmdW5jdGlvbiAoKSB7XG5cdGNvbnN0IFAgPSBvcHRzLnByb21pc2VNb2R1bGU7XG5cdGNvbnN0IGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuXHR9XG5cblx0cmV0dXJuIG5ldyBQKChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRpZiAob3B0cy5lcnJvckZpcnN0KSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdHJlc3VsdHMudW5zaGlmdChlcnIpO1xuXHRcdFx0XHRcdFx0cmVqZWN0KHJlc3VsdHMpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChlcnIpIHtcblx0XHRcdFx0XHRyZWplY3QoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRhcmdzLnB1c2goZnVuY3Rpb24gKHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2ldID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRmbi5hcHBseSh0aGlzLCBhcmdzKTtcblx0fSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChvYmosIG9wdHMpID0+IHtcblx0b3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuXHRcdGV4Y2x1ZGU6IFsvLisoU3luY3xTdHJlYW0pJC9dLFxuXHRcdGVycm9yRmlyc3Q6IHRydWUsXG5cdFx0cHJvbWlzZU1vZHVsZTogUHJvbWlzZVxuXHR9LCBvcHRzKTtcblxuXHRjb25zdCBmaWx0ZXIgPSBrZXkgPT4ge1xuXHRcdGNvbnN0IG1hdGNoID0gcGF0dGVybiA9PiB0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycgPyBrZXkgPT09IHBhdHRlcm4gOiBwYXR0ZXJuLnRlc3Qoa2V5KTtcblx0XHRyZXR1cm4gb3B0cy5pbmNsdWRlID8gb3B0cy5pbmNsdWRlLnNvbWUobWF0Y2gpIDogIW9wdHMuZXhjbHVkZS5zb21lKG1hdGNoKTtcblx0fTtcblxuXHRsZXQgcmV0O1xuXHRpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmIChvcHRzLmV4Y2x1ZGVNYWluKSB7XG5cdFx0XHRcdHJldHVybiBvYmouYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb2Nlc3NGbihvYmosIG9wdHMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRyZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKTtcblx0fVxuXG5cdGZvciAoY29uc3Qga2V5IGluIG9iaikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGd1YXJkLWZvci1pblxuXHRcdGNvbnN0IHggPSBvYmpba2V5XTtcblx0XHRyZXRba2V5XSA9IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICYmIGZpbHRlcihrZXkpID8gcHJvY2Vzc0ZuKHgsIG9wdHMpIDogeDtcblx0fVxuXG5cdHJldHVybiByZXQ7XG59O1xuIiwiY29uc3QgRXRoUXVlcnkgPSByZXF1aXJlKCdldGgtcXVlcnknKVxuY29uc3QgcGlmeSA9IHJlcXVpcmUoJ3BpZnknKVxuY29uc3QgU2FmZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ3NhZmUtZXZlbnQtZW1pdHRlcicpXG5cbmNvbnN0IHNlYyA9IDEwMDBcblxuY29uc3QgY2FsY3VsYXRlU3VtID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlXG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbJ3N5bmMnLCAnbGF0ZXN0J11cblxuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuXG4gIC8vXG4gIC8vIHB1YmxpY1xuICAvL1xuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLy8gY29uZmlnXG4gICAgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uID0gb3B0cy5ibG9ja1Jlc2V0RHVyYXRpb24gfHwgMjAgKiBzZWNcbiAgICAvLyBzdGF0ZVxuICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0XG4gICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbFxuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlXG4gICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSB0aGlzLl9vbk5ld0xpc3RlbmVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpXG4gICAgLy8gbGlzdGVuIGZvciBoYW5kbGVyIGNoYW5nZXNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgfVxuXG4gIGlzUnVubmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZ1xuICB9XG5cbiAgZ2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrXG4gIH1cblxuICBhc3luYyBnZXRMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLl9jdXJyZW50QmxvY2spIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2tcbiAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5vbmNlKCdsYXRlc3QnLCByZXNvbHZlKSlcbiAgICAvLyByZXR1cm4gbmV3bHkgc2V0IGN1cnJlbnQgYmxvY2tcbiAgICByZXR1cm4gbGF0ZXN0QmxvY2tcbiAgfVxuXG4gIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUFsbExpc3RlbmVycyAoZXZlbnROYW1lKSB7XG4gICAgLy8gcGVyZm9ybSBkZWZhdWx0IGJlaGF2aW9yLCBwcmVzZXJ2ZSBmbiBhcml0eVxuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpXG4gICAgfVxuICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgICAvLyB0cmlnZ2VyIHN0b3AgY2hlY2sganVzdCBpbiBjYXNlXG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpXG4gIH1cblxuICAvL1xuICAvLyB0byBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAvL1xuXG4gIF9zdGFydCAoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cblxuICBfZW5kICgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc2V0dXBJbnRlcm5hbEV2ZW50cyAoKSB7XG4gICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY2VcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICB9XG5cbiAgX29uTmV3TGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgIGlmICghYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHJldHVyblxuICAgIHRoaXMuX21heWJlU3RhcnQoKVxuICB9XG5cbiAgX29uUmVtb3ZlTGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGByZW1vdmVMaXN0ZW5lcmAgaXMgY2FsbGVkICphZnRlciogdGhlIGxpc3RlbmVyIGlzIHJlbW92ZWRcbiAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkgcmV0dXJuXG4gICAgdGhpcy5fbWF5YmVFbmQoKVxuICB9XG5cbiAgX21heWJlU3RhcnQgKCkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHJldHVyblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWVcbiAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICB0aGlzLl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpXG4gICAgdGhpcy5fc3RhcnQoKVxuICB9XG5cbiAgX21heWJlRW5kICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUnVubmluZykgcmV0dXJuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KClcbiAgICB0aGlzLl9lbmQoKVxuICB9XG5cbiAgX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQgKCkge1xuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHNcbiAgICAgIC5tYXAoZXZlbnROYW1lID0+IHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpKVxuICAgICAgLnJlZHVjZShjYWxjdWxhdGVTdW0pXG4gIH1cblxuICBfbmV3UG90ZW50aWFsTGF0ZXN0IChuZXdCbG9jaykge1xuICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgIGlmIChjdXJyZW50QmxvY2sgJiYgKGhleFRvSW50KG5ld0Jsb2NrKSA8PSBoZXhUb0ludChjdXJyZW50QmxvY2spKSkgcmV0dXJuXG4gICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKVxuICB9XG5cbiAgX3NldEN1cnJlbnRCbG9jayAobmV3QmxvY2spIHtcbiAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIHRoaXMuX2N1cnJlbnRCbG9jayA9IG5ld0Jsb2NrXG4gICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBuZXdCbG9jaylcbiAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KVxuICB9XG5cbiAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQgKCkge1xuICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKVxuICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24pXG4gICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxuXG4gIF9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KVxuICB9XG5cbiAgX3Jlc2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VCbG9ja1RyYWNrZXJcblxuZnVuY3Rpb24gaGV4VG9JbnQoaGV4SW50KSB7XG4gIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaGV4SW50LCAxNilcbn1cbiIsImNvbnN0IHBpZnkgPSByZXF1aXJlKCdwaWZ5JylcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXIgPSByZXF1aXJlKCcuL2Jhc2UnKVxuXG5jb25zdCBzZWMgPSAxMDAwXG5cbmNsYXNzIFBvbGxpbmdCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQmxvY2tUcmFja2VyIHtcblxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJylcbiAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSBvcHRzLnBvbGxpbmdJbnRlcnZhbCB8fCAyMCAqIHNlY1xuICAgIGNvbnN0IHJldHJ5VGltZW91dCA9IG9wdHMucmV0cnlUaW1lb3V0IHx8IHBvbGxpbmdJbnRlcnZhbCAvIDEwXG4gICAgY29uc3Qga2VlcEV2ZW50TG9vcEFjdGl2ZSA9IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5rZWVwRXZlbnRMb29wQWN0aXZlIDogdHJ1ZVxuICAgIGNvbnN0IHNldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2VcbiAgICAvLyBCYXNlQmxvY2tUcmFja2VyIGNvbnN0cnVjdG9yXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7XG4gICAgICBibG9ja1Jlc2V0RHVyYXRpb246IHBvbGxpbmdJbnRlcnZhbCxcbiAgICB9LCBvcHRzKSlcbiAgICAvLyBjb25maWdcbiAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWxcbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSByZXRyeVRpbWVvdXRcbiAgICB0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlID0ga2VlcEV2ZW50TG9vcEFjdGl2ZVxuICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBzZXRTa2lwQ2FjaGVGbGFnXG4gIH1cblxuICAvL1xuICAvLyBwdWJsaWNcbiAgLy9cblxuICAvLyB0cmlnZ2VyIGJsb2NrIHBvbGxpbmdcbiAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jayAoKSB7XG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKClcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc3RhcnQgKCkge1xuICAgIHRoaXMuX3BlcmZvcm1TeW5jKCkuY2F0Y2goZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKVxuICB9XG5cbiAgYXN5bmMgX3BlcmZvcm1TeW5jICgpIHtcbiAgICB3aGlsZSAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpXG4gICAgICAgIGF3YWl0IHRpbWVvdXQodGhpcy5fcG9sbGluZ0ludGVydmFsLCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBuZXdFcnIgPSBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBsYXRlc3QgYmxvY2s6XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3RXJyKVxuICAgICAgICB9IGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihuZXdFcnIpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF91cGRhdGVMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gZmV0Y2ggKyBzZXQgbGF0ZXN0IGJsb2NrXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLl9mZXRjaExhdGVzdEJsb2NrKClcbiAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QobGF0ZXN0QmxvY2spXG4gIH1cblxuICBhc3luYyBfZmV0Y2hMYXRlc3RCbG9jayAoKSB7XG4gICAgY29uc3QgcmVxID0geyBqc29ucnBjOiBcIjIuMFwiLCBpZDogMSwgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJywgcGFyYW1zOiBbXSB9XG4gICAgaWYgKHRoaXMuX3NldFNraXBDYWNoZUZsYWcpIHJlcS5za2lwQ2FjaGUgPSB0cnVlXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcGlmeSgoY2IpID0+IHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGNiKSkoKVxuICAgIGlmIChyZXMuZXJyb3IpIHRocm93IG5ldyBFcnJvcihgUG9sbGluZ0Jsb2NrVHJhY2tlciAtIGVuY291bnRlcmVkIGVycm9yIGZldGNoaW5nIGJsb2NrOlxcbiR7cmVzLmVycm9yfWApXG4gICAgcmV0dXJuIHJlcy5yZXN1bHRcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZ0Jsb2NrVHJhY2tlclxuXG5mdW5jdGlvbiB0aW1lb3V0IChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pXG4gICAgLy8gZG9uJ3Qga2VlcCBwcm9jZXNzIG9wZW5cbiAgICBpZiAodGltb3V0UmVmLnVucmVmICYmIHVucmVmKSB7XG4gICAgICB0aW1vdXRSZWYudW5yZWYoKVxuICAgIH1cbiAgfSlcbn1cbiIsImNvbnN0IGV4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJylcbmNvbnN0IGNyZWF0ZVJhbmRvbUlkID0gcmVxdWlyZSgnanNvbi1ycGMtcmFuZG9tLWlkJykoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV0aFF1ZXJ5XG5cblxuZnVuY3Rpb24gRXRoUXVlcnkocHJvdmlkZXIpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyXG59XG5cbi8vXG4vLyBiYXNlIHF1ZXJpZXNcbi8vXG5cbi8vIGRlZmF1bHQgYmxvY2tcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRCYWxhbmNlID0gICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5XaXRoRGVmYXVsdEJsb2NrRm9yKDIsICdldGhfZ2V0QmFsYW5jZScpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0Q29kZSA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuV2l0aERlZmF1bHRCbG9ja0ZvcigyLCAnZXRoX2dldENvZGUnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbldpdGhEZWZhdWx0QmxvY2tGb3IoMiwgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRTdG9yYWdlQXQgPSAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5XaXRoRGVmYXVsdEJsb2NrRm9yKDMsICdldGhfZ2V0U3RvcmFnZUF0JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5jYWxsID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5XaXRoRGVmYXVsdEJsb2NrRm9yKDIsICdldGhfY2FsbCcpXG4vLyBzdGFuZGFyZFxuRXRoUXVlcnkucHJvdG90eXBlLnByb3RvY29sVmVyc2lvbiA9ICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3Byb3RvY29sVmVyc2lvbicpXG5FdGhRdWVyeS5wcm90b3R5cGUuc3luY2luZyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfc3luY2luZycpXG5FdGhRdWVyeS5wcm90b3R5cGUuY29pbmJhc2UgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfY29pbmJhc2UnKVxuRXRoUXVlcnkucHJvdG90eXBlLm1pbmluZyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX21pbmluZycpXG5FdGhRdWVyeS5wcm90b3R5cGUuaGFzaHJhdGUgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfaGFzaHJhdGUnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdhc1ByaWNlID0gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dhc1ByaWNlJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5hY2NvdW50cyA9ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9hY2NvdW50cycpXG5FdGhRdWVyeS5wcm90b3R5cGUuYmxvY2tOdW1iZXIgPSAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfYmxvY2tOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCA9ICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXIgPSAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFVuY2xlQ291bnRCeUJsb2NrSGFzaCA9ICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXIgPSAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLnNpZ24gPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3NpZ24nKVxuRXRoUXVlcnkucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9ICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3NlbmRUcmFuc2FjdGlvbicpXG5FdGhRdWVyeS5wcm90b3R5cGUuc2VuZFJhd1RyYW5zYWN0aW9uID0gICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9ICAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9lc3RpbWF0ZUdhcycpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0QmxvY2tCeUhhc2ggPSAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0QmxvY2tCeUhhc2gnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEJsb2NrQnlOdW1iZXIgPSAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEJsb2NrQnlOdW1iZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQnlIYXNoID0gICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXggPSAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tIYXNoQW5kSW5kZXgnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4ID0gZ2VuZXJhdGVGbkZvcignZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvblJlY2VpcHQgPSAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCA9ICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXggPSAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfZ2V0VW5jbGVCeUJsb2NrTnVtYmVyQW5kSW5kZXgnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldENvbXBpbGVycyA9ICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldENvbXBpbGVycycpXG5FdGhRdWVyeS5wcm90b3R5cGUuY29tcGlsZUxMTCA9ICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfY29tcGlsZUxMTCcpXG5FdGhRdWVyeS5wcm90b3R5cGUuY29tcGlsZVNvbGlkaXR5ID0gICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfY29tcGlsZVNvbGlkaXR5JylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5jb21waWxlU2VycGVudCA9ICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9jb21waWxlU2VycGVudCcpXG5FdGhRdWVyeS5wcm90b3R5cGUubmV3RmlsdGVyID0gICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfbmV3RmlsdGVyJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS5uZXdCbG9ja0ZpbHRlciA9ICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF9uZXdCbG9ja0ZpbHRlcicpXG5FdGhRdWVyeS5wcm90b3R5cGUubmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyID0gICAgICAgICBnZW5lcmF0ZUZuRm9yKCdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJylcbkV0aFF1ZXJ5LnByb3RvdHlwZS51bmluc3RhbGxGaWx0ZXIgPSAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlRm5Gb3IoJ2V0aF91bmluc3RhbGxGaWx0ZXInKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEZpbHRlckNoYW5nZXMgPSAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEZpbHRlckNoYW5nZXMnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldEZpbHRlckxvZ3MgPSAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldEZpbHRlckxvZ3MnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldExvZ3MgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldExvZ3MnKVxuRXRoUXVlcnkucHJvdG90eXBlLmdldFdvcmsgPSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX2dldFdvcmsnKVxuRXRoUXVlcnkucHJvdG90eXBlLnN1Ym1pdFdvcmsgPSAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3N1Ym1pdFdvcmsnKVxuRXRoUXVlcnkucHJvdG90eXBlLnN1Ym1pdEhhc2hyYXRlID0gICAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVGbkZvcignZXRoX3N1Ym1pdEhhc2hyYXRlJylcblxuLy8gbmV0d29yayBsZXZlbFxuXG5FdGhRdWVyeS5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24ob3B0cywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLmN1cnJlbnRQcm92aWRlci5zZW5kQXN5bmMoY3JlYXRlUGF5bG9hZChvcHRzKSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSl7XG4gICAgaWYgKCFlcnIgJiYgcmVzcG9uc2UuZXJyb3IpIGVyciA9IG5ldyBFcnJvcignRXRoUXVlcnkgLSBSUEMgRXJyb3IgLSAnK3Jlc3BvbnNlLmVycm9yLm1lc3NhZ2UpXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjYihudWxsLCByZXNwb25zZS5yZXN1bHQpXG4gIH0pXG59XG5cbi8vIHV0aWxcblxuZnVuY3Rpb24gZ2VuZXJhdGVGbkZvcihtZXRob2ROYW1lKXtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHZhciBjYiA9IGFyZ3MucG9wKClcbiAgICBzZWxmLnNlbmRBc3luYyh7XG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgfSwgY2IpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVGbldpdGhEZWZhdWx0QmxvY2tGb3IoYXJnQ291bnQsIG1ldGhvZE5hbWUpe1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICBjb25zdCBzZWxmID0gdGhpc1xuICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgdmFyIGNiID0gYXJncy5wb3AoKVxuICAgIC8vIHNldCBvcHRpb25hbCBkZWZhdWx0IGJsb2NrIHBhcmFtXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgYXJnQ291bnQpIGFyZ3MucHVzaCgnbGF0ZXN0JylcbiAgICBzZWxmLnNlbmRBc3luYyh7XG4gICAgICBtZXRob2Q6IG1ldGhvZE5hbWUsXG4gICAgICBwYXJhbXM6IGFyZ3MsXG4gICAgfSwgY2IpXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF5bG9hZChkYXRhKXtcbiAgcmV0dXJuIGV4dGVuZCh7XG4gICAgLy8gZGVmYXVsdHNcbiAgICBpZDogY3JlYXRlUmFuZG9tSWQoKSxcbiAgICBqc29ucnBjOiAnMi4wJyxcbiAgICBwYXJhbXM6IFtdLFxuICAgIC8vIHVzZXItc3BlY2lmaWVkXG4gIH0sIGRhdGEpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiAkZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiAkZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gJGdldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIFJlZmxlY3RBcHBseSh0aGlzLmxpc3RlbmVyLCB0aGlzLnRhcmdldCwgYXJncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4KSB7XG5cdHJldHVybiB0b1N0cmluZy5jYWxsKHgpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbiIsIi8qKlxuICogUmV0dXJucyBhIGBCb29sZWFuYCBvbiB3aGV0aGVyIG9yIG5vdCB0aGUgYSBgU3RyaW5nYCBzdGFydHMgd2l0aCAnMHgnXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIHRoZSBzdHJpbmcgaW5wdXQgdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGEgYm9vbGVhbiBpZiBpdCBpcyBvciBpcyBub3QgaGV4IHByZWZpeGVkXG4gKiBAdGhyb3dzIGlmIHRoZSBzdHIgaW5wdXQgaXMgbm90IGEgc3RyaW5nXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW2lzLWhleC1wcmVmaXhlZF0gdmFsdWUgbXVzdCBiZSB0eXBlICdzdHJpbmcnLCBpcyBjdXJyZW50bHkgdHlwZSBcIiArICh0eXBlb2Ygc3RyKSArIFwiLCB3aGlsZSBjaGVja2luZyBpc0hleFByZWZpeGVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBzdHIuc2xpY2UoMCwgMikgPT09ICcweCc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2Vycm9ycycpOyIsInZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbnZhciBKc29uUnBjRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLCBjb2RlLCBkYXRhKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBKc29uUnBjRXJyb3IpKSB7XG4gICAgcmV0dXJuIG5ldyBKc29uUnBjRXJyb3IobWVzc2FnZSwgY29kZSwgZGF0YSk7XG4gIH1cblxuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG59O1xuXG5pbmhlcml0cyhKc29uUnBjRXJyb3IsIEVycm9yKTtcblxudmFyIFBhcnNlRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhcnNlRXJyb3IpKSB7XG4gICAgcmV0dXJuIG5ldyBQYXJzZUVycm9yKCk7XG4gIH1cblxuICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnUGFyc2UgZXJyb3InLCAtMzI3MDApO1xufTtcblxuaW5oZXJpdHMoUGFyc2VFcnJvciwgSnNvblJwY0Vycm9yKTtcblxudmFyIEludmFsaWRSZXF1ZXN0ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbnZhbGlkUmVxdWVzdCkpIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRSZXF1ZXN0KCk7XG4gIH1cblxuICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCAnSW52YWxpZCBSZXF1ZXN0JywgLTMyNjAwKTtcbn07XG5cbmluaGVyaXRzKEludmFsaWRSZXF1ZXN0LCBKc29uUnBjRXJyb3IpO1xuXG52YXIgTWV0aG9kTm90Rm91bmQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1ldGhvZE5vdEZvdW5kKSkge1xuICAgIHJldHVybiBuZXcgTWV0aG9kTm90Rm91bmQoKTtcbiAgfVxuXG4gIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdNZXRob2Qgbm90IGZvdW5kJywgLTMyNjAxKTtcbn07XG5cbmluaGVyaXRzKE1ldGhvZE5vdEZvdW5kLCBKc29uUnBjRXJyb3IpO1xuXG52YXIgSW52YWxpZFBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW52YWxpZFBhcmFtcykpIHtcbiAgICByZXR1cm4gbmV3IEludmFsaWRQYXJhbXMoKTtcbiAgfVxuXG4gIEpzb25ScGNFcnJvci5jYWxsKHRoaXMsICdJbnZhbGlkIHBhcmFtcycsIC0zMjYwMik7XG59O1xuXG5pbmhlcml0cyhJbnZhbGlkUGFyYW1zLCBKc29uUnBjRXJyb3IpO1xuXG52YXIgSW50ZXJuYWxFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICB2YXIgbWVzc2FnZTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSW50ZXJuYWxFcnJvcikpIHtcbiAgICByZXR1cm4gbmV3IEludGVybmFsRXJyb3IoZXJyKTtcbiAgfVxuXG4gIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gZXJyLm1lc3NhZ2U7XG4gIH0gZWxzZSB7XG4gICAgbWVzc2FnZSA9ICdJbnRlcm5hbCBlcnJvcic7XG4gIH1cblxuICBKc29uUnBjRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlLCAtMzI2MDMpO1xufTtcblxuaW5oZXJpdHMoSW50ZXJuYWxFcnJvciwgSnNvblJwY0Vycm9yKTtcblxudmFyIFNlcnZlckVycm9yID0gZnVuY3Rpb24oY29kZSkge1xuICBpZiAoY29kZSA8IC0zMjA5OSB8fCBjb2RlID4gLTMyMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGVycm9yIGNvZGUnKTtcbiAgfVxuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTZXJ2ZXJFcnJvcikpIHtcbiAgICByZXR1cm4gbmV3IFNlcnZlckVycm9yKGNvZGUpO1xuICB9XG5cbiAgSnNvblJwY0Vycm9yLmNhbGwodGhpcywgJ1NlcnZlciBlcnJvcicsIGNvZGUpO1xufTtcblxuaW5oZXJpdHMoU2VydmVyRXJyb3IsIEpzb25ScGNFcnJvcik7XG5cbkpzb25ScGNFcnJvci5QYXJzZUVycm9yID0gUGFyc2VFcnJvcjtcbkpzb25ScGNFcnJvci5JbnZhbGlkUmVxdWVzdCA9IEludmFsaWRSZXF1ZXN0O1xuSnNvblJwY0Vycm9yLk1ldGhvZE5vdEZvdW5kID0gTWV0aG9kTm90Rm91bmQ7XG5Kc29uUnBjRXJyb3IuSW52YWxpZFBhcmFtcyA9IEludmFsaWRQYXJhbXM7XG5Kc29uUnBjRXJyb3IuSW50ZXJuYWxFcnJvciA9IEludGVybmFsRXJyb3I7XG5Kc29uUnBjRXJyb3IuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUnBjRXJyb3I7XG5cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBJZEl0ZXJhdG9yXG5cbmZ1bmN0aW9uIElkSXRlcmF0b3Iob3B0cyl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHZhciBtYXggPSBvcHRzLm1heCB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB2YXIgaWRDb3VudGVyID0gdHlwZW9mIG9wdHMuc3RhcnQgIT09ICd1bmRlZmluZWQnID8gb3B0cy5zdGFydCA6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heClcblxuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUmFuZG9tSWQgKCkge1xuICAgIGlkQ291bnRlciA9IGlkQ291bnRlciAlIG1heFxuICAgIHJldHVybiBpZENvdW50ZXIrK1xuICB9XG5cbn0iLCJ2YXIganNvbiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJyA/IEpTT04gOiByZXF1aXJlKCdqc29uaWZ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgb3B0cyA9IHsgY21wOiBvcHRzIH07XG4gICAgdmFyIHNwYWNlID0gb3B0cy5zcGFjZSB8fCAnJztcbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykgc3BhY2UgPSBBcnJheShzcGFjZSsxKS5qb2luKCcgJyk7XG4gICAgdmFyIGN5Y2xlcyA9ICh0eXBlb2Ygb3B0cy5jeWNsZXMgPT09ICdib29sZWFuJykgPyBvcHRzLmN5Y2xlcyA6IGZhbHNlO1xuICAgIHZhciByZXBsYWNlciA9IG9wdHMucmVwbGFjZXIgfHwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXR1cm4gdmFsdWU7IH07XG5cbiAgICB2YXIgY21wID0gb3B0cy5jbXAgJiYgKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFvYmogPSB7IGtleTogYSwgdmFsdWU6IG5vZGVbYV0gfTtcbiAgICAgICAgICAgICAgICB2YXIgYm9iaiA9IHsga2V5OiBiLCB2YWx1ZTogbm9kZVtiXSB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmKGFvYmosIGJvYmopO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9KShvcHRzLmNtcCk7XG5cbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIHJldHVybiAoZnVuY3Rpb24gc3RyaW5naWZ5IChwYXJlbnQsIGtleSwgbm9kZSwgbGV2ZWwpIHtcbiAgICAgICAgdmFyIGluZGVudCA9IHNwYWNlID8gKCdcXG4nICsgbmV3IEFycmF5KGxldmVsICsgMSkuam9pbihzcGFjZSkpIDogJyc7XG4gICAgICAgIHZhciBjb2xvblNlcGFyYXRvciA9IHNwYWNlID8gJzogJyA6ICc6JztcblxuICAgICAgICBpZiAobm9kZSAmJiBub2RlLnRvSlNPTiAmJiB0eXBlb2Ygbm9kZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLnRvSlNPTigpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHJlcGxhY2VyLmNhbGwocGFyZW50LCBrZXksIG5vZGUpO1xuXG4gICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8IG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uLnN0cmluZ2lmeShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBzdHJpbmdpZnkobm9kZSwgaSwgbm9kZVtpXSwgbGV2ZWwrMSkgfHwganNvbi5zdHJpbmdpZnkobnVsbCk7XG4gICAgICAgICAgICAgICAgb3V0LnB1c2goaW5kZW50ICsgc3BhY2UgKyBpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnWycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ10nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3ljbGVzKSByZXR1cm4ganNvbi5zdHJpbmdpZnkoJ19fY3ljbGVfXycpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NvbnZlcnRpbmcgY2lyY3VsYXIgc3RydWN0dXJlIHRvIEpTT04nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugc2Vlbi5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMobm9kZSkuc29ydChjbXAgJiYgY21wKG5vZGUpKTtcbiAgICAgICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHN0cmluZ2lmeShub2RlLCBrZXksIG5vZGVba2V5XSwgbGV2ZWwrMSk7XG5cbiAgICAgICAgICAgICAgICBpZighdmFsdWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleVZhbHVlID0ganNvbi5zdHJpbmdpZnkoa2V5KVxuICAgICAgICAgICAgICAgICAgICArIGNvbG9uU2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIG91dC5wdXNoKGluZGVudCArIHNwYWNlICsga2V5VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2Vlbi5zcGxpY2Uoc2Vlbi5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiAneycgKyBvdXQuam9pbignLCcpICsgaW5kZW50ICsgJ30nO1xuICAgICAgICB9XG4gICAgfSkoeyAnJzogb2JqIH0sICcnLCBvYmosIDApO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwoeCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn07XG4iLCJleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9saWIvcGFyc2UnKTtcbmV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9saWIvc3RyaW5naWZ5Jyk7XG4iLCJ2YXIgYXQsIC8vIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgZXNjYXBlZSA9IHtcbiAgICAgICAgJ1wiJzogICdcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFwnLFxuICAgICAgICAnLyc6ICAnLycsXG4gICAgICAgIGI6ICAgICdcXGInLFxuICAgICAgICBmOiAgICAnXFxmJyxcbiAgICAgICAgbjogICAgJ1xcbicsXG4gICAgICAgIHI6ICAgICdcXHInLFxuICAgICAgICB0OiAgICAnXFx0J1xuICAgIH0sXG4gICAgdGV4dCxcblxuICAgIGVycm9yID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgLy8gQ2FsbCBlcnJvciB3aGVuIHNvbWV0aGluZyBpcyB3cm9uZy5cbiAgICAgICAgdGhyb3cge1xuICAgICAgICAgICAgbmFtZTogICAgJ1N5bnRheEVycm9yJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IG0sXG4gICAgICAgICAgICBhdDogICAgICBhdCxcbiAgICAgICAgICAgIHRleHQ6ICAgIHRleHRcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFxuICAgIG5leHQgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAvLyBJZiBhIGMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB2ZXJpZnkgdGhhdCBpdCBtYXRjaGVzIHRoZSBjdXJyZW50IGNoYXJhY3Rlci5cbiAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgIGVycm9yKFwiRXhwZWN0ZWQgJ1wiICsgYyArIFwiJyBpbnN0ZWFkIG9mICdcIiArIGNoICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBHZXQgdGhlIG5leHQgY2hhcmFjdGVyLiBXaGVuIHRoZXJlIGFyZSBubyBtb3JlIGNoYXJhY3RlcnMsXG4gICAgICAgIC8vIHJldHVybiB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAgICBcbiAgICAgICAgY2ggPSB0ZXh0LmNoYXJBdChhdCk7XG4gICAgICAgIGF0ICs9IDE7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuICAgIFxuICAgIG51bWJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgIHZhciBudW1iZXIsXG4gICAgICAgICAgICBzdHJpbmcgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGlmIChjaCA9PT0gJy0nKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSAnLSc7XG4gICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgc3RyaW5nICs9ICcuJztcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkgJiYgY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICBpZiAoIWlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgIGVycm9yKFwiQmFkIG51bWJlclwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUGFyc2UgYSBzdHJpbmcgdmFsdWUuXG4gICAgICAgIHZhciBoZXgsXG4gICAgICAgICAgICBpLFxuICAgICAgICAgICAgc3RyaW5nID0gJycsXG4gICAgICAgICAgICB1ZmZmZjtcbiAgICAgICAgXG4gICAgICAgIC8vIFdoZW4gcGFyc2luZyBmb3Igc3RyaW5nIHZhbHVlcywgd2UgbXVzdCBsb29rIGZvciBcIiBhbmQgXFwgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd1Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhleCA9IHBhcnNlSW50KG5leHQoKSwgMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodWZmZmYpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlc2NhcGVlW2NoXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBzdHJpbmdcIik7XG4gICAgfSxcblxuICAgIHdoaXRlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBTa2lwIHdoaXRlc3BhY2UuXG5cbiAgICAgICAgd2hpbGUgKGNoICYmIGNoIDw9ICcgJykge1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHdvcmQgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuXG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICBuZXh0KCdyJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICBuZXh0KCdhJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgbmV4dCgnbicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJVbmV4cGVjdGVkICdcIiArIGNoICsgXCInXCIpO1xuICAgIH0sXG5cbiAgICB2YWx1ZSwgIC8vIFBsYWNlIGhvbGRlciBmb3IgdGhlIHZhbHVlIGZ1bmN0aW9uLlxuXG4gICAgYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIGFycmF5IHZhbHVlLlxuXG4gICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ1snKSB7XG4gICAgICAgICAgICBuZXh0KCdbJyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAgIC8vIGVtcHR5IGFycmF5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIGFycmF5XCIpO1xuICAgIH0sXG5cbiAgICBvYmplY3QgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cblxuICAgICAgICB2YXIga2V5LFxuICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKGNoID09PSAneycpIHtcbiAgICAgICAgICAgIG5leHQoJ3snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAgIC8vIGVtcHR5IG9iamVjdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gc3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcignRHVwbGljYXRlIGtleSBcIicgKyBrZXkgKyAnXCInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZSgpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBvYmplY3RcIik7XG4gICAgfTtcblxudmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFBhcnNlIGEgSlNPTiB2YWx1ZS4gSXQgY291bGQgYmUgYW4gb2JqZWN0LCBhbiBhcnJheSwgYSBzdHJpbmcsIGEgbnVtYmVyLFxuLy8gb3IgYSB3b3JkLlxuXG4gICAgd2hpdGUoKTtcbiAgICBzd2l0Y2ggKGNoKSB7XG4gICAgY2FzZSAneyc6XG4gICAgICAgIHJldHVybiBvYmplY3QoKTtcbiAgICBjYXNlICdbJzpcbiAgICAgICAgcmV0dXJuIGFycmF5KCk7XG4gICAgY2FzZSAnXCInOlxuICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgY2FzZSAnLSc6XG4gICAgICAgIHJldHVybiBudW1iZXIoKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gY2ggPj0gJzAnICYmIGNoIDw9ICc5JyA/IG51bWJlcigpIDogd29yZCgpO1xuICAgIH1cbn07XG5cbi8vIFJldHVybiB0aGUganNvbl9wYXJzZSBmdW5jdGlvbi4gSXQgd2lsbCBoYXZlIGFjY2VzcyB0byBhbGwgb2YgdGhlIGFib3ZlXG4vLyBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCByZXZpdmVyKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBcbiAgICB0ZXh0ID0gc291cmNlO1xuICAgIGF0ID0gMDtcbiAgICBjaCA9ICcgJztcbiAgICByZXN1bHQgPSB2YWx1ZSgpO1xuICAgIHdoaXRlKCk7XG4gICAgaWYgKGNoKSB7XG4gICAgICAgIGVycm9yKFwiU3ludGF4IGVycm9yXCIpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmV2aXZlciBmdW5jdGlvbiwgd2UgcmVjdXJzaXZlbHkgd2FsayB0aGUgbmV3IHN0cnVjdHVyZSxcbiAgICAvLyBwYXNzaW5nIGVhY2ggbmFtZS92YWx1ZSBwYWlyIHRvIHRoZSByZXZpdmVyIGZ1bmN0aW9uIGZvciBwb3NzaWJsZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLCBzdGFydGluZyB3aXRoIGEgdGVtcG9yYXJ5IHJvb3Qgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIHJlc3VsdFxuICAgIC8vIGluIGFuIGVtcHR5IGtleS4gSWYgdGhlcmUgaXMgbm90IGEgcmV2aXZlciBmdW5jdGlvbiwgd2Ugc2ltcGx5IHJldHVybiB0aGVcbiAgICAvLyByZXN1bHQuXG5cbiAgICByZXR1cm4gdHlwZW9mIHJldml2ZXIgPT09ICdmdW5jdGlvbicgPyAoZnVuY3Rpb24gd2Fsayhob2xkZXIsIGtleSkge1xuICAgICAgICB2YXIgaywgdiwgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHYgPSB3YWxrKHZhbHVlLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVba10gPSB2O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXZpdmVyLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9KHsnJzogcmVzdWx0fSwgJycpKSA6IHJlc3VsdDtcbn07XG4iLCJ2YXIgY3ggPSAvW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGdhcCxcbiAgICBpbmRlbnQsXG4gICAgbWV0YSA9IHsgICAgLy8gdGFibGUgb2YgY2hhcmFjdGVyIHN1YnN0aXR1dGlvbnNcbiAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAnXFxuJzogJ1xcXFxuJyxcbiAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAnXCInIDogJ1xcXFxcIicsXG4gICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgIH0sXG4gICAgcmVwO1xuXG5mdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcbiAgICAvLyBJZiB0aGUgc3RyaW5nIGNvbnRhaW5zIG5vIGNvbnRyb2wgY2hhcmFjdGVycywgbm8gcXVvdGUgY2hhcmFjdGVycywgYW5kIG5vXG4gICAgLy8gYmFja3NsYXNoIGNoYXJhY3RlcnMsIHRoZW4gd2UgY2FuIHNhZmVseSBzbGFwIHNvbWUgcXVvdGVzIGFyb3VuZCBpdC5cbiAgICAvLyBPdGhlcndpc2Ugd2UgbXVzdCBhbHNvIHJlcGxhY2UgdGhlIG9mZmVuZGluZyBjaGFyYWN0ZXJzIHdpdGggc2FmZSBlc2NhcGVcbiAgICAvLyBzZXF1ZW5jZXMuXG4gICAgXG4gICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIGVzY2FwYWJsZS50ZXN0KHN0cmluZykgPyAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIH0pICsgJ1wiJyA6ICdcIicgKyBzdHJpbmcgKyAnXCInO1xufVxuXG5mdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcbiAgICAvLyBQcm9kdWNlIGEgc3RyaW5nIGZyb20gaG9sZGVyW2tleV0uXG4gICAgdmFyIGksICAgICAgICAgIC8vIFRoZSBsb29wIGNvdW50ZXIuXG4gICAgICAgIGssICAgICAgICAgIC8vIFRoZSBtZW1iZXIga2V5LlxuICAgICAgICB2LCAgICAgICAgICAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICBsZW5ndGgsXG4gICAgICAgIG1pbmQgPSBnYXAsXG4gICAgICAgIHBhcnRpYWwsXG4gICAgICAgIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgXG4gICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICB9XG4gICAgXG4gICAgLy8gSWYgd2Ugd2VyZSBjYWxsZWQgd2l0aCBhIHJlcGxhY2VyIGZ1bmN0aW9uLCB0aGVuIGNhbGwgdGhlIHJlcGxhY2VyIHRvXG4gICAgLy8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgaWYgKHR5cGVvZiByZXAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSByZXAuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBcbiAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBFbmNvZGUgbm9uLWZpbml0ZSBudW1iZXJzIGFzIG51bGwuXG4gICAgICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gU3RyaW5nKHZhbHVlKSA6ICdudWxsJztcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIGJvb2xlYW4gb3IgbnVsbCwgY29udmVydCBpdCB0byBhIHN0cmluZy4gTm90ZTpcbiAgICAgICAgICAgIC8vIHR5cGVvZiBudWxsIGRvZXMgbm90IHByb2R1Y2UgJ251bGwnLiBUaGUgY2FzZSBpcyBpbmNsdWRlZCBoZXJlIGluXG4gICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICBnYXAgKz0gaW5kZW50O1xuICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBBcnJheS5pc0FycmF5XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseSh2YWx1ZSkgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpYWxbaV0gPSBzdHIoaSwgdmFsdWUpIHx8ICdudWxsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIGVsZW1lbnRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsIGFuZFxuICAgICAgICAgICAgICAgIC8vIHdyYXAgdGhlbSBpbiBicmFja2V0cy5cbiAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDogZ2FwID9cbiAgICAgICAgICAgICAgICAgICAgJ1tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVwbGFjZXIgaXMgYW4gYXJyYXksIHVzZSBpdCB0byBzZWxlY3QgdGhlIG1lbWJlcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHN0cmluZ2lmaWVkLlxuICAgICAgICAgICAgaWYgKHJlcCAmJiB0eXBlb2YgcmVwID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSByZXBbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgaXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUga2V5cyBpbiB0aGUgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBtZW1iZXIgdGV4dHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcyxcbiAgICAgICAgLy8gYW5kIHdyYXAgdGhlbSBpbiBicmFjZXMuXG5cbiAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ3t9JyA6IGdhcCA/XG4gICAgICAgICAgICAne1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICd9JyA6XG4gICAgICAgICAgICAneycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICd9JztcbiAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICAgdmFyIGk7XG4gICAgZ2FwID0gJyc7XG4gICAgaW5kZW50ID0gJyc7XG4gICAgXG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIG51bWJlciwgbWFrZSBhbiBpbmRlbnQgc3RyaW5nIGNvbnRhaW5pbmcgdGhhdFxuICAgIC8vIG1hbnkgc3BhY2VzLlxuICAgIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzcGFjZTsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbmRlbnQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcsIGl0IHdpbGwgYmUgdXNlZCBhcyB0aGUgaW5kZW50IHN0cmluZy5cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGVudCA9IHNwYWNlO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVwbGFjZXIsIGl0IG11c3QgYmUgYSBmdW5jdGlvbiBvciBhbiBhcnJheS5cbiAgICAvLyBPdGhlcndpc2UsIHRocm93IGFuIGVycm9yLlxuICAgIHJlcCA9IHJlcGxhY2VyO1xuICAgIGlmIChyZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgIT09ICdmdW5jdGlvbidcbiAgICAmJiAodHlwZW9mIHJlcGxhY2VyICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVwbGFjZXIubGVuZ3RoICE9PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdKU09OLnN0cmluZ2lmeScpO1xuICAgIH1cbiAgICBcbiAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IG9mIHN0cmluZ2lmeWluZyB0aGUgdmFsdWUuXG4gICAgcmV0dXJuIHN0cignJywgeycnOiB2YWx1ZX0pO1xufTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgaXNGbiA9IHJlcXVpcmUoJ2lzLWZuJyk7XG52YXIgc2V0SW1tZWRpYXRlID0gcmVxdWlyZSgnc2V0LWltbWVkaWF0ZS1zaGltJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHByb21pc2UpIHtcblx0aWYgKCFpc0ZuKHByb21pc2UudGhlbikpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIHByb21pc2UnKTtcblx0fVxuXG5cdHJldHVybiBmdW5jdGlvbiAoY2IpIHtcblx0XHRwcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcblx0XHRcdHNldEltbWVkaWF0ZShjYiwgbnVsbCwgZGF0YSk7XG5cdFx0fSwgZnVuY3Rpb24gKGVycikge1xuXHRcdFx0c2V0SW1tZWRpYXRlKGNiLCBlcnIpO1xuXHRcdH0pO1xuXHR9O1xufTtcbiIsImNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cy8nKVxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTYWZlRXZlbnRFbWl0dGVyXG5cblxuZnVuY3Rpb24gU2FmZUV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcbn1cblxudXRpbC5pbmhlcml0cyhTYWZlRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXIpXG5cblNhZmVFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAodHlwZSkge1xuICAvLyBjb3BpZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vR296YWxhL2V2ZW50cy9ibG9iL21hc3Rlci9ldmVudHMuanNcbiAgLy8gbW9kaWZpZWQgbGluZXMgYXJlIGNvbW1lbnRlZCB3aXRoIFwiZWRpdGVkOlwiXG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBlZGl0ZWQ6IHVzaW5nIHNhZmVBcHBseVxuICAgIHNhZmVBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgLy8gZWRpdGVkOiB1c2luZyBzYWZlQXBwbHlcbiAgICAgIHNhZmVBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHNhZmVBcHBseShoYW5kbGVyLCBjb250ZXh0LCBhcmdzKSB7XG4gIHRyeSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIGNvbnRleHQsIGFyZ3MpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIHRocm93IGVycm9yIGFmdGVyIHRpbWVvdXQgc28gYXMgbm90IHRvIGludGVydXB0IHRoZSBzdGFja1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09ICdmdW5jdGlvbicgPyBzZXRJbW1lZGlhdGUgOlxuXHRmdW5jdGlvbiBzZXRJbW1lZGlhdGUoKSB7XG5cdFx0dmFyIGFyZ3MgPSBbXS5zbGljZS5hcHBseShhcmd1bWVudHMpO1xuXHRcdGFyZ3Muc3BsaWNlKDEsIDAsIDApO1xuXHRcdHNldFRpbWVvdXQuYXBwbHkobnVsbCwgYXJncyk7XG5cdH07XG4iLCJ2YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgJzB4JyBmcm9tIGEgZ2l2ZW4gYFN0cmluZ2AgaXMgcHJlc2VudFxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciB0aGUgc3RyaW5nIHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd8T3B0aW9uYWx9IGEgc3RyaW5nIGJ5IHBhc3MgaWYgbmVjZXNzYXJ5XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICByZXR1cm4gaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyLnNsaWNlKDIpIDogc3RyO1xufVxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsInZhciB2MSA9IHJlcXVpcmUoJy4vdjEnKTtcbnZhciB2NCA9IHJlcXVpcmUoJy4vdjQnKTtcblxudmFyIHV1aWQgPSB2NDtcbnV1aWQudjEgPSB2MTtcbnV1aWQudjQgPSB2NDtcblxubW9kdWxlLmV4cG9ydHMgPSB1dWlkO1xuIiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xudmFyIF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IHJuZygpO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbXG4gICAgICAgIHNlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgICAgIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH1cblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgPyBidWYgOiBieXRlc1RvVXVpZChiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2MTtcbiIsInZhciBybmcgPSByZXF1aXJlKCcuL2xpYi9ybmcnKTtcbnZhciBieXRlc1RvVXVpZCA9IHJlcXVpcmUoJy4vbGliL2J5dGVzVG9VdWlkJyk7XG5cbmZ1bmN0aW9uIHY0KG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuXG4gIGlmICh0eXBlb2Yob3B0aW9ucykgPT0gJ3N0cmluZycpIHtcbiAgICBidWYgPSBvcHRpb25zID09PSAnYmluYXJ5JyA/IG5ldyBBcnJheSgxNikgOiBudWxsO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG4gIHJuZHNbNl0gPSAocm5kc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgcm5kc1s4XSA9IChybmRzWzhdICYgMHgzZikgfCAweDgwO1xuXG4gIC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuICBpZiAoYnVmKSB7XG4gICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDE2OyArK2lpKSB7XG4gICAgICBidWZbaSArIGlpXSA9IHJuZHNbaWldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWYgfHwgYnl0ZXNUb1V1aWQocm5kcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdjQ7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIC8qKlxuICAgICAqIEEgdG9rZW4gdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gQml0c2tpIG9uIGJlaGFsZiBvZiBhIHVzZXIuXG4gICAgICovXG4gICAgY2xhc3MgQWNjZXNzVG9rZW4ge1xuICAgICAgICBjb25zdHJ1Y3Rvcih0b2tlbiwgZXhwaXJlc0luKSB7XG4gICAgICAgICAgICB0aGlzLmV4cGlyZXNBdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIGlmIChleHBpcmVzSW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGlyZXNBdCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApICsgZXhwaXJlc0luO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCBleHBpcmVkKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXhwaXJlc0F0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwaXJlc0luID0gdGhpcy5leHBpcmVzQXQgLSBub3c7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGlyZXNJbiA8PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuQWNjZXNzVG9rZW4gPSBBY2Nlc3NUb2tlbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWNjZXNzLXRva2VuLmpzLm1hcCIsInZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG4gICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIiwgXCIuL2Vycm9ycy9wcm92aWRlci1lcnJvclwiLCBcIi4vc3VicHJvdmlkZXJzL25vbmNlLXRyYWNrZXJcIiwgXCIuL3N1YnByb3ZpZGVycy90cmFuc2FjdGlvbi12YWxpZGF0b3JcIiwgXCIuL3N1YnByb3ZpZGVycy90eXBlZC1kYXRhXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBwcm92aWRlcl9lbmdpbmVfMSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIikpO1xuICAgIGNvbnN0IHByb3ZpZGVyX2Vycm9yXzEgPSByZXF1aXJlKFwiLi9lcnJvcnMvcHJvdmlkZXItZXJyb3JcIik7XG4gICAgY29uc3Qgbm9uY2VfdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vc3VicHJvdmlkZXJzL25vbmNlLXRyYWNrZXJcIik7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25fdmFsaWRhdG9yXzEgPSByZXF1aXJlKFwiLi9zdWJwcm92aWRlcnMvdHJhbnNhY3Rpb24tdmFsaWRhdG9yXCIpO1xuICAgIGNvbnN0IHR5cGVkX2RhdGFfMSA9IHJlcXVpcmUoXCIuL3N1YnByb3ZpZGVycy90eXBlZC1kYXRhXCIpO1xuICAgIGNsYXNzIEJpdHNraUVuZ2luZSBleHRlbmRzIHByb3ZpZGVyX2VuZ2luZV8xLmRlZmF1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgLy8gSGFuZGxlcyBzdGF0aWMgcmVzcG9uc2VzXG4gICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKG5ldyBwcm92aWRlcl9lbmdpbmVfMS5EZWZhdWx0Rml4dHVyZVN1YnByb3ZpZGVyKCkpO1xuICAgICAgICAgICAgLy8gTW9uaXRvcnMgcmVxdWVzdHMgdG8gZXRoX2dldFRyYW5zYWN0aW9uQ291bnQgYW5kIGV0aF9zZW5kVHJhbnNhY3Rpb24gdG8gdHJhY2tcbiAgICAgICAgICAgIC8vIHBlbmRpbmcgdHJhbnNhY3Rpb25zXG4gICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKG5ldyBub25jZV90cmFja2VyXzEuTm9uY2VUcmFja2VyU3VicHJvdmlkZXIoKSk7XG4gICAgICAgICAgICAvLyBTYW5pdGl6ZXMgdHJhbnNhY3Rpb24gcGFyYW1zLCByZW1vdmluZyBhbnl0aGluZyBpbnZhbGlkXG4gICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKG5ldyBwcm92aWRlcl9lbmdpbmVfMS5TYW5pdGl6ZXJTdWJwcm92aWRlcigpKTtcbiAgICAgICAgICAgIGNvbnN0IGVuYWJsZVZhbGlkYXRvciA9ICEob3B0aW9ucyAmJiBvcHRpb25zLmRpc2FibGVWYWxpZGF0aW9uID09PSB0cnVlKTtcbiAgICAgICAgICAgIGlmIChlbmFibGVWYWxpZGF0b3IpIHtcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmVzIHRoYXQgdHJhbnNhY3Rpb25zIGFyZSB3ZWxsIGZvcm1lZCAobm9uY2UsIGdhcywgZ2FzUHJpY2UsIGZyb20pIGJlZm9yZSB0aGV5IGFyZSBzZW50IHRvIEJpdHNraVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IHRyYW5zYWN0aW9uX3ZhbGlkYXRvcl8xLlRyYW5zYWN0aW9uVmFsaWRhdG9yU3VicHJvdmlkZXIob3B0aW9ucy5taW5HYXNQcmljZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkUHJvdmlkZXIobmV3IHR5cGVkX2RhdGFfMS5UeXBlZERhdGFTYW5pdGl6ZXJTdWJwcm92aWRlcigpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuYWJsZUNhY2hlID0gIShvcHRpb25zICYmIG9wdGlvbnMuZGlzYWJsZUNhY2hpbmcgPT09IHRydWUpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgLy8gQmxvY2sgQ2FjaGUgLSBjYWNoZXMgY2VydGFpbiByZXF1ZXN0cyBieSB0aGVpciBibG9jayBudW1iZXJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKG5ldyBwcm92aWRlcl9lbmdpbmVfMS5CbG9ja0NhY2hlU3VicHJvdmlkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGVzIHN1YnNjcmlwdGlvbnMgYW5kIGZpbHRlcnNcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckFuZFN1YnNTdWJwcm92aWRlciA9IG5ldyBwcm92aWRlcl9lbmdpbmVfMS5TdWJzY3JpcHRpb25TdWJwcm92aWRlcigpO1xuICAgICAgICAgICAgLy8gV2F0Y2ggZm9yIHVwZGF0ZXMgZnJvbSBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBmaWx0ZXJBbmRTdWJzU3VicHJvdmlkZXIub24oJ2RhdGEnLCAoXywgbm90aWZpY2F0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2Uobm90aWZpY2F0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5hZGRQcm92aWRlcihmaWx0ZXJBbmRTdWJzU3VicHJvdmlkZXIpO1xuICAgICAgICAgICAgaWYgKGVuYWJsZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVib3VuY2VzIGR1cGxpY2F0ZSByZXF1ZXN0cyB0aGF0IG9jY3VyIGF0IHRoZSBzYW1lIHRpbWVcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFByb3ZpZGVyKG5ldyBwcm92aWRlcl9lbmdpbmVfMS5JbmZsaWdodENhY2hlU3VicHJvdmlkZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwcG9ydHNTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvbGxGb3JCbG9ja3M7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlKHN1YnNjcmliZU1ldGhvZCA9ICdldGhfc3Vic2NyaWJlJywgc3Vic2NyaXB0aW9uTWV0aG9kLCBwYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BvbGxGb3JCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocHJvdmlkZXJfZXJyb3JfMS5Qcm92aWRlckVycm9yLlN1YnNjcmlwdGlvbnNVbmF2YWlsYWJsZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtZXRlcnMudW5zaGlmdChzdWJzY3JpcHRpb25NZXRob2QpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChzdWJzY3JpYmVNZXRob2QsIHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHVuc3Vic2NyaWJlKHN1YnNjcmlwdGlvbklkLCB1bnN1YnNjcmliZU1ldGhvZCA9ICdldGhfdW5zdWJzY3JpYmUnKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3BvbGxGb3JCbG9ja3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocHJvdmlkZXJfZXJyb3JfMS5Qcm92aWRlckVycm9yLlN1YnNjcmlwdGlvbnNVbmF2YWlsYWJsZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmQodW5zdWJzY3JpYmVNZXRob2QsIFtzdWJzY3JpcHRpb25JZF0pLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoc3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBvbk1lc3NhZ2Uobm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgICAvLyBSZS1lbWl0IChwcmV2aW91cyBiZWhhdmlvciB+IHdlYjMgMS4wLjAtYmV0YS4zNylcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG51bGwsIG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICBpZiAobm90aWZpY2F0aW9uICYmIG5vdGlmaWNhdGlvbi5wYXJhbXMgJiYgbm90aWZpY2F0aW9uLnBhcmFtcy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBDdXJyZW50IHdlYjMgYmVoYXZpb3IgLSBlbWl0IHN1YnNjcmlwdGlvbiBpZFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQobm90aWZpY2F0aW9uLnBhcmFtcy5zdWJzY3JpcHRpb24sIG5vdGlmaWNhdGlvbi5wYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuQml0c2tpRW5naW5lID0gQml0c2tpRW5naW5lO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaXRza2ktZW5naW5lLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICAvLyBKU09OLVJQQyBtZXRob2RzIHRoYXQgcmVxdWlyZSBBdXRob3JpemF0aW9uIGhlYWRlclxuICAgIGV4cG9ydHMuQVVUSEVOVElDQVRFRF9NRVRIT0RTID0gW1xuICAgICAgICAnZXRoX2FjY291bnRzJyxcbiAgICAgICAgJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICAnZXRoX3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgICdldGhfc2lnblR5cGVkRGF0YScsXG4gICAgICAgICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgJ2V0aF9zaWduJyxcbiAgICBdO1xuICAgIC8vIEVycm9yIG1lc3NhZ2VzIHRoYXQgYXJlIHVzdWFsbHkgdHJhbnNpZW50IGFuZCBzaG91bGQgYmUgcmV0cmllZFxuICAgIGV4cG9ydHMuUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAgICAgLy8gaWdub3JlIHNlcnZlciBvdmVybG9hZCBlcnJvcnNcbiAgICAgICAgJ0dhdGV3YXkgdGltZW91dCcsXG4gICAgICAgICdFVElNRURPVVQnLFxuICAgICAgICAnRU5PVEZPVU5EJyxcbiAgICAgICAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgICAgICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgICdFQ09OTlJFU0VUJyxcbiAgICAgICAgJ0VIT1NUVU5SRUFDSCcsXG4gICAgICAgICdUaW1lb3V0IG91dCB3aGlsZSB3YWl0aW5nIGZvciByZXNwb25zZScsXG4gICAgXTtcbiAgICAvLyBFcnJvcnMgdGhhdCBpbmRpY2F0ZSB0aGUgYWNjZXNzIHRva2VuIGlzIG5vdCB2YWxpZFxuICAgIGV4cG9ydHMuVU5BVVRIT1JJWkVEX0VSUk9SUyA9IFtcbiAgICAgICAgJ01pc3NpbmcgYXV0aCcsXG4gICAgICAgICdJbnZhbGlkIGNsaWVudCBpZCcsXG4gICAgICAgICdOb3QgQXV0aG9yaXplZCcsXG4gICAgXTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICB2YXIgUHJvdmlkZXJFcnJvckNvZGU7XG4gICAgKGZ1bmN0aW9uIChQcm92aWRlckVycm9yQ29kZSkge1xuICAgICAgICAvLyBUaHJvd24gd2hlbiBhY2Nlc3Npbmcgc3Vic2NyaXB0aW9uIGZlYXR1cmVzIHdoZW4gdGhleSBhcmUgZGlzYWJsZWQuXG4gICAgICAgIFByb3ZpZGVyRXJyb3JDb2RlW1Byb3ZpZGVyRXJyb3JDb2RlW1wiU3Vic2NyaXB0aW9uc1VuYXZhaWxhYmxlXCJdID0gNDAwMF0gPSBcIlN1YnNjcmlwdGlvbnNVbmF2YWlsYWJsZVwiO1xuICAgICAgICAvLyBUaHJvd24gd2hlbiByZXF1ZXN0IGlzIG1pc3NpbmcgcmVxdWlyZWQgcGFyYW1zIG9yIGRhdGFcbiAgICAgICAgUHJvdmlkZXJFcnJvckNvZGVbUHJvdmlkZXJFcnJvckNvZGVbXCJJbnZhbGlkUmVxdWVzdFwiXSA9IDQwMDFdID0gXCJJbnZhbGlkUmVxdWVzdFwiO1xuICAgIH0pKFByb3ZpZGVyRXJyb3JDb2RlID0gZXhwb3J0cy5Qcm92aWRlckVycm9yQ29kZSB8fCAoZXhwb3J0cy5Qcm92aWRlckVycm9yQ29kZSA9IHt9KSk7XG4gICAgY2xhc3MgUHJvdmlkZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSAnUHJvdmlkZXJFcnJvcic7XG4gICAgICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgUHJvdmlkZXJFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBTdWJzY3JpcHRpb25zVW5hdmFpbGFibGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3ZpZGVyRXJyb3IoJ1N1YnNjcmlwdGlvbnMgYXJlIGRpc2FibGVkLiBFbmFibGUgYmxvY2sgcG9sbGluZyB0byB1c2UgdGhpcyBmZWF0dXJlLicsIFByb3ZpZGVyRXJyb3JDb2RlLlN1YnNjcmlwdGlvbnNVbmF2YWlsYWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIEludmFsaWRSZXF1ZXN0KHJlYXNvbikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm92aWRlckVycm9yKGBJbnZhbGlkIHJlcXVlc3Q6ICR7cmVhc29ufWAsIFByb3ZpZGVyRXJyb3JDb2RlLkludmFsaWRSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLlByb3ZpZGVyRXJyb3IgPSBQcm92aWRlckVycm9yO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlci1lcnJvci5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhbiBlcnJvciB0aGF0IGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlclxuICAgICAqIFlvdSBjYW4gYWNjZXNzIHRoZSByZXNwb25zZSBjb2RlIHZpYSB0aGUgY29kZSBwcm9wZXJ0eSwgYW5kIHRoZSBVUkkgZnJvbSB0aGUgcmVxdWVzdFVSSSBwcm9wZXJ0eS5cbiAgICAgKiBUaGUgcmV0cmllZCBwcm9wZXJ0eSB3aWxsIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSByZXF1ZXN0IGZhaWxlZCBhZnRlciBtdWx0aXBsZSB0cmllcy5cbiAgICAgKi9cbiAgICBjbGFzcyBTZXJ2ZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICAgICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSwgcmVxdWVzdFVSSSwgcmV0cmllZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9ICdTZXJ2ZXJFcnJvcic7XG4gICAgICAgICAgICAvLyBNYWludGFpbnMgcHJvcGVyIHN0YWNrIHRyYWNlIGZvciB3aGVyZSBvdXIgZXJyb3Igd2FzIHRocm93biAob25seSBhdmFpbGFibGUgb24gVjgpXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgU2VydmVyRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdFVSSSA9IHJlcXVlc3RVUkk7XG4gICAgICAgICAgICB0aGlzLnJldHJpZWQgPSByZXRyaWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuU2VydmVyRXJyb3IgPSBTZXJ2ZXJFcnJvcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmVyLWVycm9yLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiLi9iaXRza2ktZW5naW5lXCIsIFwiLi9hdXRoL2FjY2Vzcy10b2tlblwiLCBcIi4vc3VicHJvdmlkZXJzL2F1dGhlbnRpY2F0ZWQtZmV0Y2hcIiwgXCIuL25ldHdvcmtcIiwgXCIuL2Vycm9ycy9zZXJ2ZXItZXJyb3JcIiwgXCIuL2Vycm9ycy9wcm92aWRlci1lcnJvclwiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgdmFyIGJpdHNraV9lbmdpbmVfMSA9IHJlcXVpcmUoXCIuL2JpdHNraS1lbmdpbmVcIik7XG4gICAgZXhwb3J0cy5CaXRza2lFbmdpbmUgPSBiaXRza2lfZW5naW5lXzEuQml0c2tpRW5naW5lO1xuICAgIHZhciBhY2Nlc3NfdG9rZW5fMSA9IHJlcXVpcmUoXCIuL2F1dGgvYWNjZXNzLXRva2VuXCIpO1xuICAgIGV4cG9ydHMuQWNjZXNzVG9rZW4gPSBhY2Nlc3NfdG9rZW5fMS5BY2Nlc3NUb2tlbjtcbiAgICB2YXIgYXV0aGVudGljYXRlZF9mZXRjaF8xID0gcmVxdWlyZShcIi4vc3VicHJvdmlkZXJzL2F1dGhlbnRpY2F0ZWQtZmV0Y2hcIik7XG4gICAgZXhwb3J0cy5BdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlciA9IGF1dGhlbnRpY2F0ZWRfZmV0Y2hfMS5BdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlcjtcbiAgICB2YXIgbmV0d29ya18xID0gcmVxdWlyZShcIi4vbmV0d29ya1wiKTtcbiAgICBleHBvcnRzLk1haW5uZXQgPSBuZXR3b3JrXzEuTWFpbm5ldDtcbiAgICBleHBvcnRzLlJpbmtlYnkgPSBuZXR3b3JrXzEuUmlua2VieTtcbiAgICBleHBvcnRzLktvdmFuID0gbmV0d29ya18xLktvdmFuO1xuICAgIHZhciBzZXJ2ZXJfZXJyb3JfMSA9IHJlcXVpcmUoXCIuL2Vycm9ycy9zZXJ2ZXItZXJyb3JcIik7XG4gICAgZXhwb3J0cy5TZXJ2ZXJFcnJvciA9IHNlcnZlcl9lcnJvcl8xLlNlcnZlckVycm9yO1xuICAgIHZhciBwcm92aWRlcl9lcnJvcl8xID0gcmVxdWlyZShcIi4vZXJyb3JzL3Byb3ZpZGVyLWVycm9yXCIpO1xuICAgIGV4cG9ydHMuUHJvdmlkZXJFcnJvciA9IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvcjtcbiAgICBleHBvcnRzLlByb3ZpZGVyRXJyb3JDb2RlID0gcHJvdmlkZXJfZXJyb3JfMS5Qcm92aWRlckVycm9yQ29kZTtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHZhciB2ID0gZmFjdG9yeShyZXF1aXJlLCBleHBvcnRzKTtcbiAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgbW9kdWxlLmV4cG9ydHMgPSB2O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoW1wicmVxdWlyZVwiLCBcImV4cG9ydHNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGV4cG9ydHMuTWFpbm5ldCA9IHtcbiAgICAgICAgY2hhaW5JZDogMSxcbiAgICAgICAgcnBjVXJsOiAnaHR0cHM6Ly9hcGkuYml0c2tpLmNvbS92MS93ZWIzL21haW5uZXQnLFxuICAgIH07XG4gICAgZXhwb3J0cy5SaW5rZWJ5ID0ge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBycGNVcmw6ICdodHRwczovL2FwaS5iaXRza2kuY29tL3YxL3dlYjMvcmlua2VieScsXG4gICAgfTtcbiAgICBleHBvcnRzLktvdmFuID0ge1xuICAgICAgICBjaGFpbklkOiA0MixcbiAgICAgICAgcnBjVXJsOiAnaHR0cHM6Ly9hcGkuYml0c2tpLmNvbS92MS93ZWIzL2tvdmFuJyxcbiAgICB9O1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXR3b3JrLmpzLm1hcCIsInZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIiwgXCJhc3luYy9yZXRyeVwiLCBcIi4uL2NvbnN0YW50c1wiLCBcIi4uL2Vycm9ycy9zZXJ2ZXItZXJyb3JcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyX2VuZ2luZV8xID0gcmVxdWlyZShcIkBiaXRza2kvcHJvdmlkZXItZW5naW5lXCIpO1xuICAgIGNvbnN0IHJldHJ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImFzeW5jL3JldHJ5XCIpKTtcbiAgICBjb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG4gICAgY29uc3Qgc2VydmVyX2Vycm9yXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzL3NlcnZlci1lcnJvclwiKTtcbiAgICAvKlxuICAgICAqIFN1YnByb3ZpZGVyIHRoYXQgZmV0Y2hlcyBvdmVyIEhUVFAgYW5kIG1hbmFnZXMgYXV0aGVudGljYXRpb24gaGVhZGVyc1xuICAgICAqL1xuICAgIGNsYXNzIEF1dGhlbnRpY2F0ZWRGZXRjaFN1YnByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfZW5naW5lXzEuRmV0Y2hTdWJwcm92aWRlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHJwY1VybCwgZGVidWcsIGFjY2Vzc1Rva2VuUHJvdmlkZXIsIGRlZmF1bHRIZWFkZXJzID0ge30pIHtcbiAgICAgICAgICAgIHN1cGVyKHsgcnBjVXJsIH0pO1xuICAgICAgICAgICAgdGhpcy5hdXRoZW50aWNhdGVkTWV0aG9kcyA9IGNvbnN0YW50c18xLkFVVEhFTlRJQ0FURURfTUVUSE9EUztcbiAgICAgICAgICAgIHRoaXMuYWNjZXNzVG9rZW5Qcm92aWRlciA9IGFjY2Vzc1Rva2VuUHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRIZWFkZXJzID0gZGVmYXVsdEhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVpcmVzQXV0aGVudGljYXRpb24ocGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVBdXRoZW50aWNhdGVkUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUF1dGhlbnRpY2F0ZWRSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgICAgICAgICAgdGhpcy5hY2Nlc3NUb2tlblByb3ZpZGVyLmdldEFjY2Vzc1Rva2VuKCkudGhlbigoYWNjZXNzVG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdGhpcy5nZW5lcmF0ZVBhcmFtZXRlcnMocGF5bG9hZCwgYWNjZXNzVG9rZW4pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHBhcmFtZXRlcnMsIG5leHQsIGVuZCk7XG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICBlbmQoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlVW5hdXRoZW50aWNhdGVkUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0aGlzLmdlbmVyYXRlUGFyYW1ldGVycyhwYXlsb2FkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHBhcmFtZXRlcnMsIG5leHQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWlyZXNBdXRoZW50aWNhdGlvbihwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdXRoZW50aWNhdGVkTWV0aG9kcy5zb21lKChtZXRob2QpID0+IG1ldGhvZCA9PT0gcGF5bG9hZC5tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGdlbmVyYXRlUGFyYW1ldGVycyhwYXlsb2FkLCBhY2Nlc3NUb2tlbikge1xuICAgICAgICAgICAgLy8gb3ZlcndyaXRlIGlkIHRvIG5vdCBjb25mbGljdCB3aXRoIG90aGVyIGNvbmN1cnJlbnQgdXNlcnNcbiAgICAgICAgICAgIGNvbnN0IG5ld1BheWxvYWQgPSB0aGlzLmNyZWF0ZVBheWxvYWQocGF5bG9hZCk7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXh0cmEgcGFyYW1ldGVyIGZyb20gcmVxdWVzdFxuICAgICAgICAgICAgZGVsZXRlIG5ld1BheWxvYWQub3JpZ2luO1xuICAgICAgICAgICAgbGV0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzLCB0aGlzLmRlZmF1bHRIZWFkZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHBheWxvYWQub3JpZ2luO1xuICAgICAgICAgICAgaWYgKHRoaXMub3JpZ2luSHR0cEhlYWRlcktleSAmJiBvcmlnaW5Eb21haW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW3RoaXMub3JpZ2luSHR0cEhlYWRlcktleV0gPSBvcmlnaW5Eb21haW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWNjZXNzVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7YWNjZXNzVG9rZW59YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RQYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5ld1BheWxvYWQpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RQYXJhbWV0ZXJzO1xuICAgICAgICB9XG4gICAgICAgIHNlbmRSZXF1ZXN0KHBhcmFtZXRlcnMsIG5leHQsIGVuZCkge1xuICAgICAgICAgICAgcmV0cnlfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgICAgICBlcnJvckZpbHRlcjogdGhpcy5pc0Vycm9yUmV0cmlhYmxlLFxuICAgICAgICAgICAgICAgIGludGVydmFsOiAxMDAwLFxuICAgICAgICAgICAgICAgIHRpbWVzOiA1LFxuICAgICAgICAgICAgfSwgKGNiKSA9PiB0aGlzLl9zdWJtaXRSZXF1ZXN0KHBhcmFtZXRlcnMsIGNiKSwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gZW5kcyBvbiByZXRyaWFibGUgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIHRoaXMuaXNFcnJvclJldHJpYWJsZShlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJpZXNFeGhhdXN0ZWRFcnIgPSBuZXcgc2VydmVyX2Vycm9yXzEuU2VydmVyRXJyb3IoZXJyLm1lc3NhZ2UsIDIwMCwgdGhpcy5ycGNVcmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kKHJldHJpZXNFeGhhdXN0ZWRFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIHRoaXMuaXNVbmF1dGhvcml6ZWRFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFjY2Vzc1Rva2VuUHJvdmlkZXIuaW52YWxpZGF0ZVRva2VuKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY29udGludWUgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVyciwgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlzRXJyb3JSZXRyaWFibGUoZXJyKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBjb25zdGFudHNfMS5SRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlzVW5hdXRob3JpemVkRXJyb3IoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc3RhbnRzXzEuVU5BVVRIT1JJWkVEX0VSUk9SUy5zb21lKChwaHJhc2UpID0+IGVyci5tZXNzYWdlLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuQXV0aGVudGljYXRlZEZldGNoU3VicHJvdmlkZXIgPSBBdXRoZW50aWNhdGVkRmV0Y2hTdWJwcm92aWRlcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXV0aGVudGljYXRlZC1mZXRjaC5qcy5tYXAiLCIoZnVuY3Rpb24gKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdmFyIHYgPSBmYWN0b3J5KHJlcXVpcmUsIGV4cG9ydHMpO1xuICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSBtb2R1bGUuZXhwb3J0cyA9IHY7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShbXCJyZXF1aXJlXCIsIFwiZXhwb3J0c1wiLCBcIkBiaXRza2kvcHJvdmlkZXItZW5naW5lXCJdLCBmYWN0b3J5KTtcbiAgICB9XG59KShmdW5jdGlvbiAocmVxdWlyZSwgZXhwb3J0cykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgICBjb25zdCBwcm92aWRlcl9lbmdpbmVfMSA9IHJlcXVpcmUoXCJAYml0c2tpL3Byb3ZpZGVyLWVuZ2luZVwiKTtcbiAgICAvKipcbiAgICAgKiBBIHN1YnByb3ZpZGVyIHRoYXQgdHJhY2tzIGFuZCBhdXRvbWF0aWNhbGx5IGluY3JlbWVudHMgdGhlIG5vbmNlIG9uIHRoZSBjbGllbnQuXG4gICAgICogSGVhdmlseSBiYXNlZCBvbiB0aGUgcHJvdmlkZXItZW5naW5lIE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyLCBidXQgbW9kaWZpZWQgZm9yXG4gICAgICogQml0c2tpJ3MgdHJhbnNhY3Rpb24gZmxvdy5cbiAgICAgKi9cbiAgICBjbGFzcyBOb25jZVRyYWNrZXJTdWJwcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2VuZ2luZV8xLlN1YnByb3ZpZGVyIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgdGhpcy5ub25jZUNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVJlcXVlc3QocGF5bG9hZCwgbmV4dCwgZW5kKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVRyYW5zYWN0aW9uQ291bnRSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVTZW5kVHJhbnNhY3Rpb25SZXF1ZXN0KHBheWxvYWQsIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCByZXN1bHQgaWYgcHJlc2VudFxuICAgICAgICBoYW5kbGVUcmFuc2FjdGlvbkNvdW50UmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrVGFnID0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoID4gMSA/IHBheWxvYWQucGFyYW1zWzFdIDogbnVsbDtcbiAgICAgICAgICAgIC8vIE9ubHkgaGFuZGxlIHBlbmRpbmcgdGFnXG4gICAgICAgICAgICBpZiAoYmxvY2tUYWcgIT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IHRoaXMubm9uY2VDYWNoZS5nZXQoYWRkcmVzcyk7XG4gICAgICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIHJlc3VsdCBpdCB3ZSBoYXZlIGl0XG4gICAgICAgICAgICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgZW5kKG51bGwsIGNhY2hlZFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbHRocm91Z2ggYW5kIHBvcHVsYXRlIGNhY2hlXG4gICAgICAgICAgICBuZXh0KChlcnIsIHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vbmNlQ2FjaGUuc2V0KGFkZHJlc3MsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0b0hleChudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2UxNiA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICBsZXQgaGV4ID0gYmFzZTE2O1xuICAgICAgICAgICAgaWYgKGJhc2UxNi5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaGV4ID0gJzAnICsgYmFzZTE2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcweCcgKyBoZXg7XG4gICAgICAgIH1cbiAgICAgICAgZnJvbUhleChzdHIpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludChzdHIsIDE2KTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0Tm9uY2Uobm9uY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Ym1pdHRlZE5vbmNlID0gdGhpcy5mcm9tSGV4KG5vbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHROb25jZSA9IHN1Ym1pdHRlZE5vbmNlICsgMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KG5leHROb25jZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IG5leHQgbm9uY2UgZm9yIGFkZHJlc3NcbiAgICAgICAgaGFuZGxlU2VuZFRyYW5zYWN0aW9uUmVxdWVzdChwYXlsb2FkLCBuZXh0KSB7XG4gICAgICAgICAgICAvLyBTdWJtaXQgdGhlIHJlcXVlc3QsIHRoZW4gbW9uaXRvciB0aGUgcmVzdWx0XG4gICAgICAgICAgICBuZXh0KChlcnIsIHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHBheWxvYWQucGFyYW1zLmxlbmd0aCA+IDAgPyBwYXlsb2FkLnBhcmFtc1swXSA6IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1pdHRlZE5vbmNlID0gdHJhbnNhY3Rpb24ubm9uY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHRyYW5zYWN0aW9uLmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Ym1pdHRlZE5vbmNlICYmIGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluY3JlbWVudCBub25jZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE5vbmNlID0gdGhpcy5uZXh0Tm9uY2Uoc3VibWl0dGVkTm9uY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ub25jZUNhY2hlLnNldChhZGRyZXNzLCBuZXh0Tm9uY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgY2FjaGVkIHZhbHVlIGlmIHdlIGVuY291bnRlciBhbiBlcnJvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vbmNlQ2FjaGUuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5Ob25jZVRyYWNrZXJTdWJwcm92aWRlciA9IE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub25jZS10cmFja2VyLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IHByb3ZpZGVyX2VuZ2luZV8xID0gcmVxdWlyZShcIkBiaXRza2kvcHJvdmlkZXItZW5naW5lXCIpO1xuICAgIC8qKlxuICAgICAqIEEgc3VicHJvdmlkZXIgdGhhdCBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlcyBtaXNzaW5nIHRyYW5zYWN0aW9uIGRldGFpbHMuXG4gICAgICogVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBpdCBoYXMgYmVjb21lIGNvbW1vbiB0byBzdWJtaXQgdHJhbnNhY3Rpb25zIHdpdGhcbiAgICAgKiBvbmx5IHNvbWUgb2YgdGhlIHBhcmFtZXRlcnMgYW5kIHJlbHkgb24gdGhlIHByb3ZpZGVyIG9yIG5vZGUgdG8gZmlsbCBpbiB0aGUgcmVzdC5cbiAgICAgKi9cbiAgICBjbGFzcyBUcmFuc2FjdGlvblZhbGlkYXRvclN1YnByb3ZpZGVyIGV4dGVuZHMgcHJvdmlkZXJfZW5naW5lXzEuU3VicHJvdmlkZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcihtaW5HYXNQcmljZSA9IDApIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLm1pbkdhc1ByaWNlID0gbWluR2FzUHJpY2U7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBfKSB7XG4gICAgICAgICAgICAvLyBPbmx5IGhhbmRsZSB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHx8IHBheWxvYWQubWV0aG9kID09PSAnZXRoX3NpZ25UcmFuc2FjdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25GaWVsZHMocGF5bG9hZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBheWxvYWQgd2FzIG1vZGlmaWVkLiBDb250aW51ZS5cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoIGlmIHdlIGNhbm5vdCBwb3B1bGF0ZSBmaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEV4YW1pbmUgdHJhbnNhY3Rpb24gYW5kIHBvcHVsYXRlIG1pc3NpbmcgcGFyYW1zXG4gICAgICAgIGFzeW5jIHBvcHVsYXRlVHJhbnNhY3Rpb25GaWVsZHMocGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gcGF5bG9hZC5wYXJhbXMgfHwgW107XG4gICAgICAgICAgICBsZXQgdHJhbnNhY3Rpb24gPSB7fTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gcGFyYW1zWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZnJvbSB3aXRoIGRlZmF1bHQgYWNjb3VudFxuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZyb20gPSBhY2NvdW50c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXNQcmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmVzdGltYXRlR2FzUHJpY2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKHRyYW5zYWN0aW9uLmdhc1ByaWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3Npbmcgbm9uY2VcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmdldE5vbmNlKHRyYW5zYWN0aW9uLmZyb20pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godHJhbnNhY3Rpb24ubm9uY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUG9wdWxhdGUgbWlzc2luZyBnYXNcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2godGhpcy5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0cmFuc2FjdGlvbi5nYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRXhlY3V0ZSBwcm9taXNlc1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHBhcmFtZXRlcnMgd2l0aCBsb2FkZWQgdmFsdWVzLiBNdXN0IGJlIHZlcnkgY2FyZWZ1bCB3aXRoIHRoZSBpbmRleGVzIGhlcmUuXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNQcmljZSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gdmFsdWVzWzFdO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gdmFsdWVzWzJdO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBwYXJhbXMgb24gdGhlIHBheWxvYWRcbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzBdID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBnZXROb25jZShhZGRyZXNzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFthZGRyZXNzLCAnbGF0ZXN0J10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVJlcXVlc3QocmVxdWVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgYXN5bmMgZ2V0QWNjb3VudHMoKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIGlkOiAwLFxuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9hY2NvdW50cycsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZXN0aW1hdGVHYXMnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW3RyYW5zYWN0aW9uXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBhc3luYyBlc3RpbWF0ZUdhc1ByaWNlKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBpZDogMCxcbiAgICAgICAgICAgICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2FzUHJpY2UnLFxuICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGVyZm9ybVJlcXVlc3QocmVxdWVzdCkudGhlbigoZ2FzUHJpY2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2FzUHJpY2UgPT09ICcweDAnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgMHgke3RoaXMubWluR2FzUHJpY2UudG9TdHJpbmcoMTYpfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBnYXNQcmljZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdyYXBzIGVtaXRQYXlsb2FkIGluIGEgcHJvbWlzZVxuICAgICAgICBwZXJmb3JtUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bGZpbGwsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdFBheWxvYWQocGF5bG9hZCwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVsZmlsbChyZXN1bHQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhwb3J0cy5UcmFuc2FjdGlvblZhbGlkYXRvclN1YnByb3ZpZGVyID0gVHJhbnNhY3Rpb25WYWxpZGF0b3JTdWJwcm92aWRlcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24tdmFsaWRhdG9yLmpzLm1hcCIsIihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIiwgXCIuLi9lcnJvcnMvcHJvdmlkZXItZXJyb3JcIiwgXCIuLi91dGlscy9wYXJzZS11dGlsc1wiXSwgZmFjdG9yeSk7XG4gICAgfVxufSkoZnVuY3Rpb24gKHJlcXVpcmUsIGV4cG9ydHMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4gICAgY29uc3QgcHJvdmlkZXJfZW5naW5lXzEgPSByZXF1aXJlKFwiQGJpdHNraS9wcm92aWRlci1lbmdpbmVcIik7XG4gICAgY29uc3QgcHJvdmlkZXJfZXJyb3JfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnMvcHJvdmlkZXItZXJyb3JcIik7XG4gICAgY29uc3QgcGFyc2VfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9wYXJzZS11dGlsc1wiKTtcbiAgICBjbGFzcyBUeXBlZERhdGFTYW5pdGl6ZXJTdWJwcm92aWRlciBleHRlbmRzIHByb3ZpZGVyX2VuZ2luZV8xLlN1YnByb3ZpZGVyIHtcbiAgICAgICAgaGFuZGxlUmVxdWVzdChwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zaWduVHlwZWREYXRhJyB8fCBwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9zaWduVHlwZWREYXRhX3YzJykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2FuaXRpemVQYXlsb2FkKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbmQoZXJyLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBzYW5pdGl6ZVBheWxvYWQocGF5bG9hZCkge1xuICAgICAgICAgICAgY29uc3QgdHlwZWREYXRhID0gdGhpcy5leHRyYWN0VHlwZWREYXRhKHBheWxvYWQpO1xuICAgICAgICAgICAgLy8gY3JlYXRlIG1hcCBvZiB0eXBlc1xuICAgICAgICAgICAgY29uc3QgdHlwZU1hcHBpbmcgPSBjcmVhdGVUeXBlTWFwcGluZyh0eXBlZERhdGEpO1xuICAgICAgICAgICAgLy8gc2FuaXRpemUgZG9tYWluXG4gICAgICAgICAgICBzYW5pdGl6ZURvbWFpbih0eXBlZERhdGEsIHR5cGVNYXBwaW5nKTtcbiAgICAgICAgICAgIC8vIHNhbml0aXplIG1lc3NhZ2VcbiAgICAgICAgICAgIHNhbml0aXplTWVzc2FnZSh0eXBlZERhdGEsIHR5cGVNYXBwaW5nKTtcbiAgICAgICAgICAgIC8vIFJlLWFzc2lnbiB0eXBlZCBkYXRhIHRvIHBhcmFtcyBpbiBjYXNlIGl0IGhhcyBiZWVuIHBhcnNlZFxuICAgICAgICAgICAgLy8gZnJvbSBhIHN0cmluZy5cbiAgICAgICAgICAgIHBheWxvYWQucGFyYW1zWzFdID0gdHlwZWREYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdpdmVuIGEgSlNPTi1SUEMgcmVxdWVzdCwgZXh0cmFjdCB0aGUgdHlwZWQgZGF0YSBmcm9tIHRoZSBwYXJhbXNcbiAgICAgICAgZXh0cmFjdFR5cGVkRGF0YShwYXlsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXBheWxvYWQucGFyYW1zIHx8IHBheWxvYWQucGFyYW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBwcm92aWRlcl9lcnJvcl8xLlByb3ZpZGVyRXJyb3IuSW52YWxpZFJlcXVlc3QoJ01pc3NpbmcgcGFyYW1zIGZvciB0eXBlZCBkYXRhJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIGltcGxlbWVudGF0aW9ucyBwYXNzIHR5cGVkIGRhdGEgYXMgYSBzdHJpbmdcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC5wYXJhbXNbMV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocGF5bG9hZC5wYXJhbXNbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQucGFyYW1zWzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4cG9ydHMuVHlwZWREYXRhU2FuaXRpemVyU3VicHJvdmlkZXIgPSBUeXBlZERhdGFTYW5pdGl6ZXJTdWJwcm92aWRlcjtcbiAgICAvKipcbiAgICAgKiBTYW5pdGl6ZXMgdGhlIGBkb21haW5gIHZhbHVlcyBmcm9tIHRoZSBUeXBlZERhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEgVHlwZWREYXRhIHBheWxvYWRcbiAgICAgKiBAcGFyYW0gdHlwZU1hcHBpbmcgYSBUeXBlTWFwcGluZyBwcmUtZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVkRGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplRG9tYWluKHR5cGVkRGF0YSwgdHlwZU1hcHBpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlZERhdGEuZG9tYWluID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgcHJvdmlkZXJfZXJyb3JfMS5Qcm92aWRlckVycm9yLkludmFsaWRSZXF1ZXN0KCdNaXNzaW5nIGRvbWFpbiBmb3IgdHlwZWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZWREYXRhLnR5cGVzLkVJUDcxMkRvbWFpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvci5JbnZhbGlkUmVxdWVzdCgnTWlzc2luZyB0eXBlIGRlZmluaXRpb24gZm9yIGRvbWFpbicpO1xuICAgICAgICB9XG4gICAgICAgIHNhbml0aXplVHlwZSgnRUlQNzEyRG9tYWluJywgdHlwZWREYXRhLmRvbWFpbiwgdHlwZU1hcHBpbmcpO1xuICAgIH1cbiAgICBleHBvcnRzLnNhbml0aXplRG9tYWluID0gc2FuaXRpemVEb21haW47XG4gICAgLyoqXG4gICAgICogU2FuaXRpemVzIHRoZSBgbWVzc2FnZWAgdmFsdWVzIGZyb20gdGhlIFR5cGVkRGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGVkRGF0YSBUeXBlZERhdGEgcGF5bG9hZFxuICAgICAqIEBwYXJhbSB0eXBlTWFwcGluZyBhIFR5cGVNYXBwaW5nIHByZS1nZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZWREYXRhXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2FuaXRpemVNZXNzYWdlKHR5cGVkRGF0YSwgdHlwZU1hcHBpbmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlZERhdGEubWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvci5JbnZhbGlkUmVxdWVzdCgnTWlzc2luZyBtZXNzYWdlIGluIHR5cGVkIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGVkRGF0YS5wcmltYXJ5VHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IHByb3ZpZGVyX2Vycm9yXzEuUHJvdmlkZXJFcnJvci5JbnZhbGlkUmVxdWVzdCgnTWlzc2luZyBwcmltYXJ5IHR5cGUgaW4gdHlwZWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIHNhbml0aXplVHlwZSh0eXBlZERhdGEucHJpbWFyeVR5cGUsIHR5cGVkRGF0YS5tZXNzYWdlLCB0eXBlTWFwcGluZyk7XG4gICAgfVxuICAgIGV4cG9ydHMuc2FuaXRpemVNZXNzYWdlID0gc2FuaXRpemVNZXNzYWdlO1xuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGV4YW1pbmVzIGVhY2ggdmFsdWUgYW5kIGRldGVybWluZXMgdHlwZSBmcm9tIHRoZSB0eXBlIG1hcHBpbmcgdG9cbiAgICAgKiBmb3JtYXQgYW5kIHNhbml0aXplIHRoZSB2YWx1ZSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBDdXJyZW50bHkgdGhpcyB3aWxsIG9ubHkgY29udmVydCBudW1iZXIgdmFsdWVzIGludG8gYSBjb25zaXN0ZW50IGhleCBmb3JtYXQsXG4gICAgICogYnV0IGluIHRoZSBmdXR1cmUgYWRkaXRpb25hbCB0cmFuc2Zvcm1hdGlvbnMgbWF5IGJlIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlTmFtZSBOYW1lIG9mIHRoZSB0eXBlIHdlIGFyZSBzdGFydGluZyBmcm9tXG4gICAgICogQHBhcmFtIHZhbHVlcyBUaGUgcm9vdCBvYmplY3QgY29udGFpbmluZyB0aGUga2V5cyBhbmQgdmFsdWVzXG4gICAgICogQHBhcmFtIHR5cGVNYXBwaW5nIFRoZSB0eXBlIG1hcHBpbmcgdGhhdCByZXByZXNlbnRzIHRoaXMgZGF0YVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbml0aXplVHlwZSh0eXBlTmFtZSwgdmFsdWVzLCB0eXBlTWFwcGluZykge1xuICAgICAgICAvLyBGb3IgZWFjaCBrZXkgaW4gdGhlICd2YWx1ZXMnIG9iamVjdC4uLlxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgdHlwZSBuYW1lIGFzc29jaWF0ZWQgZnJvbSB0aGUgbWFwcGluZ1xuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVNYXBwaW5nW3R5cGVOYW1lXVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcgaWYgd2UgZG9uJ3QgaGF2ZSBhIHR5cGUgZm9yIHRoaXMga2V5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgYmFzZSB0eXBlIChsZWZ0IHNpZGUgb2YgdGhlIGJyYWNrZXRzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VUeXBlID0gdHlwZS5zcGxpdCgnWycpWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWVzW2tleV0ubGVuZ3RoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDb3VsZCBub3QgcGFyc2UgJHt2YWx1ZXNba2V5XX0gZm9yIHR5cGUgJHt0eXBlfS4gRXhwZWN0ZWQgYXJyYXkuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIGJhc2UgdHlwZSBpcyBhIHN0cnVjdCwgaXRlcmF0ZSB0aHJvdWdoIGVhY2ggaW5zdGFuY2Ugb2Ygc3RydWN0XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVNYXBwaW5nW2Jhc2VUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB2YWx1ZXNba2V5XSBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheSwgd2hlcmUgZWFjaCBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHN0cnVjdCBuYW1lZCBiYXNlVHlwZS5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0uZm9yRWFjaCgoaXRlbVZhbHVlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FuaXRpemVUeXBlKGJhc2VUeXBlLCBpdGVtVmFsdWVzLCB0eXBlTWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChiYXNlVHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgYmFzZVR5cGUuc3RhcnRzV2l0aCgnaW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhcnJheSBvZiBwcmltaXRpdmUgdHlwZXMgdGhhdCBhcmUgbnVtYmVycywgd2UgbmVlZCB0byBlbmNvZGUgdGhlIG51bWJlcnMgYXMgaGV4XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bWJlclZhbHVlcyA9IHZhbHVlc1trZXldLm1hcCgobnVtYmVyVmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZV91dGlsc18xLmVuY29kZU51bWJlcihudW1iZXJWYWx1ZSwgYmFzZVR5cGUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSBudW1iZXJWYWx1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIHdpdGggcmVndWxhciBhcnJheSB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaW50OFtdLCBldGMgc2hvdWxkIGFscmVhZHkgYmUgc3RyaW5nc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVNYXBwaW5nW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdHlwZSBuYW1lIGlzIGEgY3VzdG9tIHN0cnVjdCwgaXQgc2hvdWxkIGxpdmUgaW4gdGhlIHR5cGUgbWFwcGluZ1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gcmVjdXJzaXZlbHkgY2hlY2sgdGhlIGN1c3RvbSB0eXBlcyB1bnRpbCB3ZSBnZXQgdG8gcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICAgICAgIHNhbml0aXplVHlwZSh0eXBlLCB2YWx1ZXNba2V5XSwgdHlwZU1hcHBpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCd1aW50JykgfHwgdHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmFsbHksIGlmIHdlIGhhdmUgYSBwcmltaXRpdmUgdHlwZSB0aGF0IGlzIGEgbnVtYmVyLCB3ZSBuZWVkIHRvIGVuY29kZSB0aGUgbnVtYmVycyBhcyBoZXhcbiAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHBhcnNlX3V0aWxzXzEuZW5jb2RlTnVtYmVyKHZhbHVlc1trZXldLCB0eXBlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4cG9ydHMuc2FuaXRpemVUeXBlID0gc2FuaXRpemVUeXBlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0eXBlIG5hbWUgaW5kaWNhdGVzIHRoYXQgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0gdHlwZU5hbWUgc29saWRpdHkgdHlwZSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheSh0eXBlTmFtZSkge1xuICAgICAgICBpZiAodHlwZU5hbWUuaW5jbHVkZXMoJ1snKSAmJiB0eXBlTmFtZS5pbmNsdWRlcygnXScpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcHMgdGhlIHR5cGUgZGVmaW5pdGlvbnMgZnJvbSB0aGUgdHlwZWQgZGF0YSBmb3IgZWFzeSBsb29rLXVwLlxuICAgICAqIFRvcCBsZXZlbCBrZXlzIHJlcHJlc2VudCB0aGUgc3RydWN0cyBkZWZpbmVkLCB3aGlsZSB0b3AtbGV2ZWwgdmFsdWVzXG4gICAgICogYXJlIGFuIG9iamVjdCBrZXllZCBieSBwcm9wZXJ0eSB3aXRoIHN0cmluZyB2YWx1ZXMgb2YgdGhlIHR5cGUgbmFtZS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOlxuICAgICAqIHtcbiAgICAgKiAgICBFSVA3MTJEb21haW46IHtcbiAgICAgKiAgICAgIG5hbWU6ICdzdHJpbmcnLFxuICAgICAqICAgICAgdmVyc2lvbjogJ3N0cmluZycsXG4gICAgICogICAgICBjaGFpbklkOiAndWludDI1NidcbiAgICAgKiAgICB9XG4gICAgICogfVxuICAgICAqIEBwYXJhbSB0eXBlZERhdGEgVGhlIFR5cGVkRGF0YSB0byBtYXBcbiAgICAgKiBAcmV0dXJucyB7VHlwZU1hcHBpbmd9IHRoZSBtYXBwZWQgZGF0YSBzY2hlbWFcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVUeXBlTWFwcGluZyh0eXBlZERhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlZERhdGEudHlwZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBwcm92aWRlcl9lcnJvcl8xLlByb3ZpZGVyRXJyb3IuSW52YWxpZFJlcXVlc3QoJ01pc3NpbmcgdHlwZSBkZWZpbml0aW9ucyBmb3IgdHlwZWQgZGF0YScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgdG9wIGxldmVsIGtleXMuIFRoZXNlIHJlcHJlc2VudCB0aGUgY3VzdG9tIHR5cGVzLlxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModHlwZWREYXRhLnR5cGVzKS5yZWR1Y2UoKGFjYywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVkdWNlIGludG8gYSBuZXcgc2luZ2xlIG9iamVjdFxuICAgICAgICAgICAgLy8gU2V0IGEga2V5IGZvciBlYWNoIHR5cGUsIHJlZHVjZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgdHlwZXMgdG8gYW4gb2JqZWN0XG4gICAgICAgICAgICBhY2NbY3VycmVudF0gPSB0eXBlZERhdGEudHlwZXNbY3VycmVudF0ucmVkdWNlKChhY2MyLCB0eXBlRGVmKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIGVhY2ggdHlwZSwgc2V0IHRoZSBrZXkgYXMgdGhlIHByb3BlcnR5IG5hbWUsIGFuZCB0aGUgdmFsdWUgYXMgdGhlIHR5cGUgbmFtZVxuICAgICAgICAgICAgICAgIGFjYzJbdHlwZURlZi5uYW1lXSA9IHR5cGVEZWYudHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjMjtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgZXhwb3J0cy5jcmVhdGVUeXBlTWFwcGluZyA9IGNyZWF0ZVR5cGVNYXBwaW5nO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCIsInZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbihmdW5jdGlvbiAoZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICB2YXIgdiA9IGZhY3RvcnkocmVxdWlyZSwgZXhwb3J0cyk7XG4gICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIG1vZHVsZS5leHBvcnRzID0gdjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFtcInJlcXVpcmVcIiwgXCJleHBvcnRzXCIsIFwiYm4uanNcIl0sIGZhY3RvcnkpO1xuICAgIH1cbn0pKGZ1bmN0aW9uIChyZXF1aXJlLCBleHBvcnRzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuICAgIGNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbiAgICAvKipcbiAgICAgKiBwYXJzZU51bWJlclxuICAgICAqIENvbnZlcnRzIGEgdmFsdWUgdGhhdCByZXByZXNlbnRzIGEgbnVtYmVyIGludG8gYSBoZXggdmFsdWUuXG4gICAgICogQHBhcmFtIGFyZyB7c3RyaW5nIHwgbnVtYmVyIHwgQk59IEEgbnVtYmVyIHZhbHVlIHRvIGNvbnZlcnQgdG8gaGV4LlxuICAgICAqIENhbiBiZSBhIHJlZ3VsYXIgbnVtYmVyLCBiYXNlLTEwIHN0cmluZywgYmFzZS0xNiBzdHJpbmcsIG9yIEJOIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtCTn0gQk4gaW5zdGFuY2UgcmVwcmVzZW50aW5nIHRoZSBudW1iZXJcbiAgICAgKlxuICAgICAqIChBZGFwdGVkIGZyb20gZXRoZXJldW1qcy1hYmkpXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VOdW1iZXIoYXJnKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYXJnO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmIChhcmcuc3Vic3RyKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYXJnLnN1YnN0cigyKSwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYXJnLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnLnRvQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGFzc3VtZSB0aGlzIGlzIGEgQk4gZm9yIHRoZSBtb21lbnQsIHJlcGxhY2Ugd2l0aCBCTi5pc0JOIHNvb25cbiAgICAgICAgICAgIHJldHVybiBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FyZ3VtZW50IGlzIG5vdCBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlQml0V2lkdGgodHlwZSwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIGRlZmF1bHQgdG8gMjU2IGJpdCBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgIGxldCBzaXplID0gMjU2O1xuICAgICAgICAvLyBJZiB0eXBlIHN0cmluZyBpcyBsb25nZXIgdGhhbiBvZmZzZXQsIHBhcnNlIGJpdHMgZnJvbSB0aGUgdHlwZSBzdHJpbmdcbiAgICAgICAgaWYgKHR5cGUubGVuZ3RoID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQodHlwZS5zdWJzdHIob2Zmc2V0KSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpdCB3aWR0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOCwgYW5kIGluIHRoZSByYW5nZSA4LTI1Ni5cbiAgICAgICAgaWYgKHNpemUgJSA4IHx8IHNpemUgPCA4IHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiaXQgd2lkdGggJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBlbmNvZGVOdW1iZXJcbiAgICAgKiBUYWtlcyBhIGRlY2ltYWwgc3RyaW5nLCBoZXggc3RyaW5nLCByZWd1bGFyIG51bWJlciwgb3IgQk4gaW5zdGFuY2UgYW5kIHJldHVybnMgYSBoZXggc3RyaW5nIGluIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgICAqIFR5cGljYWxseSB0aGVzZSBjb252ZXJzaW9ucyBhcmUgZG9uZSBpbiB3ZWIzLCBidXQgdW50aWwgd2ViMyBhZGRzIGRpcmVjdCBzdXBwb3J0LCB0aGlzIGlzIG5lY2Vzc2FyeSBmb3Igbm9ybWFsaXppbmdcbiAgICAgKiBudW1iZXJzIGV0aF9zaWduVHlwZWREYXRhIHBheWxvYWRzLlxuICAgICAqIEBwYXJhbSBudW0gVGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0gdHlwZSBUaGUgc29saWRpdHkgQUJJIHR5cGUgdG8gZm9ybWF0IHRoZSBkYXRhIGFzIChlZy4gdWludDI1NiwgaW50OCwgZXRjKS4gT25seSBzdXBwb3J0cyBpbnQgYW5kIHVpbnQgdmFyaWFudHMuXG4gICAgICogQHBhcmFtIGNvbXBhY3QgYm9vbGVhbiAoZGVmYXVsdCBmYWxzZSkuIFdoZXRoZXIgdG8gdXNlIGNvbXBhY3QgZW5jb2RpbmcgZm9yIHVpbnRzLCBvciBwYWQgd2l0aCB6ZXJvZXMuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQSBoZXggc3RyaW5nIGZvcm1hdHRlZCBhcyB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5jb2RlTnVtYmVyKG51bSwgdHlwZSwgY29tcGFjdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlLnN0YXJ0c1dpdGgoJ3VpbnQnKSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlQml0V2lkdGgodHlwZSwgNCk7IC8vIHN0YXJ0IGFmdGVyICd1aW50J1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gc2l6ZSAvIDQ7IC8vIGxlbmd0aCBpbiBjaGFyYWN0ZXJzIGZvciB0aGUgc3RyaW5nLiBoZXggaXMgMSBjaGFyYWN0ZXIgZm9yIDQgYml0cy5cbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlTnVtYmVyKG51bSk7XG4gICAgICAgICAgICAvLyB1aW50IGNhbiBuZXZlciBiZSBuZWdhdGl2ZVxuICAgICAgICAgICAgaWYgKHBhcnNlZC5pc05lZygpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwbGllZCB1aW50IGlzIG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRvIGhleCwgYW5kIHByZXBlbmQgMHhcbiAgICAgICAgICAgIGlmIChjb21wYWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICcweCcgKyBwYXJzZWQudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICcweCcgKyBwYXJzZWQudG9TdHJpbmcoMTYsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZS5zdGFydHNXaXRoKCdpbnQnKSkge1xuICAgICAgICAgICAgLy8gYml0IHdpZHRoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4LCBhbmQgaW4gdGhlIHJhbmdlIDgtMjU2LlxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlQml0V2lkdGgodHlwZSwgMyk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBzaXplIC8gNDsgLy8gbGVuZ3RoIGluIGNoYXJhY3RlcnMgZm9yIHRoZSBzdHJpbmcuIGhleCBpcyAxIGNoYXJhY3RlciBmb3IgNCBiaXRzLlxuICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VOdW1iZXIobnVtKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdG8gdHdvcyBjb21wbGVtZW50IGF0IHRoZSBiaXQgc2l6ZSBmcm9tIHRoZSB0eXBlLCB0aGVuIGNvbnZlcnQgdmFsdWUgdG8gaGV4XG4gICAgICAgICAgICByZXR1cm4gJzB4JyArIHBhcnNlZC50b1R3b3Moc2l6ZSkudG9TdHJpbmcoMTYsIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdHlwZSBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleHBvcnRzLmVuY29kZU51bWJlciA9IGVuY29kZU51bWJlcjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2UtdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xudmFyIGV0aGpzX3V0aWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoanMtdXRpbFwiKSk7XG4vLyBNZXRob2RzIGZyb20gZXRoZXJldW1qcy11dGlsXG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzXG4gKiBgQnVmZmVyYCwgYFN0cmluZ2AsIGBOdW1iZXJgLCBudWxsL3VuZGVmaW5lZCwgYEJOYCBhbmQgb3RoZXIgb2JqZWN0cyB3aXRoIGEgYHRvQXJyYXkoKWAgbWV0aG9kLlxuICogQHBhcmFtIHYgdGhlIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKHYpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGV0aGpzX3V0aWxfMS5kZWZhdWx0LmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgICAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV0aGpzX3V0aWxfMS5kZWZhdWx0LnBhZFRvRXZlbihldGhqc191dGlsXzEuZGVmYXVsdC5zdHJpcEhleFByZWZpeCh2KSksICdoZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBtYXgtbGluZS1sZW5ndGhcbiAgICAgICAgICAgICAgICBcIkNhbm5vdCBjb252ZXJ0IHN0cmluZyB0byBidWZmZXIuIHRvQnVmZmVyIG9ubHkgc3VwcG9ydHMgMHgtcHJlZml4ZWQgaGV4IHN0cmluZ3MgYW5kIHRoaXMgc3RyaW5nIHdhcyBnaXZlbjogXCIgKyB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHYgPSBldGhqc191dGlsXzEuZGVmYXVsdC5pbnRUb0J1ZmZlcih2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChibl9qc18xLmRlZmF1bHQuaXNCTih2KSkge1xuICAgICAgICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2LnRvQXJyYXkpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnRzIGEgQk4gdG8gYSBCdWZmZXJcbiAgICAgICAgICAgIHYgPSBCdWZmZXIuZnJvbSh2LnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCB0eXBlOiBcIiArIHYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuZXhwb3J0cy50b0J1ZmZlciA9IHRvQnVmZmVyO1xuLyoqXG4gKiBBZGRzIFwiMHhcIiB0byBhIGdpdmVuIGBTdHJpbmdgIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgc3RhcnQgd2l0aCBcIjB4XCIuXG4gKi9cbmZ1bmN0aW9uIGFkZEhleFByZWZpeChzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIGV0aGpzX3V0aWxfMS5kZWZhdWx0LmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59XG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGFkZEhleFByZWZpeDtcbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICAgIHJldHVybiBldGhqc191dGlsXzEuZGVmYXVsdC5zdHJpcEhleFByZWZpeChzdHIpO1xufVxuZXhwb3J0cy5zdHJpcEhleFByZWZpeCA9IHN0cmlwSGV4UHJlZml4O1xuZnVuY3Rpb24gaW50VG9IZXgobikge1xuICAgIHJldHVybiBldGhqc191dGlsXzEuZGVmYXVsdC5pbnRUb0hleChuKTtcbn1cbmV4cG9ydHMuaW50VG9IZXggPSBpbnRUb0hleDtcbmZ1bmN0aW9uIGludFRvQnVmZmVyKG4pIHtcbiAgICByZXR1cm4gZXRoanNfdXRpbF8xLmRlZmF1bHQuaW50VG9CdWZmZXIobik7XG59XG5leHBvcnRzLmludFRvQnVmZmVyID0gaW50VG9CdWZmZXI7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9IZXgoYnVmKSB7XG4gICAgYnVmID0gdG9CdWZmZXIoYnVmKTtcbiAgICByZXR1cm4gJzB4JyArIGJ1Zi50b1N0cmluZygnaGV4Jyk7XG59XG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gYnVmZmVyVG9IZXg7XG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYC5cbiAqIEBwYXJhbSBidWYgYEJ1ZmZlcmAgb2JqZWN0IHRvIGNvbnZlcnRcbiAqIEB0aHJvd3MgSWYgdGhlIGlucHV0IG51bWJlciBleGNlZWRzIDUzIGJpdHMuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvSW50KGJ1Zikge1xuICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KHRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59XG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gYnVmZmVyVG9JbnQ7XG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWAuXG4gKiBAcGFyYW0gYSAoQnVmZmVyfEFycmF5fFN0cmluZylcbiAqIEByZXR1cm4gKEJ1ZmZlcnxBcnJheXxTdHJpbmcpXG4gKi9cbmZ1bmN0aW9uIHVucGFkKGEpIHtcbiAgICBhID0gZXRoanNfdXRpbF8xLmRlZmF1bHQuc3RyaXBIZXhQcmVmaXgoYSk7XG4gICAgdmFyIGZpcnN0ID0gYVswXTtcbiAgICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgICAgICBhID0gYS5zbGljZSgxKTtcbiAgICAgICAgZmlyc3QgPSBhWzBdO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbn1cbmV4cG9ydHMudW5wYWQgPSB1bnBhZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGFzc2VydF8xID0gcmVxdWlyZShcIi4vYXNzZXJ0XCIpO1xudmFyIGV0aF91dGlsXzEgPSByZXF1aXJlKFwiLi9ldGgtdXRpbFwiKTtcbi8qXG4gKiBBcyBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNoZXgtdmFsdWUtZW5jb2RpbmdcbiAqIFF1YW50aXRpZXMgc2hvdWxkIGJlIHJlcHJlc2VudGVkIGJ5IHRoZSBtb3N0IGNvbXBhY3QgaGV4IHJlcHJlc2VudGF0aW9uIHBvc3NpYmxlXG4gKiBUaGlzIG1lYW5zIHRoYXQgbm8gbGVhZGluZyB6ZXJvZXMgYXJlIGFsbG93ZWQuIFRoZXJlIGhlbHBlcnMgbWFrZSBpdCBlYXN5XG4gKiB0byBjb252ZXJ0IHRvIGFuZCBmcm9tIGludGVnZXJzIGFuZCB0aGVpciBjb21wYWN0IGhleCByZXByZXNlbnRhdGlvblxuICovXG5mdW5jdGlvbiBidWZmZXJUb1F1YW50aXR5SGV4KGJ1ZmZlcikge1xuICAgIGJ1ZmZlciA9IGV0aF91dGlsXzEudG9CdWZmZXIoYnVmZmVyKTtcbiAgICB2YXIgaGV4ID0gYnVmZmVyLnRvU3RyaW5nKCdoZXgnKTtcbiAgICB2YXIgdHJpbW1lZCA9IGV0aF91dGlsXzEudW5wYWQoaGV4KTtcbiAgICByZXR1cm4gZXRoX3V0aWxfMS5hZGRIZXhQcmVmaXgodHJpbW1lZCk7XG59XG5leHBvcnRzLmJ1ZmZlclRvUXVhbnRpdHlIZXggPSBidWZmZXJUb1F1YW50aXR5SGV4O1xuZnVuY3Rpb24gaW50VG9RdWFudGl0eUhleChuKSB7XG4gICAgYXNzZXJ0XzEuYXNzZXJ0KHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiBuID09PSBNYXRoLmZsb29yKG4pLCAnaW50VG9RdWFudGl0eUhleCBhcmcgbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgdmFyIG5IZXggPSBldGhfdXRpbF8xLnRvQnVmZmVyKG4pLnRvU3RyaW5nKCdoZXgnKTtcbiAgICBpZiAobkhleFswXSA9PT0gJzAnKSB7XG4gICAgICAgIG5IZXggPSBuSGV4LnN1YnN0cmluZygxKTtcbiAgICB9XG4gICAgcmV0dXJuIGV0aF91dGlsXzEuYWRkSGV4UHJlZml4KG5IZXgpO1xufVxuZXhwb3J0cy5pbnRUb1F1YW50aXR5SGV4ID0gaW50VG9RdWFudGl0eUhleDtcbmZ1bmN0aW9uIHF1YW50aXR5SGV4VG9JbnQocHJlZml4ZWRRdWFudGl0eUhleCkge1xuICAgIGFzc2VydF8xLmFzc2VydCh0eXBlb2YgcHJlZml4ZWRRdWFudGl0eUhleCA9PT0gJ3N0cmluZycsICdhcmcgdG8gcXVhbnRpdHlIZXhUb0ludCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgdmFyIHF1YW50aXR5SGV4ID0gZXRoX3V0aWxfMS5zdHJpcEhleFByZWZpeChwcmVmaXhlZFF1YW50aXR5SGV4KTtcbiAgICB2YXIgaXNFdmVuID0gcXVhbnRpdHlIZXgubGVuZ3RoICUgMiA9PT0gMDtcbiAgICBpZiAoIWlzRXZlbikge1xuICAgICAgICBxdWFudGl0eUhleCA9ICcwJyArIHF1YW50aXR5SGV4O1xuICAgIH1cbiAgICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihxdWFudGl0eUhleCwgJ2hleCcpO1xuICAgIHJldHVybiBldGhfdXRpbF8xLmJ1ZmZlclRvSW50KGJ1Zik7XG59XG5leHBvcnRzLnF1YW50aXR5SGV4VG9JbnQgPSBxdWFudGl0eUhleFRvSW50O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmZhbGxiYWNrID0gZmFsbGJhY2s7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xudmFyIGhhc1NldEltbWVkaWF0ZSA9IGV4cG9ydHMuaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXRJbW1lZGlhdGU7XG52YXIgaGFzTmV4dFRpY2sgPSBleHBvcnRzLmhhc05leHRUaWNrID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSAnZnVuY3Rpb24nO1xuXG5mdW5jdGlvbiBmYWxsYmFjayhmbikge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xufVxuXG5mdW5jdGlvbiB3cmFwKGRlZmVyKSB7XG4gICAgcmV0dXJuIChmbiwgLi4uYXJncykgPT4gZGVmZXIoKCkgPT4gZm4oLi4uYXJncykpO1xufVxuXG52YXIgX2RlZmVyO1xuXG5pZiAoaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgX2RlZmVyID0gc2V0SW1tZWRpYXRlO1xufSBlbHNlIGlmIChoYXNOZXh0VGljaykge1xuICAgIF9kZWZlciA9IHByb2Nlc3MubmV4dFRpY2s7XG59IGVsc2Uge1xuICAgIF9kZWZlciA9IGZhbGxiYWNrO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSB3cmFwKF9kZWZlcik7IiwidmFyIGNsb25lID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5zdGFuY2VvZihvYmosIHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUgIT0gbnVsbCAmJiBvYmogaW5zdGFuY2VvZiB0eXBlO1xufVxuXG52YXIgbmF0aXZlTWFwO1xudHJ5IHtcbiAgbmF0aXZlTWFwID0gTWFwO1xufSBjYXRjaChfKSB7XG4gIC8vIG1heWJlIGEgcmVmZXJlbmNlIGVycm9yIGJlY2F1c2Ugbm8gYE1hcGAuIEdpdmUgaXQgYSBkdW1teSB2YWx1ZSB0aGF0IG5vXG4gIC8vIHZhbHVlIHdpbGwgZXZlciBiZSBhbiBpbnN0YW5jZW9mLlxuICBuYXRpdmVNYXAgPSBmdW5jdGlvbigpIHt9O1xufVxuXG52YXIgbmF0aXZlU2V0O1xudHJ5IHtcbiAgbmF0aXZlU2V0ID0gU2V0O1xufSBjYXRjaChfKSB7XG4gIG5hdGl2ZVNldCA9IGZ1bmN0aW9uKCkge307XG59XG5cbnZhciBuYXRpdmVQcm9taXNlO1xudHJ5IHtcbiAgbmF0aXZlUHJvbWlzZSA9IFByb21pc2U7XG59IGNhdGNoKF8pIHtcbiAgbmF0aXZlUHJvbWlzZSA9IGZ1bmN0aW9uKCkge307XG59XG5cbi8qKlxuICogQ2xvbmVzIChjb3BpZXMpIGFuIE9iamVjdCB1c2luZyBkZWVwIGNvcHlpbmcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBzdXBwb3J0cyBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGRlZmF1bHQsIGJ1dCBpZiB5b3UgYXJlIGNlcnRhaW5cbiAqIHRoZXJlIGFyZSBubyBjaXJjdWxhciByZWZlcmVuY2VzIGluIHlvdXIgb2JqZWN0LCB5b3UgY2FuIHNhdmUgc29tZSBDUFUgdGltZVxuICogYnkgY2FsbGluZyBjbG9uZShvYmosIGZhbHNlKS5cbiAqXG4gKiBDYXV0aW9uOiBpZiBgY2lyY3VsYXJgIGlzIGZhbHNlIGFuZCBgcGFyZW50YCBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogeW91ciBwcm9ncmFtIG1heSBlbnRlciBhbiBpbmZpbml0ZSBsb29wIGFuZCBjcmFzaC5cbiAqXG4gKiBAcGFyYW0gYHBhcmVudGAgLSB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGBjaXJjdWxhcmAgLSBzZXQgdG8gdHJ1ZSBpZiB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZCBtYXkgY29udGFpblxuICogICAgY2lyY3VsYXIgcmVmZXJlbmNlcy4gKG9wdGlvbmFsIC0gdHJ1ZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIGBkZXB0aGAgLSBzZXQgdG8gYSBudW1iZXIgaWYgdGhlIG9iamVjdCBpcyBvbmx5IHRvIGJlIGNsb25lZCB0b1xuICogICAgYSBwYXJ0aWN1bGFyIGRlcHRoLiAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBJbmZpbml0eSlcbiAqIEBwYXJhbSBgcHJvdG90eXBlYCAtIHNldHMgdGhlIHByb3RvdHlwZSB0byBiZSB1c2VkIHdoZW4gY2xvbmluZyBhbiBvYmplY3QuXG4gKiAgICAob3B0aW9uYWwgLSBkZWZhdWx0cyB0byBwYXJlbnQgcHJvdG90eXBlKS5cbiAqIEBwYXJhbSBgaW5jbHVkZU5vbkVudW1lcmFibGVgIC0gc2V0IHRvIHRydWUgaWYgdGhlIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXNcbiAqICAgIHNob3VsZCBiZSBjbG9uZWQgYXMgd2VsbC4gTm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBvbiB0aGUgcHJvdG90eXBlXG4gKiAgICBjaGFpbiB3aWxsIGJlIGlnbm9yZWQuIChvcHRpb25hbCAtIGZhbHNlIGJ5IGRlZmF1bHQpXG4qL1xuZnVuY3Rpb24gY2xvbmUocGFyZW50LCBjaXJjdWxhciwgZGVwdGgsIHByb3RvdHlwZSwgaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgaWYgKHR5cGVvZiBjaXJjdWxhciA9PT0gJ29iamVjdCcpIHtcbiAgICBkZXB0aCA9IGNpcmN1bGFyLmRlcHRoO1xuICAgIHByb3RvdHlwZSA9IGNpcmN1bGFyLnByb3RvdHlwZTtcbiAgICBpbmNsdWRlTm9uRW51bWVyYWJsZSA9IGNpcmN1bGFyLmluY2x1ZGVOb25FbnVtZXJhYmxlO1xuICAgIGNpcmN1bGFyID0gY2lyY3VsYXIuY2lyY3VsYXI7XG4gIH1cbiAgLy8gbWFpbnRhaW4gdHdvIGFycmF5cyBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcywgd2hlcmUgY29ycmVzcG9uZGluZyBwYXJlbnRzXG4gIC8vIGFuZCBjaGlsZHJlbiBoYXZlIHRoZSBzYW1lIGluZGV4XG4gIHZhciBhbGxQYXJlbnRzID0gW107XG4gIHZhciBhbGxDaGlsZHJlbiA9IFtdO1xuXG4gIHZhciB1c2VCdWZmZXIgPSB0eXBlb2YgQnVmZmVyICE9ICd1bmRlZmluZWQnO1xuXG4gIGlmICh0eXBlb2YgY2lyY3VsYXIgPT0gJ3VuZGVmaW5lZCcpXG4gICAgY2lyY3VsYXIgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZGVwdGggPT0gJ3VuZGVmaW5lZCcpXG4gICAgZGVwdGggPSBJbmZpbml0eTtcblxuICAvLyByZWN1cnNlIHRoaXMgZnVuY3Rpb24gc28gd2UgZG9uJ3QgcmVzZXQgYWxsUGFyZW50cyBhbmQgYWxsQ2hpbGRyZW5cbiAgZnVuY3Rpb24gX2Nsb25lKHBhcmVudCwgZGVwdGgpIHtcbiAgICAvLyBjbG9uaW5nIG51bGwgYWx3YXlzIHJldHVybnMgbnVsbFxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGlmIChkZXB0aCA9PT0gMClcbiAgICAgIHJldHVybiBwYXJlbnQ7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIHByb3RvO1xuICAgIGlmICh0eXBlb2YgcGFyZW50ICE9ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZU1hcCgpO1xuICAgIH0gZWxzZSBpZiAoX2luc3RhbmNlb2YocGFyZW50LCBuYXRpdmVTZXQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBuYXRpdmVTZXQoKTtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlUHJvbWlzZSkpIHtcbiAgICAgIGNoaWxkID0gbmV3IG5hdGl2ZVByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBwYXJlbnQudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc29sdmUoX2Nsb25lKHZhbHVlLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KF9jbG9uZShlcnIsIGRlcHRoIC0gMSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvbmUuX19pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gW107XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzUmVnRXhwKHBhcmVudCkpIHtcbiAgICAgIGNoaWxkID0gbmV3IFJlZ0V4cChwYXJlbnQuc291cmNlLCBfX2dldFJlZ0V4cEZsYWdzKHBhcmVudCkpO1xuICAgICAgaWYgKHBhcmVudC5sYXN0SW5kZXgpIGNoaWxkLmxhc3RJbmRleCA9IHBhcmVudC5sYXN0SW5kZXg7XG4gICAgfSBlbHNlIGlmIChjbG9uZS5fX2lzRGF0ZShwYXJlbnQpKSB7XG4gICAgICBjaGlsZCA9IG5ldyBEYXRlKHBhcmVudC5nZXRUaW1lKCkpO1xuICAgIH0gZWxzZSBpZiAodXNlQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihwYXJlbnQpKSB7XG4gICAgICBpZiAoQnVmZmVyLmFsbG9jVW5zYWZlKSB7XG4gICAgICAgIC8vIE5vZGUuanMgPj0gNC41LjBcbiAgICAgICAgY2hpbGQgPSBCdWZmZXIuYWxsb2NVbnNhZmUocGFyZW50Lmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPbGRlciBOb2RlLmpzIHZlcnNpb25zXG4gICAgICAgIGNoaWxkID0gbmV3IEJ1ZmZlcihwYXJlbnQubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudC5jb3B5KGNoaWxkKTtcbiAgICAgIHJldHVybiBjaGlsZDtcbiAgICB9IGVsc2UgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgRXJyb3IpKSB7XG4gICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBwcm90b3R5cGUgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocGFyZW50KTtcbiAgICAgICAgY2hpbGQgPSBPYmplY3QuY3JlYXRlKHByb3RvKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjaGlsZCA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgcHJvdG8gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNpcmN1bGFyKSB7XG4gICAgICB2YXIgaW5kZXggPSBhbGxQYXJlbnRzLmluZGV4T2YocGFyZW50KTtcblxuICAgICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIHJldHVybiBhbGxDaGlsZHJlbltpbmRleF07XG4gICAgICB9XG4gICAgICBhbGxQYXJlbnRzLnB1c2gocGFyZW50KTtcbiAgICAgIGFsbENoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cblxuICAgIGlmIChfaW5zdGFuY2VvZihwYXJlbnQsIG5hdGl2ZU1hcCkpIHtcbiAgICAgIHBhcmVudC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgdmFyIGtleUNoaWxkID0gX2Nsb25lKGtleSwgZGVwdGggLSAxKTtcbiAgICAgICAgdmFyIHZhbHVlQ2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLnNldChrZXlDaGlsZCwgdmFsdWVDaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF9pbnN0YW5jZW9mKHBhcmVudCwgbmF0aXZlU2V0KSkge1xuICAgICAgcGFyZW50LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGVudHJ5Q2hpbGQgPSBfY2xvbmUodmFsdWUsIGRlcHRoIC0gMSk7XG4gICAgICAgIGNoaWxkLmFkZChlbnRyeUNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gcGFyZW50KSB7XG4gICAgICB2YXIgYXR0cnM7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgYXR0cnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGF0dHJzICYmIGF0dHJzLnNldCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY2hpbGRbaV0gPSBfY2xvbmUocGFyZW50W2ldLCBkZXB0aCAtIDEpO1xuICAgIH1cblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBEb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IGNsb25pbmcgYSBzeW1ib2wgYmVjYXVzZSBpdCBpcyBhIHByaW1pdGl2ZSxcbiAgICAgICAgLy8gbGlrZSBhIG51bWJlciBvciBzdHJpbmcuXG4gICAgICAgIHZhciBzeW1ib2wgPSBzeW1ib2xzW2ldO1xuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocGFyZW50LCBzeW1ib2wpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5lbnVtZXJhYmxlICYmICFpbmNsdWRlTm9uRW51bWVyYWJsZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkW3N5bWJvbF0gPSBfY2xvbmUocGFyZW50W3N5bWJvbF0sIGRlcHRoIC0gMSk7XG4gICAgICAgIGlmICghZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBzeW1ib2wsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW5jbHVkZU5vbkVudW1lcmFibGUpIHtcbiAgICAgIHZhciBhbGxQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocGFyZW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWxsUHJvcGVydHlOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvcGVydHlOYW1lID0gYWxsUHJvcGVydHlOYW1lc1tpXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhcmVudCwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRbcHJvcGVydHlOYW1lXSA9IF9jbG9uZShwYXJlbnRbcHJvcGVydHlOYW1lXSwgZGVwdGggLSAxKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNoaWxkLCBwcm9wZXJ0eU5hbWUsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICByZXR1cm4gX2Nsb25lKHBhcmVudCwgZGVwdGgpO1xufVxuXG4vKipcbiAqIFNpbXBsZSBmbGF0IGNsb25lIHVzaW5nIHByb3RvdHlwZSwgYWNjZXB0cyBvbmx5IG9iamVjdHMsIHVzZWZ1bGwgZm9yIHByb3BlcnR5XG4gKiBvdmVycmlkZSBvbiBGTEFUIGNvbmZpZ3VyYXRpb24gb2JqZWN0IChubyBuZXN0ZWQgcHJvcHMpLlxuICpcbiAqIFVTRSBXSVRIIENBVVRJT04hIFRoaXMgbWF5IG5vdCBiZWhhdmUgYXMgeW91IHdpc2ggaWYgeW91IGRvIG5vdCBrbm93IGhvdyB0aGlzXG4gKiB3b3Jrcy5cbiAqL1xuY2xvbmUuY2xvbmVQcm90b3R5cGUgPSBmdW5jdGlvbiBjbG9uZVByb3RvdHlwZShwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCA9PT0gbnVsbClcbiAgICByZXR1cm4gbnVsbDtcblxuICB2YXIgYyA9IGZ1bmN0aW9uICgpIHt9O1xuICBjLnByb3RvdHlwZSA9IHBhcmVudDtcbiAgcmV0dXJuIG5ldyBjKCk7XG59O1xuXG4vLyBwcml2YXRlIHV0aWxpdHkgZnVuY3Rpb25zXG5cbmZ1bmN0aW9uIF9fb2JqVG9TdHIobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuY2xvbmUuX19vYmpUb1N0ciA9IF9fb2JqVG9TdHI7XG5cbmZ1bmN0aW9uIF9faXNEYXRlKG8pIHtcbiAgcmV0dXJuIHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBfX29ialRvU3RyKG8pID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5jbG9uZS5fX2lzRGF0ZSA9IF9faXNEYXRlO1xuXG5mdW5jdGlvbiBfX2lzQXJyYXkobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5jbG9uZS5fX2lzQXJyYXkgPSBfX2lzQXJyYXk7XG5cbmZ1bmN0aW9uIF9faXNSZWdFeHAobykge1xuICByZXR1cm4gdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIF9fb2JqVG9TdHIobykgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuY2xvbmUuX19pc1JlZ0V4cCA9IF9faXNSZWdFeHA7XG5cbmZ1bmN0aW9uIF9fZ2V0UmVnRXhwRmxhZ3MocmUpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZS5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlLmlnbm9yZUNhc2UpIGZsYWdzICs9ICdpJztcbiAgaWYgKHJlLm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59XG5jbG9uZS5fX2dldFJlZ0V4cEZsYWdzID0gX19nZXRSZWdFeHBGbGFncztcblxucmV0dXJuIGNsb25lO1xufSkoKTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0hleFByZWZpeGVkID0gcmVxdWlyZSgnaXMtaGV4LXByZWZpeGVkJyk7XG52YXIgc3RyaXBIZXhQcmVmaXggPSByZXF1aXJlKCdzdHJpcC1oZXgtcHJlZml4Jyk7XG5cbi8qKlxuICogUGFkcyBhIGBTdHJpbmdgIHRvIGhhdmUgYW4gZXZlbiBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7U3RyaW5nfSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gcGFkVG9FdmVuKHZhbHVlKSB7XG4gIHZhciBhID0gdmFsdWU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAodHlwZW9mIGEgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgcGFkZGluZyB0byBldmVuLCB2YWx1ZSBtdXN0IGJlIHN0cmluZywgaXMgY3VycmVudGx5ICcgKyB0eXBlb2YgYSArICcsIHdoaWxlIHBhZFRvRXZlbi4nKTtcbiAgfVxuXG4gIGlmIChhLmxlbmd0aCAlIDIpIHtcbiAgICBhID0gJzAnICsgYTtcbiAgfVxuXG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgYE51bWJlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaW50VG9IZXgoaSkge1xuICB2YXIgaGV4ID0gaS50b1N0cmluZygxNik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBgTnVtYmVyYCB0byBhIGBCdWZmZXJgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5mdW5jdGlvbiBpbnRUb0J1ZmZlcihpKSB7XG4gIHZhciBoZXggPSBpbnRUb0hleChpKTtcblxuICByZXR1cm4gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oaGV4LnNsaWNlKDIpKSwgJ2hleCcpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYmluYXJ5IHNpemUgb2YgYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmluYXJ5U2l6ZShzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gd2hpbGUgZ2V0dGluZyBiaW5hcnkgc2l6ZSwgbWV0aG9kIGdldEJpbmFyeVNpemUgcmVxdWlyZXMgaW5wdXQgXFwnc3RyXFwnIHRvIGJlIHR5cGUgU3RyaW5nLCBnb3QgXFwnJyArIHR5cGVvZiBzdHIgKyAnXFwnLicpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIFRSVUUgaWYgdGhlIGZpcnN0IHNwZWNpZmllZCBhcnJheSBjb250YWlucyBhbGwgZWxlbWVudHNcbiAqIGZyb20gdGhlIHNlY29uZCBvbmUuIEZBTFNFIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBzdXBlcnNldFxuICogQHBhcmFtIHthcnJheX0gc3Vic2V0XG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGFycmF5Q29udGFpbnNBcnJheShzdXBlcnNldCwgc3Vic2V0LCBzb21lKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHN1cGVyc2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3VwZXJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdXBlcnNldCArICdcXCcnKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShzdWJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdWJzZXRcXCcgdG8gYmUgYW4gYXJyYXkgZ290IHR5cGUgXFwnJyArIHR5cGVvZiBzdWJzZXQgKyAnXFwnJyk7XG4gIH1cblxuICByZXR1cm4gc3Vic2V0W0Jvb2xlYW4oc29tZSkgJiYgJ3NvbWUnIHx8ICdldmVyeSddKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBzdXBlcnNldC5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICB9KTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCB1dGY4IGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9VdGY4KGhleCkge1xuICB2YXIgYnVmZmVyVmFsdWUgPSBuZXcgQnVmZmVyKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeChoZXgpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpKSwgJ2hleCcpO1xuXG4gIHJldHVybiBidWZmZXJWYWx1ZS50b1N0cmluZygndXRmOCcpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGFzY2lpIGZyb20gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIHRvQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvQXNjaWkoaGV4KSB7XG4gIHZhciBzdHIgPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICB2YXIgaSA9IDAsXG4gICAgICBsID0gaGV4Lmxlbmd0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgaSA9IDI7XG4gIH1cblxuICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiB1dGY4IHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbVV0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21VdGY4KHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBzdHIgPSBuZXcgQnVmZmVyKHN0cmluZ1ZhbHVlLCAndXRmOCcpO1xuXG4gIHJldHVybiAnMHgnICsgcGFkVG9FdmVuKHN0ci50b1N0cmluZygnaGV4JykpLnJlcGxhY2UoL14wK3wwKyQvZywgJycpO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tQXNjaWkoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIGhleCA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyaW5nVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIGNvZGUgPSBzdHJpbmdWYWx1ZS5jaGFyQ29kZUF0KGkpO1xuICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgaGV4ICs9IG4ubGVuZ3RoIDwgMiA/ICcwJyArIG4gOiBuO1xuICB9XG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogZ2V0S2V5cyhbe2E6IDEsIGI6IDJ9LCB7YTogMywgYjogNH1dLCAnYScpID0+IFsxLCAzXVxuICpcbiAqIEBtZXRob2QgZ2V0S2V5cyBnZXQgc3BlY2lmaWMga2V5IGZyb20gaW5uZXIgb2JqZWN0IGFycmF5IG9mIG9iamVjdHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJhbXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dFbXB0eVxuICogQHJldHVybnMge0FycmF5fSBvdXRwdXQganVzdCBhIHNpbXBsZSBhcnJheSBvZiBvdXRwdXQga2V5c1xuICovXG5mdW5jdGlvbiBnZXRLZXlzKHBhcmFtcywga2V5LCBhbGxvd0VtcHR5KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgQXJyYXkgYXMgXFwncGFyYW1zXFwnIGlucHV0LCBnb3QgXFwnJyArIHR5cGVvZiBwYXJhbXMgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGdldEtleXMgZXhwZWN0aW5nIHR5cGUgU3RyaW5nIGZvciBpbnB1dCBcXCdrZXlcXCcgZ290IFxcJycgKyB0eXBlb2Yga2V5ICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciB2YWx1ZSA9IHBhcmFtc1tpXVtrZXldOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgaWYgKGFsbG93RW1wdHkgJiYgIXZhbHVlKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFiaScpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIElzIHRoZSBzdHJpbmcgYSBoZXggc3RyaW5nLlxuICpcbiAqIEBtZXRob2QgY2hlY2sgaWYgc3RyaW5nIGlzIGhleCBzdHJpbmcgb2Ygc3BlY2lmaWMgbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm5zIHtCb29sZWFufSBvdXRwdXQgdGhlIHN0cmluZyBpcyBhIGhleCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXJyYXlDb250YWluc0FycmF5OiBhcnJheUNvbnRhaW5zQXJyYXksXG4gIGludFRvQnVmZmVyOiBpbnRUb0J1ZmZlcixcbiAgZ2V0QmluYXJ5U2l6ZTogZ2V0QmluYXJ5U2l6ZSxcbiAgaXNIZXhQcmVmaXhlZDogaXNIZXhQcmVmaXhlZCxcbiAgc3RyaXBIZXhQcmVmaXg6IHN0cmlwSGV4UHJlZml4LFxuICBwYWRUb0V2ZW46IHBhZFRvRXZlbixcbiAgaW50VG9IZXg6IGludFRvSGV4LFxuICBmcm9tQXNjaWk6IGZyb21Bc2NpaSxcbiAgZnJvbVV0Zjg6IGZyb21VdGY4LFxuICB0b0FzY2lpOiB0b0FzY2lpLFxuICB0b1V0Zjg6IHRvVXRmOCxcbiAgZ2V0S2V5czogZ2V0S2V5cyxcbiAgaXNIZXhTdHJpbmc6IGlzSGV4U3RyaW5nXG59OyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IHNldEltbWVkaWF0ZSA6XG5cdGZ1bmN0aW9uIHNldEltbWVkaWF0ZSgpIHtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cyk7XG5cdFx0YXJncy5zcGxpY2UoMSwgMCwgMCk7XG5cdFx0c2V0VGltZW91dC5hcHBseShudWxsLCBhcmdzKTtcblx0fTtcbiJdfQ==
