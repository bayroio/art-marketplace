"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bitski_1 = require("../bitski");
const authentication_error_1 = require("../errors/authentication-error");
const oauth_manager_1 = require("./oauth-manager");
const token_store_1 = require("./token-store");
const user_1 = require("./user");
const user_store_1 = require("./user-store");
class OpenidAuthProvider {
    constructor(clientId, redirectUri, additionalScopes, opts) {
        opts = opts || {};
        const settings = {
            additionalScopes,
            clientId,
            redirectUri,
        };
        Object.assign(settings, opts);
        this.oauthManager = new oauth_manager_1.OAuthManager(settings);
        this.tokenStore = new token_store_1.TokenStore(clientId, opts.store);
        this.userStore = new user_store_1.UserStore(clientId, opts.store);
    }
    get authStatus() {
        if (this.tokenStore.currentToken) {
            return bitski_1.AuthenticationStatus.Connected;
        }
        else if (this.tokenStore.refreshToken) {
            return bitski_1.AuthenticationStatus.Expired;
        }
        else {
            return bitski_1.AuthenticationStatus.NotConnected;
        }
    }
    getAccessToken() {
        if (this.tokenStore.currentToken) {
            return Promise.resolve(this.tokenStore.currentToken);
        }
        if (this.tokenStore.refreshToken) {
            return this.refreshAccessToken();
        }
        return Promise.reject(authentication_error_1.AuthenticationError.NotSignedIn());
    }
    getRefreshToken() {
        if (this.tokenStore.refreshToken) {
            return Promise.resolve(this.tokenStore.refreshToken);
        }
        // Error: the user did not approve this app for offline access
        if (this.tokenStore.currentToken) {
            return Promise.reject(authentication_error_1.AuthenticationError.NoRefreshToken());
        }
        // Error: the user is not signed in.
        return Promise.reject(authentication_error_1.AuthenticationError.NotSignedIn());
    }
    invalidateToken() {
        if (this.tokenStore.currentToken) {
            this.tokenStore.invalidateCurrentToken();
        }
        if (this.signOutCallback) {
            this.signOutCallback();
        }
        return Promise.resolve();
    }
    refreshAccessToken() {
        if (this.tokenStore.refreshToken) {
            return this.oauthManager.refreshAccessToken(this.tokenStore.refreshToken).then((tokenResponse) => {
                this.tokenStore.persistTokenResponse(tokenResponse);
                return tokenResponse.accessToken;
            }).catch((error) => {
                // If we can't renew, we likely have bad data
                this.tokenStore.clear();
                this.userStore.clear();
                throw error;
            });
        }
        return Promise.reject(authentication_error_1.AuthenticationError.NoRefreshToken());
    }
    signIn(method, opts) {
        let promise;
        switch (method) {
            case bitski_1.OAuthSignInMethod.Redirect:
                promise = this.oauthManager.signInRedirect(opts);
                break;
            case bitski_1.OAuthSignInMethod.Silent:
                return Promise.reject(authentication_error_1.AuthenticationError.UnsupportedAuthenticationMethod());
            default:
                promise = this.oauthManager.signInPopup(opts);
                break;
        }
        return promise.then((tokenResponse) => {
            this.tokenStore.persistTokenResponse(tokenResponse);
            return this.loadUser();
        });
    }
    connect() {
        return this.refreshAccessToken().then(() => {
            return this.loadUser();
        });
    }
    getUser() {
        return this.getOrFetchUser();
    }
    signInOrConnect(signInMethod = bitski_1.OAuthSignInMethod.Popup, opts) {
        switch (this.authStatus) {
            case bitski_1.AuthenticationStatus.Connected:
                return this.loadUser();
            case bitski_1.AuthenticationStatus.Expired:
                return this.connect();
            case bitski_1.AuthenticationStatus.NotConnected:
                return this.signIn(signInMethod, opts);
        }
    }
    redirectCallback() {
        return this.oauthManager.redirectCallback().then((tokenResponse) => {
            this.tokenStore.persistTokenResponse(tokenResponse);
            return this.loadUser();
        });
    }
    signOut() {
        this.tokenStore.clear();
        this.userStore.clear();
        // Call the sign out callback if one has been provided
        if (this.signOutCallback) {
            this.signOutCallback();
        }
        // We don't currently have the ability to invalidate access tokens, so for now simply resolve.
        // Down the road this may perform a network request to invalidate.
        return Promise.resolve();
    }
    getOrFetchUser() {
        const currentUser = this.userStore.currentUser;
        if (currentUser) {
            return Promise.resolve(currentUser);
        }
        return this.loadUser();
    }
    loadUser() {
        return this.getAccessToken().then((accessToken) => {
            return this.oauthManager.requestUserInfo(accessToken);
        }).then((json) => {
            return user_1.User.fromJson(json);
        }).then((user) => {
            this.userStore.set(user);
            return user;
        });
    }
}
exports.OpenidAuthProvider = OpenidAuthProvider;
//# sourceMappingURL=openid-auth-provider.js.map