"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const bitski_provider_1 = require("bitski-provider");
exports.Kovan = bitski_provider_1.Kovan;
exports.Mainnet = bitski_provider_1.Mainnet;
exports.Rinkeby = bitski_provider_1.Rinkeby;
const oauth_manager_1 = require("./auth/oauth-manager");
exports.LOGIN_HINT_SIGNUP = oauth_manager_1.LOGIN_HINT_SIGNUP;
const openid_auth_provider_1 = require("./auth/openid-auth-provider");
const connect_button_1 = require("./components/connect-button");
exports.ConnectButtonSize = connect_button_1.ConnectButtonSize;
const constants_1 = require("./constants");
const bitski_browser_engine_1 = require("./providers/bitski-browser-engine");
const index_1 = __importDefault(require("./styles/index"));
const callback_1 = require("./utils/callback");
const localstorage_store_1 = require("./utils/localstorage-store");
exports.LocalStorageStore = localstorage_store_1.LocalStorageStore;
var OAuthSignInMethod;
(function (OAuthSignInMethod) {
    OAuthSignInMethod["Redirect"] = "REDIRECT";
    OAuthSignInMethod["Popup"] = "POPUP";
    OAuthSignInMethod["Silent"] = "SILENT";
})(OAuthSignInMethod = exports.OAuthSignInMethod || (exports.OAuthSignInMethod = {}));
var AuthenticationStatus;
(function (AuthenticationStatus) {
    AuthenticationStatus["Connected"] = "CONNECTED";
    AuthenticationStatus["Expired"] = "EXPIRED";
    AuthenticationStatus["NotConnected"] = "NOT_CONNECTED";
})(AuthenticationStatus = exports.AuthenticationStatus || (exports.AuthenticationStatus = {}));
// Errors
var authentication_error_1 = require("./errors/authentication-error");
exports.AuthenticationError = authentication_error_1.AuthenticationError;
exports.AuthenticationErrorCode = authentication_error_1.AuthenticationErrorCode;
var parse_error_1 = require("./errors/parse-error");
exports.ParseError = parse_error_1.ParseError;
exports.ParseErrorCode = parse_error_1.ParseErrorCode;
var signer_error_1 = require("./errors/signer-error");
exports.SignerError = signer_error_1.SignerError;
exports.SignerErrorCode = signer_error_1.SignerErrorCode;
/**
 * Bitski SDK
 */
class Bitski {
    /**
     * @param clientId OAuth Client ID
     * @param redirectUri Redirect uri, defaults to the current url. This should be the location of your callback html file.
     * @param additionalScopes To use custom scopes, add them here. The default value is ['offline'].
     * Note: Make sure your app is approved for the scopes you are requesting first.
     * @param options Other OAuth settings. Don't change these unless you know what you are doing.
     */
    constructor(clientId, redirectUri, additionalScopes, options) {
        this.engines = new Map();
        this.signoutHandlers = [];
        this.clientId = clientId;
        this.sdkVersion = constants_1.SDK_VERSION;
        this.authProvider = new openid_auth_provider_1.OpenidAuthProvider(clientId, redirectUri || window.location.href, additionalScopes, options);
        if (document && document.body) {
            this.injectStyles();
        }
        else {
            window.addEventListener('load', () => {
                this.injectStyles();
            });
        }
        this.authProvider.signOutCallback = this.onSignOut.bind(this);
    }
    /**
     * Alternative to using our static callback.html file. Call this from your own redirect page.
     */
    static callback() {
        callback_1.processCallback();
    }
    /**
     * Returns a new web3 provider for a given network.
     * @param options options for the provider, or a network name
     */
    getProvider(options) {
        // Check cache for existing provider
        const existingProvider = this.engines.get(JSON.stringify(options));
        if (existingProvider) {
            existingProvider.start();
            return existingProvider;
        }
        // Create a new provider if one does not exist
        let normalizedOptions = {};
        if (options && typeof options !== 'string') {
            normalizedOptions = options;
        }
        const network = this.networkFromProviderOptions(options);
        if (network === bitski_provider_1.Kovan && normalizedOptions.minGasPrice == null) {
            normalizedOptions.minGasPrice = 1;
        }
        const newProvider = this.createProvider(network, normalizedOptions);
        newProvider.start();
        this.engines.set(JSON.stringify(options), newProvider);
        return newProvider;
    }
    /**
     * Creates a sign in with bitski button to add to your app. If an HTML element is passed in as the
     * first parameter, it will automatically add it to the DOM inside that element. Make sure to add
     * a callback to get notified of login events.
     * @param options {ConnectButtonOptions} Optional configuration for the button
     * @param callback Post-login callback. Called when sign in is complete. Not applicable for redirect login method.
     */
    getConnectButton(options, callback) {
        return new connect_button_1.ConnectButton(this.authProvider, options, callback);
    }
    /**
     * Signs in or connects to bitski depending on the user's auth state.
     * Since it may open a popup, this method must be called from user interaction handler,
     * such as a click or tap handler.
     * @param options Provide SignInOptions for the sign in request. See signIn() for more info.
     */
    start(options) {
        return this.authProvider.signInOrConnect(undefined, options);
    }
    /**
     * Check the logged in state of the user
     */
    get authStatus() {
        return this.authProvider.authStatus;
    }
    /**
     * Starts the sign in flow. Will trigger a popup window over your app, so it must be called within a user interaction handler such as a click.
     * @param options Optionally provide additional options for the sign in request.
     *
     * You can use the options parameter to request that we show the sign up form instead of the sign in form:
     * ```javascript
     * import { LOGIN_HINT_SIGNUP } from 'bitski';
     *
     * await bitski.signIn({ login_hint: LOGIN_HINT_SIGNUP });
     * ```
     */
    signIn(options) {
        return this.authProvider.signIn(OAuthSignInMethod.Popup, options);
    }
    /**
     * Gets the current signed in user. Will reject if we are not signed in.
     */
    getUser() {
        return this.authProvider.getUser();
    }
    /**
     * Connects to bitski to get a valid access token if possible.
     */
    connect() {
        return this.authProvider.connect();
    }
    /**
     * Starts redirect sign in flow. This is an alternative flow to the popup that all takes place in the same browser window.
     * @param options Optionally provide additional options for the sign in request. See signIn() for more info.
     */
    signInRedirect(options) {
        this.authProvider.signIn(OAuthSignInMethod.Redirect, options);
    }
    /**
     * Call from your oauth redirect page.
     */
    redirectCallback() {
        return this.authProvider.redirectCallback();
    }
    /**
     * Retrieves the current access token for the user, if logged in.
     */
    getCurrentAccessToken() {
        return this.authProvider.getAccessToken();
    }
    /**
     * Retrieves the current refresh token for the user, if logged in.
     * Requires that the user has approved your application for offline access.
     */
    getCurrentRefreshToken() {
        return this.authProvider.getRefreshToken();
    }
    /**
     * Register a callback to be called on sign out. This is a good practice,
     * since there may be situations where you are signed out unexpectedly.
     * @param fn Your callback function
     */
    addSignOutHandler(fn) {
        this.signoutHandlers.push(fn);
    }
    /**
     * Remove a registered signout callback
     * @param fn Your callback function
     */
    removeSignOutHandler(fn) {
        const index = this.signoutHandlers.findIndex((item) => item === fn);
        if (index >= 0) {
            this.signoutHandlers.splice(index, 1);
        }
    }
    /**
     * Sign the current user out of your application.
     */
    signOut() {
        this.engines.forEach((engine) => engine.stop());
        return this.authProvider.signOut();
    }
    createProvider(network, options = {}) {
        return new bitski_browser_engine_1.BitskiBrowserEngine(this.clientId, this.authProvider, this.sdkVersion, network, options);
    }
    networkFromName(networkName) {
        switch (networkName) {
            case '':
            case 'mainnet':
                return bitski_provider_1.Mainnet;
            case 'rinkeby':
                return bitski_provider_1.Rinkeby;
            case 'kovan':
                return bitski_provider_1.Kovan;
            default:
                throw new Error(`Unsupported network name ${networkName}. Try passing a \`network\` in the options instead.`);
        }
    }
    networkFromProviderOptions(options) {
        if (!options) {
            return bitski_provider_1.Mainnet;
        }
        if (typeof options === 'string') {
            return this.networkFromName(options);
        }
        if (options.network) {
            return options.network;
        }
        if (options.networkName) {
            return this.networkFromName(options.networkName);
        }
        return bitski_provider_1.Mainnet;
    }
    onSignOut() {
        this.signoutHandlers.forEach((cb) => {
            cb();
        });
    }
    /**
     * Embeds Bitski's UI styles
     */
    injectStyles() {
        if (document.getElementById('BitskiEmbeddedStyles')) {
            return;
        }
        const style = document.createElement('style');
        style.setAttribute('type', 'text/css');
        style.setAttribute('id', 'BitskiEmbeddedStyles');
        style.appendChild(document.createTextNode(index_1.default));
        const head = document.head || document.getElementsByTagName('head')[0];
        head.appendChild(style);
    }
}
exports.Bitski = Bitski;
//# sourceMappingURL=bitski.js.map