'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var ethUtil = require('ethereumjs-util');
var assert = require('./assert.js');

module.exports = {
    intToQuantityHex: intToQuantityHex,
    quantityHexToInt: quantityHexToInt

    /*
     * As per https://github.com/ethereum/wiki/wiki/JSON-RPC#hex-value-encoding
     * Quanities should be represented by the most compact hex representation possible
     * This means that no leading zeroes are allowed. There helpers make it easy
     * to convert to and from integers and their compact hex representation
     */

};function bufferToQuantityHex(buffer) {
    assert((typeof buffer === 'undefined' ? 'undefined' : _typeof(buffer)) === 'object' && buffer._isBuffer === true, 'bufferToQuantityHex arg must be a buffer');
    var hex = buffer.toString('hex');
    var trimmed = ethUtil.unpad(hex);
    return ethUtil.addHexPrefix(trimmed);
}

function intToQuantityHex(n) {
    assert(typeof n === 'number' && n === Math.floor(n), 'intToQuantityHex arg must be an integer');
    var nHex = ethUtil.toBuffer(n).toString('hex');
    if (nHex[0] === '0') {
        nHex = nHex.substring(1);
    }
    return ethUtil.addHexPrefix(nHex);
}

function quantityHexToInt(prefixedQuantityHex) {
    assert(typeof prefixedQuantityHex === 'string', 'arg to quantityHexToInt must be a string');
    var quantityHex = ethUtil.stripHexPrefix(prefixedQuantityHex);
    var isEven = quantityHex.length % 2 === 0;
    if (!isEven) {
        quantityHex = '0' + quantityHex;
    }
    var buf = new Buffer(quantityHex, 'hex');
    return ethUtil.bufferToInt(buf);
}