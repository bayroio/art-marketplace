"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var eachSeries_1 = __importDefault(require("async/eachSeries"));
var base_provider_1 = __importDefault(require("./base-provider"));
var provider_engine_error_1 = require("./errors/provider-engine-error");
var block_tracker_1 = __importDefault(require("./util/block-tracker"));
var stoplight_1 = __importDefault(require("./util/stoplight"));
var Web3ProviderEngine = /** @class */ (function (_super) {
    __extends(Web3ProviderEngine, _super);
    function Web3ProviderEngine(opts) {
        var _this = _super.call(this) || this;
        _this._pollForBlocks = true;
        _this._running = false;
        _this.setMaxListeners(30);
        // parse options
        opts = opts || {};
        // block polling
        var directProvider = {
            sendAsync: function (req, cb) {
                _this.sendPayload(req).then(function (res) {
                    cb(null, res);
                }).catch(function (err) {
                    cb(err);
                });
            },
        };
        if (opts.disableBlockTracking === true) {
            _this._pollForBlocks = false;
        }
        var blockTrackerProvider = opts.blockTrackerProvider || directProvider;
        _this._blockTracker = new block_tracker_1.default({
            provider: blockTrackerProvider,
            blockTracker: opts.blockTracker,
            pollingInterval: opts.pollingInterval || 4000,
        });
        _this._blockTracker.on('block', _this._setCurrentBlock.bind(_this));
        _this._blockTracker.on('sync', _this.emit.bind(_this, 'sync'));
        _this._blockTracker.on('rawBlock', _this.emit.bind(_this, 'rawBlock'));
        _this._blockTracker.on('latest', _this.emit.bind(_this, 'latest'));
        // Handle errors instead of re-emitting, since they will throw otherwise
        _this._blockTracker.on('error', function (error) {
            // Ignore errors from the block tracker unless debug is enabled
            if (opts.debug) {
                console.log('DEBUG: ' + error.message);
            }
        });
        // set initialization blocker
        _this._ready = new stoplight_1.default();
        _this._providers = [];
        return _this;
    }
    Web3ProviderEngine.prototype.isRunning = function () {
        return this._running;
    };
    Web3ProviderEngine.prototype.start = function () {
        // trigger start
        this._ready.go();
        if (this._pollForBlocks) {
            // start tracking blocks
            this._blockTracker.start();
        }
        // update state
        this._running = true;
        // signal that we started
        this.emit('start');
    };
    Web3ProviderEngine.prototype.stop = function () {
        // stop block tracking
        this._blockTracker.stop();
        // update state
        this._running = false;
        // signal that we stopped
        this.emit('stop');
    };
    Web3ProviderEngine.prototype.addProvider = function (source) {
        this._providers.push(source);
        source.setEngine(this);
    };
    Web3ProviderEngine.prototype.send = function (method, params) {
        var _this = this;
        // Wrap base class with Stoplight
        return new Promise(function (fulfill, reject) {
            _this._ready.await(function () {
                _super.prototype.send.call(_this, method, params).then(fulfill, reject);
            });
        });
    };
    Web3ProviderEngine.prototype.sendAsync = function (payload, cb) {
        var _this = this;
        // Wrap base class with Stoplight
        this._ready.await(function () {
            _super.prototype.sendAsync.call(_this, payload, cb);
        });
    };
    // Actually perform the request
    Web3ProviderEngine.prototype.sendPayload = function (payload) {
        var _this = this;
        return new Promise(function (fulfill, reject) {
            var currentProvider = -1;
            var result = null;
            var error = null;
            // Stack of subprovider next callbacks
            var stack = [];
            var next = function (callback) {
                currentProvider += 1;
                if (callback) {
                    // Insert in front since eachSeries traverses from front
                    stack.unshift(callback);
                }
                // Bubbled down as far as we could go, and the request wasn't
                // handled. Return an error.
                if (currentProvider >= _this._providers.length) {
                    // tslint:disable-next-line: max-line-length
                    var msg = "Request for method \"" + payload.method + "\" not handled by any subprovider.";
                    end(new provider_engine_error_1.ProviderEngineError(msg, provider_engine_error_1.ProviderEngineErrorCode.UnhandledRequest));
                    return;
                }
                // Handle request in next subprovider
                try {
                    var provider = _this._providers[currentProvider];
                    provider.handleRequest(payload, next, end);
                }
                catch (e) {
                    end(e);
                }
            };
            var notifySubprovider = function (fn, callback) {
                if (fn) {
                    fn(error, result, callback);
                }
                else {
                    callback();
                }
            };
            var end = function (e, r) {
                error = e;
                result = r;
                // Call any callbacks from subproviders
                eachSeries_1.default(stack, notifySubprovider).then(function () {
                    // Reconstruct JSONRPCResponse
                    var resultObj = {
                        id: payload.id,
                        jsonrpc: payload.jsonrpc,
                        result: result,
                    };
                    // Complete promise
                    if (error) {
                        reject(error);
                    }
                    else {
                        fulfill(resultObj);
                    }
                });
            };
            // Call next() to kick things off
            next();
        });
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function (bufferBlock) {
        this.currentBlock = bufferBlock;
        this.emit('block', bufferBlock);
    };
    return Web3ProviderEngine;
}(base_provider_1.default));
exports.default = Web3ProviderEngine;
