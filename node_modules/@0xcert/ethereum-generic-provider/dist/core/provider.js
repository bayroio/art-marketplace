"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereum_utils_1 = require("@0xcert/ethereum-utils");
const scaffold_1 = require("@0xcert/scaffold");
const events_1 = require("events");
const errors_1 = require("./errors");
const types_1 = require("./types");
class GenericProvider extends events_1.EventEmitter {
    constructor(options) {
        super();
        this._id = 0;
        this.encoder = typeof options.encoder !== 'undefined' ? options.encoder : new ethereum_utils_1.Encoder();
        this.accountId = options.accountId;
        this.gatewayConfig = options.gatewayConfig;
        this.unsafeRecipientIds = options.unsafeRecipientIds;
        this.assetLedgerSource = options.assetLedgerSource || 'https://conventions.0xcert.org/ethereum/xcert-mock.json';
        this.valueLedgerSource = options.valueLedgerSource || 'https://conventions.0xcert.org/ethereum/token-mock.json';
        this.signMethod = typeof options.signMethod !== 'undefined' ? options.signMethod : types_1.SignMethod.ETH_SIGN;
        this.requiredConfirmations = typeof options.requiredConfirmations !== 'undefined' ? options.requiredConfirmations : 1;
        this.mutationTimeout = typeof options.mutationTimeout !== 'undefined' ? options.mutationTimeout : 3600000;
        this.gasPriceMultiplier = typeof options.gasPriceMultiplier !== 'undefined' ? options.gasPriceMultiplier : 1.1;
        this.retryGasPriceMultiplier = typeof options.retryGasPriceMultiplier !== 'undefined' ? options.retryGasPriceMultiplier : 2;
        this.sandbox = typeof options.sandbox !== 'undefined' ? options.sandbox : false;
        this.verbose = typeof options.verbose !== 'undefined' ? options.verbose : false;
        this._client = options.client && options.client.currentProvider
            ? options.client.currentProvider
            : options.client;
    }
    log(message) {
        if (this.verbose) {
            console.log(message);
        }
    }
    get accountId() {
        return this._accountId || null;
    }
    set accountId(id) {
        id = this.encoder.normalizeAddress(id);
        if (!this.isCurrentAccount(id)) {
            this.emit(scaffold_1.ProviderEvent.ACCOUNT_CHANGE, id, this._accountId);
        }
        this._accountId = id;
    }
    get unsafeRecipientIds() {
        return this._unsafeRecipientIds || [];
    }
    set unsafeRecipientIds(ids) {
        this._unsafeRecipientIds = (ids || []).map((id) => this.encoder.normalizeAddress(id));
    }
    get gatewayConfig() {
        return this._gatewayConfig;
    }
    set gatewayConfig(config) {
        if (typeof config !== 'undefined') {
            this._gatewayConfig = {
                actionsOrderId: this.encoder.normalizeAddress(config.actionsOrderId),
                assetLedgerDeployOrderId: this.encoder.normalizeAddress(config.assetLedgerDeployOrderId),
                valueLedgerDeployOrderId: this.encoder.normalizeAddress(config.valueLedgerDeployOrderId),
            };
        }
        else {
            this._gatewayConfig = null;
        }
    }
    emit(...args) {
        super.emit.call(this, ...args);
        return this;
    }
    on(...args) {
        super.on.call(this, ...args);
        return this;
    }
    once(...args) {
        super.once.call(this, ...args);
        return this;
    }
    off(event, handler) {
        if (handler) {
            super.off(event, handler);
        }
        else {
            super.removeAllListeners(event);
        }
        return this;
    }
    sign(message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.accountId) {
                throw new Error('accountId not set.');
            }
            if (this.signMethod === types_1.SignMethod.PERSONAL_SIGN) {
                const res = yield this.post({
                    method: 'personal_sign',
                    params: [message, this.accountId, null],
                });
                return res.result;
            }
            else if (this.signMethod === types_1.SignMethod.ETH_SIGN) {
                const res = yield this.post({
                    method: 'eth_sign',
                    params: [this.accountId, message],
                });
                return res.result;
            }
            else {
                throw new Error('Signing method not implemented.');
            }
        });
    }
    getAvailableAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.post({
                method: 'eth_accounts',
                params: [],
            });
            return res.result.map((a) => this.encoder.normalizeAddress(a));
        });
    }
    getNetworkVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this.post({
                method: 'net_version',
                params: [],
            });
            return res.result;
        });
    }
    isCurrentAccount(accountId) {
        return this.accountId === this.encoder.normalizeAddress(accountId);
    }
    isUnsafeRecipientId(ledgerId) {
        const normalizedLedgerId = this.encoder.normalizeAddress(ledgerId);
        return !!this.unsafeRecipientIds.find((id) => id === normalizedLedgerId);
    }
    post(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = Object.assign({}, options);
            if (payload.method === 'eth_sendTransaction' && payload.params.length) {
                if (this.sandbox || typeof payload.params[0].gas === 'undefined') {
                    try {
                        const res = yield this.request(Object.assign(Object.assign({}, payload), { method: 'eth_estimateGas' }));
                        payload.params[0].gas = `0x${Math.ceil(res.result * 1.1).toString(16)}`;
                    }
                    catch (err) {
                        if (err && err.original && (err.original.code === -32603 || err.original.code === -32000)) {
                            payload.params.push('latest');
                            const res = yield this.request(Object.assign(Object.assign({}, payload), { method: 'eth_call' }));
                            throw new scaffold_1.ProviderError(scaffold_1.ProviderIssue.CONTRACT_ERROR, res.result);
                        }
                        else {
                            throw err;
                        }
                    }
                    if (this.sandbox) {
                        return { id: null, jsonrpc: null, result: payload.params[0].gas };
                    }
                    if (typeof payload.params[0].gasPrice === 'undefined') {
                        const res = yield this.request(Object.assign(Object.assign({}, payload), { method: 'eth_gasPrice', params: [] }));
                        payload.params[0].gasPrice = `0x${Math.ceil(res.result * this.gasPriceMultiplier).toString(16)}`;
                    }
                }
            }
            return this.request(payload);
        });
    }
    request(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = Object.assign({ jsonrpc: '2.0', id: options.id || this.getNextId(), params: [] }, options);
            return new Promise((resolve, reject) => {
                this._client.send(payload, (err, res) => {
                    if (err) {
                        this.log(err);
                        return reject(err);
                    }
                    else if (res.error) {
                        this.log(err);
                        return reject(res.error);
                    }
                    else if (res.id !== payload.id) {
                        return reject('Invalid RPC id');
                    }
                    return resolve(res);
                });
            }).catch((err) => {
                throw new scaffold_1.ProviderError(scaffold_1.ProviderIssue.GENERAL, err);
            }).then((value) => {
                if (payload.method === 'eth_call' && value && value.result && value.result.indexOf('0x08c379a0') !== -1) {
                    const errorCode = this.encoder.decodeParameters(['string'], `0x${value.result.substring(10)}`);
                    throw errors_1.parseError(errorCode[0]);
                }
                return value;
            });
        });
    }
    getNextId() {
        this._id++;
        return this._id;
    }
}
exports.GenericProvider = GenericProvider;
//# sourceMappingURL=provider.js.map