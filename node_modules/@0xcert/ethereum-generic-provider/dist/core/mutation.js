"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereum_utils_1 = require("@0xcert/ethereum-utils");
const scaffold_1 = require("@0xcert/scaffold");
const events_1 = require("events");
const types_1 = require("./types");
var MutationStatus;
(function (MutationStatus) {
    MutationStatus[MutationStatus["INITIALIZED"] = 0] = "INITIALIZED";
    MutationStatus[MutationStatus["PENDING"] = 1] = "PENDING";
    MutationStatus[MutationStatus["COMPLETED"] = 2] = "COMPLETED";
})(MutationStatus = exports.MutationStatus || (exports.MutationStatus = {}));
class Mutation extends events_1.EventEmitter {
    constructor(provider, id, context) {
        super();
        this._confirmations = 0;
        this._speed = 14000;
        this._status = MutationStatus.INITIALIZED;
        this._logs = [];
        this._id = id;
        this._provider = provider;
        if (this._provider.sandbox) {
            this._status = MutationStatus.COMPLETED;
        }
        this._context = context;
    }
    get id() {
        return this._id;
    }
    get provider() {
        return this._provider;
    }
    get confirmations() {
        return this._confirmations;
    }
    get senderId() {
        return this._senderId;
    }
    get receiverId() {
        return this._receiverId;
    }
    get logs() {
        return this._logs;
    }
    isPending() {
        return this._status === MutationStatus.PENDING;
    }
    isCompleted() {
        return this._status === MutationStatus.COMPLETED;
    }
    emit(...args) {
        super.emit.call(this, ...args);
        return this;
    }
    on(...args) {
        super.on.call(this, ...args);
        return this;
    }
    once(...args) {
        super.once.call(this, ...args);
        return this;
    }
    off(event, handler) {
        if (handler) {
            super.off(event, handler);
        }
        else {
            super.removeAllListeners(event);
        }
        return this;
    }
    complete() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = this._status === MutationStatus.INITIALIZED;
            if (this.isCompleted()) {
                return this.resolveCurrentState();
            }
            else if (!this.isPending()) {
                this._status = MutationStatus.PENDING;
                this._started = Date.now();
            }
            yield new Promise((resolve, reject) => {
                if (!this.isCompleted()) {
                    this.once(scaffold_1.MutationEvent.COMPLETE, () => resolve());
                    this.once(scaffold_1.MutationEvent.ERROR, (err) => reject(err));
                }
                else {
                    resolve();
                }
                if (start) {
                    this.loopUntilCompleted();
                }
            });
            return this;
        });
    }
    forget() {
        if (this._timer) {
            clearTimeout(this._timer);
            this._timer = undefined;
        }
        return this;
    }
    resolve() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.resolveCurrentState();
        });
    }
    retry() {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.getTransactionObject();
            if (!tx) {
                throw new Error('Mutation not found');
            }
            else if (tx.blockNumber) {
                throw new Error('Mutation already accepted onto the blockchain');
            }
            const gasPrice = yield this._provider.post({
                method: 'eth_gasPrice',
                params: [],
            });
            const oldGasPrice = tx.gasPrice;
            const retryGasPrice = gasPrice.result * this._provider.retryGasPriceMultiplier;
            const newGasPrice = retryGasPrice >= oldGasPrice ? retryGasPrice : oldGasPrice * this._provider.retryGasPriceMultiplier;
            const attrs = {
                from: tx.from,
                data: tx.input,
                nonce: tx.nonce,
                value: tx.value,
                gas: tx.gas,
                gasPrice: `0x${Math.ceil(newGasPrice).toString(16)}`,
            };
            if (tx.to) {
                attrs['to'] = tx.to;
            }
            const res = yield this._provider.post({
                method: 'eth_sendTransaction',
                params: [attrs],
            });
            this._id = res.result;
        });
    }
    cancel() {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.getTransactionObject();
            if (!tx) {
                throw new Error('Mutation not found');
            }
            else if (tx.blockNumber) {
                throw new Error('Mutation already accepted onto the blockchain');
            }
            else if (tx.from.toLowerCase() !== this._provider.accountId.toLowerCase()) {
                throw new Error('You are not the maker of this mutation so you cannot cancel it.');
            }
            const newGasPrice = `0x${Math.ceil(tx.gasPrice * 1.1).toString(16)}`;
            const attrs = {
                from: tx.from,
                to: tx.from,
                nonce: tx.nonce,
                value: '0x0',
                gasPrice: newGasPrice,
            };
            const res = yield this._provider.post({
                method: 'eth_sendTransaction',
                params: [attrs],
            });
            this._id = res.result;
        });
    }
    resolveCurrentState() {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.getTransactionObject();
            if (tx && (!tx.to || tx.to === '0x0')) {
                tx.to = yield this.getTransactionReceipt().then((r) => r ? r.contractAddress : null);
            }
            if (tx && tx.to) {
                this._senderId = ethereum_utils_1.normalizeAddress(tx.from);
                this._receiverId = ethereum_utils_1.normalizeAddress(tx.to);
                this._confirmations = yield this.getLastBlock()
                    .then((lastBlock) => lastBlock - parseInt(tx.blockNumber || lastBlock))
                    .then((num) => num < 0 ? 0 : num);
                if (this._confirmations >= this._provider.requiredConfirmations) {
                    yield this.parseLogs();
                    this._status = MutationStatus.COMPLETED;
                    return this.emit(scaffold_1.MutationEvent.COMPLETE, this);
                }
                else {
                    this.emit(scaffold_1.MutationEvent.CONFIRM, this);
                }
            }
        });
    }
    loopUntilCompleted() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.resolveCurrentState();
            if (this._provider.mutationTimeout === -1 || Date.now() - this._started < this._provider.mutationTimeout) {
                this._timer = setTimeout(this.loopUntilCompleted.bind(this), this._speed);
            }
            else {
                this.emit(scaffold_1.MutationEvent.ERROR, new Error('Mutation has timed out'));
            }
        });
    }
    getTransactionObject() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._provider.post({
                method: 'eth_getTransactionByHash',
                params: [this.id],
            });
            return res.result;
        });
    }
    getTransactionReceipt() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._provider.post({
                method: 'eth_getTransactionReceipt',
                params: [this.id],
            });
            return res.result;
        });
    }
    getLastBlock() {
        return __awaiter(this, void 0, void 0, function* () {
            const res = yield this._provider.post({
                method: 'eth_blockNumber',
            });
            return parseInt(res.result);
        });
    }
    parseLogs() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this._logs = [];
                const eventSignatures = this._context.getContext();
                if (!eventSignatures) {
                    return;
                }
                const transactionReceipt = yield this.getTransactionReceipt();
                transactionReceipt.logs.forEach((log) => {
                    const eventSignature = eventSignatures.find((e) => e.topic === log.topics[0]);
                    if (!eventSignature) {
                        this._provider.log(JSON.stringify(log));
                        return;
                    }
                    const obj = {};
                    obj['event'] = eventSignature.name;
                    obj['address'] = log.address;
                    const normal = eventSignature.types.filter((t) => t.kind === types_1.MutationEventTypeKind.NORMAL);
                    const indexed = eventSignature.types.filter((t) => t.kind === types_1.MutationEventTypeKind.INDEXED);
                    if (normal.length > 0) {
                        const normalTypes = normal.map((n) => n.type);
                        const decoded = this._provider.encoder.decodeParameters(normalTypes, log.data);
                        normal.forEach((n, idx) => {
                            obj[n.name] = decoded[idx];
                        });
                    }
                    indexed.forEach((i, idx) => {
                        obj[i.name] = this._provider.encoder.decodeParameters([i.type], log.topics[idx + 1])[0];
                    });
                    this._logs.push(obj);
                });
            }
            catch (e) {
                this._provider.log(e);
            }
        });
    }
}
exports.Mutation = Mutation;
//# sourceMappingURL=mutation.js.map