"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const merkle_1 = require("@0xcert/merkle");
const utils_1 = require("@0xcert/utils");
const data_1 = require("../utils/data");
class Cert {
    constructor(config) {
        this.schema = config.schema;
        this.merkle = new merkle_1.Merkle(Object.assign({ hasher: (v) => __awaiter(this, void 0, void 0, function* () { return utils_1.sha(256, data_1.toString(v)); }), noncer: (p) => __awaiter(this, void 0, void 0, function* () { return utils_1.sha(256, p.join('.')); }) }, config));
    }
    static getInstance(config) {
        return new Cert(config);
    }
    identify(normalize) {
        return __awaiter(this, void 0, void 0, function* () {
            return utils_1.sha(256, JSON.stringify(normalize !== false ? this.sortSchema(this.schema) : this.schema));
        });
    }
    notarize(data) {
        return __awaiter(this, void 0, void 0, function* () {
            const schemaProps = this.buildSchemaProps(data);
            const compoundProps = yield this.buildCompoundProps(schemaProps);
            const schemaRecipes = yield this.buildRecipes(compoundProps);
            return {
                $schema: 'https://conventions.0xcert.org/87-asset-evidence.json',
                data: schemaRecipes.map((recipe) => ({
                    path: recipe.path,
                    nodes: recipe.nodes,
                    values: recipe.values,
                })),
            };
        });
    }
    expose(data, paths) {
        const metadata = {};
        paths.forEach((path) => {
            const value = data_1.readPath(path, data);
            data_1.writePath(path, value, metadata);
        });
        return JSON.parse(JSON.stringify(metadata));
    }
    disclose(data, paths) {
        return __awaiter(this, void 0, void 0, function* () {
            const schemaProps = this.buildSchemaProps(data);
            const compoundProps = yield this.buildCompoundProps(schemaProps);
            const schemaRecipes = yield this.buildRecipes(compoundProps, paths);
            return {
                $schema: 'https://conventions.0xcert.org/87-asset-evidence.json',
                data: schemaRecipes.map((recipe) => ({
                    path: recipe.path,
                    nodes: recipe.nodes,
                    values: recipe.values,
                })),
            };
        });
    }
    calculate(data, evidence) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.checkDataInclusion(data, evidence.data)) {
                    return this.imprintRecipes(evidence.data);
                }
                else {
                    return null;
                }
            }
            catch (e) {
                return null;
            }
        });
    }
    imprint(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.notarize(data)
                .then((s) => s.data[0].nodes[0].hash)
                .catch(() => null);
        });
    }
    buildSchemaProps(data, schema = this.schema, prepend = []) {
        if (schema.type === 'array') {
            const items = (data || [])
                .map((v, i) => {
                return this.buildSchemaProps(v, schema.items, [...prepend, i]);
            })
                .reduce((a, b) => a.concat(b), []);
            return items.length > 0
                ? items
                : [this.buildSchemaProps(undefined, {}, [...prepend])];
        }
        else if (schema.type === 'object') {
            return Object.keys(schema.properties)
                .sort()
                .map((key) => {
                const prop = this.buildSchemaProps((data || {})[key], schema.properties[key], [...prepend, key]);
                return ['object', 'array'].indexOf(schema.properties[key].type) === -1 ? [prop] : prop;
            })
                .reduce((a, b) => a.concat(b), []);
        }
        else {
            return {
                path: prepend,
                value: data,
                key: prepend.join('.'),
                group: prepend.slice(0, -1).join('.'),
            };
        }
    }
    buildCompoundProps(props) {
        return __awaiter(this, void 0, void 0, function* () {
            props = [...props];
            const groupsByName = this.buildPropGroups(props);
            const groups = Object.keys(groupsByName).sort((a, b) => a > b ? -1 : 1)
                .filter((g) => g !== '');
            for (const group of groups) {
                const path = groupsByName[group];
                const values = [...props.filter((i) => i.group === group)]
                    .sort((a, b) => a.key > b.key ? 1 : -1)
                    .map((i) => i.value);
                const recipes = yield this.merkle.notarize(values, path);
                props.push({
                    path,
                    value: recipes.nodes[0].hash,
                    key: path.join('.'),
                    group: path.slice(0, -1).join('.'),
                });
            }
            return props.sort((a, b) => a.key > b.key ? 1 : -1);
        });
    }
    buildRecipes(props, paths = null) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = paths ? data_1.stepPaths(paths).map((p) => p.join('.')) : null;
            const groups = {};
            props.forEach((p) => groups[p.group] = p.path.slice(0, -1));
            return Promise.all(Object.keys(groups).map((group) => __awaiter(this, void 0, void 0, function* () {
                const values = props
                    .filter((p) => p.group === group)
                    .map((p) => p.value);
                let recipes = yield this.merkle.notarize(values, groups[group]);
                if (keys) {
                    const expose = props
                        .filter((p) => p.group === group)
                        .map((p, i) => keys.indexOf(p.key) === -1 ? -1 : i)
                        .filter((i) => i !== -1);
                    recipes = yield this.merkle.disclose(recipes, expose);
                }
                if (!keys || keys.indexOf(groups[group].join('.')) !== -1) {
                    return {
                        path: groups[group],
                        values: recipes.values,
                        nodes: recipes.nodes,
                        key: groups[group].join('.'),
                        group: groups[group].slice(0, -1).join('.'),
                    };
                }
            }))).then((r) => {
                return r.filter((v) => !!v);
            });
        });
    }
    checkDataInclusion(data, recipes) {
        const schemaProps = this.buildSchemaProps(data);
        recipes = data_1.cloneObject(recipes).map((p) => (Object.assign({ key: p.path.join('.'), group: p.path.slice(0, -1).join('.') }, p)));
        for (const prop of schemaProps) {
            const dataValue = data_1.readPath(prop.path, data);
            if (typeof dataValue === 'undefined') {
                continue;
            }
            const recipeGroup = prop.path.slice(0, -1).join('.');
            const recipe = recipes.find((p) => p['key'] === recipeGroup);
            if (!recipe) {
                return false;
            }
            const dataIndex = this.getPathIndexes(prop.path).pop();
            const recipeValue = recipe.values.find((v) => v.index === dataIndex);
            if (typeof recipeValue === 'undefined') {
                continue;
            }
            if (recipeValue.value !== dataValue) {
                return false;
            }
        }
        return true;
    }
    imprintRecipes(recipes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (recipes.length === 0) {
                return this.getEmptyImprint();
            }
            recipes = data_1.cloneObject(recipes).map((prop) => (Object.assign({ key: prop.path.join('.'), group: prop.path.slice(0, -1).join('.') }, prop))).sort((a, b) => a.path.length > b.path.length ? -1 : 1);
            for (const recipe of recipes) {
                const imprint = yield this.merkle.imprint(recipe).catch(() => '');
                recipe.nodes.unshift({
                    index: 0,
                    hash: imprint,
                });
                const groupKey = recipe.path.slice(0, -1).join('.');
                const groupPath = recipe.path.slice(0, -1);
                const groupIndex = this.getPathIndexes(recipe.path).slice(-1).pop();
                const groupRecipe = recipes.find((p) => p['key'] === groupKey);
                if (groupRecipe) {
                    groupRecipe.values.unshift({
                        index: groupIndex,
                        value: imprint,
                        nonce: yield this.merkle.nonce([...groupPath, groupIndex]),
                    });
                }
            }
            const rootRecipe = recipes.find((f) => f['key'] === '');
            if (rootRecipe) {
                return rootRecipe.nodes.find((n) => n.index === 0).hash;
            }
            else {
                return this.getEmptyImprint();
            }
        });
    }
    getPathIndexes(keys) {
        const indexes = [];
        let schema = this.schema;
        for (const key of keys) {
            if (schema.type === 'array') {
                indexes.push(key);
                schema = schema.items;
            }
            else if (schema.type === 'object') {
                indexes.push(Object.keys(schema.properties).sort().indexOf(key));
                schema = schema.properties[key];
            }
            else {
                indexes.push(undefined);
            }
        }
        return indexes;
    }
    getEmptyImprint() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.merkle.notarize([]).then((e) => e.nodes[0].hash);
        });
    }
    buildPropGroups(props) {
        const groups = {};
        props.map((p) => {
            const path = [];
            return p.path.map((v) => {
                path.push(v);
                return [...path];
            });
        }).reduce((a, b) => a.concat(b), []).forEach((p) => {
            return groups[p.slice(0, -1).join('.')] = p.slice(0, -1);
        });
        return groups;
    }
    sortSchema(obj) {
        return Object.keys(obj).sort().reduce((acc, key) => {
            if (Array.isArray(obj[key])) {
                acc[key] = obj[key].sort();
            }
            else if (typeof obj[key] === 'object') {
                acc[key] = this.sortSchema(obj[key]);
            }
            else {
                acc[key] = obj[key];
            }
            return acc;
        }, {});
    }
}
exports.Cert = Cert;
//# sourceMappingURL=cert.js.map