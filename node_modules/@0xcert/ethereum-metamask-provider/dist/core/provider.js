"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereum_generic_provider_1 = require("@0xcert/ethereum-generic-provider");
class MetamaskProvider extends ethereum_generic_provider_1.GenericProvider {
    constructor(options) {
        super(Object.assign(Object.assign({}, options), { signMethod: ethereum_generic_provider_1.SignMethod.PERSONAL_SIGN }));
        if (this.isSupported()) {
            this.installClient();
            this.installEvents();
        }
    }
    static getInstance() {
        return new this();
    }
    isSupported() {
        if (typeof window === 'undefined') {
            return false;
        }
        if (typeof window['ethereum'] !== 'undefined') {
            return (window['ethereum'].isMetaMask);
        }
        else if (typeof window['web3'] !== 'undefined') {
            return (typeof window['web3']['currentProvider'] !== 'undefined'
                && window['web3']['currentProvider'].isMetaMask);
        }
        else {
            return false;
        }
    }
    isEnabled() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSupported() || !this.accountId) {
                return false;
            }
            if (typeof window['ethereum'] !== 'undefined') {
                return this._client._metamask.isApproved();
            }
            else {
                return typeof window['web3'] !== 'undefined';
            }
        });
    }
    enable() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isSupported()) {
                return false;
            }
            this.accountId = typeof window['ethereum'] !== 'undefined'
                ? yield this._client.enable().then((a) => a[0])
                : window['web3']['eth']['coinbase'];
            return this;
        });
    }
    installClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof window['ethereum'] !== 'undefined') {
                this._client = window['ethereum'];
            }
            else {
                this._client = Object.assign(Object.assign({}, window['web3']['currentProvider']), { send(payload, callback) {
                        if (['eth_accounts', 'eth_coinbase', 'net_version'].indexOf(payload.method) !== -1) {
                            callback(null, window['web3']['currentProvider'].send(payload));
                        }
                        else {
                            window['web3']['currentProvider'].sendAsync(payload, callback);
                        }
                    } });
            }
        });
    }
    installEvents() {
        return __awaiter(this, void 0, void 0, function* () {
            const networkVersion = yield this.getNetworkVersion();
            if (networkVersion !== this._networkVersion) {
                this.emit(ethereum_generic_provider_1.ProviderEvent.NETWORK_CHANGE, networkVersion, this._networkVersion);
                this._networkVersion = networkVersion;
            }
            this.accountId = yield this.getAvailableAccounts().then((a) => a[0]);
            setTimeout(() => this.installEvents(), 1000);
        });
    }
}
exports.MetamaskProvider = MetamaskProvider;
//# sourceMappingURL=provider.js.map